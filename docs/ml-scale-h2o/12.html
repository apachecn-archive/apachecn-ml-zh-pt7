<html><head/><body>


	
		<title>B16721_09_Final_SK_ePub</title>
		
	
	
		<div><h1 id="_idParaDest-157"><em class="italic"> <a id="_idTextAnchor159"/>第九章</em>:制作评分和H2O魔咒</h1>
			<p>我们花了上一节的时间来学习如何利用H2O的大规模数据构建世界级的模型。在本章中，我们将学习如何部署这些模型并根据它们进行预测。首先，我们将介绍将模型投入生产评分系统的背景。然后，我们将了解H2O如何使这变得简单而灵活。这个故事的中心是H2O <strong class="bold"> MOJO </strong>(简称<strong class="bold">模型对象，优化</strong>)，一个从您的模型构建环境中导出的随时可部署的评分工件。我们将从技术上学习什么是MOJO以及如何部署它。然后，我们将编写一个简单的批处理文件评分程序，并在其中嵌入一个MOJO。我们将以一些关于魔咒的最后注释来结束。总之，在这一章中，你将发展以不同方式部署H2O模型的知识，从而开始从实时预测中获得价值。</p>
			<p>这些是我们将在本章中涉及的主要话题:</p>
			<ul>
				<li>将模型构建上下文与H2O模型的评分上下文相关联</li>
				<li>认识到H2O车型目标生产系统的多样性</li>
				<li>检查H2O可部署人造物品——H2O魔咒的技术设计</li>
				<li>编写自己的H2O MOJO批处理文件记分员，展示如何在自己的软件中嵌入MOJO</li>
			</ul>
			<h1 id="_idParaDest-158"><a id="_idTextAnchor160"/>技术要求</h1>
			<p>在本章中，您将需要一个Java SE 8或更高版本的环境。像Eclipse这样的Java IDE是可选的，但是很有用。您将在以下GitHub存储库中获得一个MOJO、一个要评分的数据集和批处理文件评分程序的Java代码:<a href="https://github.com/PacktPublishing/Machine-Learning-at-Scale-with-H2O/tree/main/chapt9">https://GitHub . com/packt publishing/Machine-Learning-at-Scale-with-H2O/tree/main/chapt 9</a>。这些工件是从第八章<a href="B16721_08_Final_SK_ePub.xhtml#_idTextAnchor137"><em class="italic"/></a><em class="italic">中构建的模型中生成的，将它们放在一起</em>。</p>
			<p>请注意，我们已经完成了模型构建，因此您不需要指向正在运行的H2O集群的模型构建环境。</p>
			<h1 id="_idParaDest-159"><a id="_idTextAnchor161"/>模型建立和模型评分环境</h1>
			<p>在<em class="italic">第2节</em>、<em class="italic">使用H2O在大数据量上构建最先进的模型</em>中，我们花了大量精力与H2O一起构建世界级的大规模模型。针对大规模数据集构建高度<a id="_idIndexMarker636"/>准确和可信的模型<a id="_idIndexMarker637"/>可能会为企业带来数百万美元的收入，拯救生命，并定义新的产品领域，但只有当模型被部署到生产系统时，才能进行预测并采取行动。</p>
			<p>在生产系统上进行部署和预测(或评分)的最后一步通常非常耗时、有问题，而且风险很大，原因稍后会讨论。H2O使从构建(训练)模型到部署模型的过渡变得容易。它还在评分位置(设备、web应用程序、数据库、微服务端点或Kafka队列)和数据速度(实时、批处理和流)方面提供了广泛的灵活性。而且，无论生产环境如何，H2O部署的模型得分快如闪电。</p>
			<p>这种易用性、灵活性和低延迟生产评分的核心是H2O魔咒。H2O MOJO是一个随时可以部署的评分工件，它是在您的模型构建代码的<a id="_idIndexMarker638"/>端由一个简单的导出命令生成的。不管生成H2O mojo的模型构建算法如何，它们都是相似的。因此，所有H2O型号的部署都是相似的。在进入MOJO并学习如何部署它之前，让我们先大致了解一下从模型训练到模型评分的过程。</p>
			<h2 id="_idParaDest-160"><a id="_idTextAnchor162"/>模特培训到生产模特打分</h2>
			<p>我们将首先概述模型如何从模型训练过渡到生产评分，然后看看H2O是如何做到这一点的。</p>
			<h3>从培训到评分的通用渠道</h3>
			<p>被训练成部署模型的<a id="_idIndexMarker639"/>的通用管道可以表示如下:</p>
			<div><div><img src="img/Figure_9.1_B16721.jpg" alt="Figure 9.1 – Generalized pipeline from model training to scoring &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图9.1–从模型训练到评分的通用管道</p>
			<p>请注意，这个<a id="_idIndexMarker640"/>管道由称为<strong class="bold">机器学习操作</strong> ( <strong class="bold"> MLOps </strong>)的实践更正式地表示和阐述，它涉及更大的关注领域，但是对于将模型部署到生产的<a id="_idIndexMarker641"/>焦点，这里的表示应该对我们有用。</p>
			<p>每个步骤总结如下:</p>
			<ol>
				<li><code>if-else</code>软件代码中的逻辑。这非常耗时，因为数据科学家必须将经过训练的模型的逻辑准确地传达给软件开发人员，而软件开发人员必须正确地实现该逻辑，然后对其进行彻底测试，以验证其准确性。这也容易出错，因此有风险，而且耗时。</li>
			</ol>
			<p>最好的情况是转换工具将训练好的模型转换成可部署的工件。这可以是一种格式(例如，XML for PMML、PFA或ONNX ),它为准备根据声明性结构进行计算的生产系统声明逻辑，也可以是可嵌入到软件程序或框架中的可运行软件工件(例如，Python wheel或Java JAR文件)。</p>
			<ol>
				<li value="2"><strong class="bold">可部署模型</strong>:转换后的模型被部署到生产系统中。这种编写的代码或<a id="_idIndexMarker643"/>转换的工件被集成到一个软件应用程序或框架中，在某个时候，将数据输入到它所拥有的评分逻辑中，并输出评分结果。比如一个客户的数据进去了，流失的概率就出来了。</li>
			</ol>
			<p>模型部署应该在测试和<strong class="bold">生产</strong> ( <strong class="bold">生产</strong>)环境中执行，通过<a id="_idIndexMarker645"/>一个使用<strong class="bold">持续集成和持续部署</strong> ( <strong class="bold"> CI/CD </strong>)管道的正式治理过程来完成<a id="_idIndexMarker644"/>部署和提升，就像一般的软件部署一样。跨所有构建的模型(例如，在不同的ML算法中)可识别和标准化的可部署工件<a id="_idIndexMarker646"/>在部署期间比那些不可识别和标准化的工件更容易自动化。</p>
			<ol>
				<li value="3"><strong class="bold">生产系统</strong>:生产现场评分。生产评分需求可以是多种多样的。例如，可能需要对<a id="_idIndexMarker647"/>一批中的整个数据库表、通过网络发送的每个实时ATM交易、客户的每个网页点击的web应用程序内部、或从边缘设备发送的传感器数据流进行评分。评分可以在设备上进行，也可以在云中的大型服务器上进行。通常，评分越快越好(每次评分少于50微秒或更快的要求并不少见)，评分器的大小和资源消耗越小，就越能部署到边缘。</li>
				<li><strong class="bold">预测</strong>:对输出进行评分。评分期间模型输出预测。请注意，预测需要业务环境和行动来实现目的或价值。例如，预测会流失的客户会得到电话或特别优惠<a id="_idIndexMarker648"/>来帮助确保他们仍然是客户。通常，评分输出不仅需要预测，还需要以原因代码的形式对这些预测进行解释。在为特定客户生成预测时，模型如何衡量计分器的每个输入？换句话说，在特定的预测中，哪些因素是最重要的。这些决策权重被表示为原因<a id="_idIndexMarker649"/>代码，它们有助于在客户流失的情况下个性化电话或特价。</li>
			</ol>
			<p>让我们看看H2O是如何实现从培训到得分的流程的。</p>
			<h3>H2O管道及其优势</h3>
			<p>训练有素的H2O模型参与到类似的管道中，但是具有重要的属性，使得<a id="_idIndexMarker650"/>它们易于部署到软件系统的不同目标，并且当它们在那里得分时也非常快。H2O的可部署工件被称为MOJO，它弥合了模型训练和模型评分之间的差距，故事中的中心人物也是如此。H2O管道的属性总结如下:</p>
			<p class="figure-caption">  </p>
			<div><div><img src="img/Figure_9.2_B16721.jpg" alt="Figure 9.2 – H2O's model training-to-scoring pipeline&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">图9.2-H2O的模型培训到评分流程</p>
			<p>让我们来阐述一下<a id="_idIndexMarker651"/>H2O部署模型的优势:</p>
			<ol>
				<li value="1"><strong class="bold"> H2O训练模型</strong>:H2O mojo从模型构建IDE中导出，准备部署。数据科学家通过在IDE中编写一行代码，将训练好的模型转换为导出的、随时可以部署的MOJO。</li>
				<li><strong class="bold">H2O MOJO</strong>:H2O MOJO是标准化的低延迟评分工件，随时可以部署。MOJO构造是标准化的，由所有模型类型共享，它有自己的运行时，嵌入在任何Java运行时中。这意味着所有的MOJOS(模型)都<a id="_idIndexMarker652"/>相同地嵌入到任何<strong class="bold"> Java虚拟机</strong> ( <strong class="bold"> JVM </strong>)中，独立于更大的软件和硬件环境。MOJOs也是轻量级的，可以部署到几乎所有的基础设施上(除了最小的边缘设备)。MOJOs的评分速度非常快，可以处理任何数据速度(实时评分、批量评分和流式评分)。</li>
				<li><strong class="bold">生产系统</strong> : H2O MOJOs灵活部署到多种生产系统。MOJOs部署到广泛的生产系统中。本章稍后将对这些系统进行概述，并详细介绍如何将MOJOS部署到这些系统上。</li>
				<li><strong class="bold">预测</strong>:mojo可以在他们的评分中输出很多信息。MOJO的输入以分类的类概率、回归的预测数值和无监督<a id="_idIndexMarker653"/>问题的模型特定结果的形式返回预测。此外，可选地，MOJOs可以Shapley或K-LIME值的形式返回原因代码，或其他属性，如预测的叶节点分配。</li>
			</ol>
			<p>让我们在下一部分更具体地关注H2O生产评分。</p>
			<h1 id="_idParaDest-161"><a id="_idTextAnchor163"/> H2O生产评分</h1>
			<p>当模型被投入生产以进行预测(或为一类无监督的问题生成无监督的结果)时，它们就实现了它们的商业价值。在本节中，我们将更详细地讨论从模型构建到生产评分的H2O管道。</p>
			<h2 id="_idParaDest-162"><a id="_idTextAnchor164"/>与H2O的端到端生产评分管道</h2>
			<p>请看下图，图中显示了从模型培训到模型部署和产品评分的端到端H2O流程:</p>
			<p class="figure-caption">图9.3-H2O全面评分管道的高级视图</p>
			<div><div><img src="img/Figure_9.3_B16721.jpg" alt="Figure 9.3 – High-level view of full scoring pipeline with H2O &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">通常，模型构建被认为是一个<strong class="bold">开发</strong> ( <strong class="bold">开发</strong>)环境，而模型评分是一个PROD环境，其源数据来自各个环境。</p>
			<p>对于开发，我们已经在<em class="italic">第2节</em>、<em class="italic">中广泛讨论了特征工程和模型训练(以及许多相关步骤，如<a id="_idIndexMarker656"/>模型解释和评估)，使用H2O </em>在大数据量上构建最先进的模型。在本章的前面，我们还简要地讨论了可导出的准备部署的H2O MOJO评分工件，并将其部署到生产系统。</p>
			<p>让我们确定在这个过程中需要记住的一些要点:</p>
			<p><em class="italic">您需要开发和生产之间的特性工程对等性</em>:这意味着任何创建训练数据集的特性工程必须与测试/生产中的评分输入相匹配。换句话说，训练数据集中的特征必须与输入模型评分的特征相同。如果在T15在开发中构建训练数据集之前，有多个特征工程步骤(例如，<strong class="bold">从数据源提取、转换和加载</strong> ( <strong class="bold"> ETL </strong>)和H2O苏打水的特征工程)，测试/生产中的评分输入必须具有那些相同的工程特征。</p>
			<ul>
				<li>话虽如此，根据MOJO的部署方式(H2O计分器、第三方集成或您自己的计分器)，您可能只需要输入测试/生产训练数据集中的一部分功能。这反映了这样一个事实，即经过训练的模型通常只选择对最终模型有贡献的数据特征的子集。然而，这个子集不是必需的；MOJOs可以接受全部或部分要素(与训练数据集相比),具体取决于您的设计方式。当我们在本章的后面更仔细地研究部署MOJOs时，这种灵活性将变得更加清晰。</li>
			</ul>
			<p>重要说明</p>
			<ul>
				<li><em class="italic">You may need a wrapper around your MOJO (but not with H2O Scorers and most third-party integrations)</em>: MOJOs are ready to deploy to a Java environment. This means the MOJO is ready to convert input data to a prediction output using the mathematical logic derived from model training and held in the MOJO, and that the MOJO itself does not need compiling or modification <a id="_idIndexMarker658"/>in any way. But, you must still make sure the input (for example, CSV, JSON, batch, and so on) feeds into the MOJO in a way that the MOJO can accept. On the other side, you may want to extract more from the MOJO scoring result than only predictions, and you will need to convert the MOJO output to a format expected downstream in the application. You do this by writing a simple Java wrapper class and using the MOJO API called <code>h2o-genmodel</code> API to interact with the MOJO. These wrapper classes are not complicated. We will learn more about wrapping MOJOs with an example later in this chapter.<p class="callout-heading">H2O计分器和许多MOJOs的第三方集成不需要包装器，因为它们在内部处理。在这些情况下，您需要的只是导出的MOJO。此外，许多集成是通过REST APIs与部署在REST服务器上的MOJOs端点进行的。</p><p class="callout"><em class="italic">您可能希望返回原因代码或其他信息以及您的预测</em> : MOJOs返回监督模型的预测和非监督模型的特定于模型的输出(例如，使用<code>H2OIsolationForestEstimator</code>训练的模型会返回异常分数)。但是，还有更多的检索从魔咒；您还可以将原因代码返回为K-LIME或Shapley值、基于树的模型所采用的决策路径或用于预测分类问题的分类标签。这些额外的输出在包装器代码中使用您构建的计分器的<code>h2o-genmodel</code> API来实现。它们可能内置于也可能不内置于H2O计分器的功能或现成的第三方集成中。你需要检查这些计分器的规格。</p></li>
				<li><em class="italic">您需要一个正式的流程来部署和管理您的模型</em>:将模型投入生产涉及风险:一般来说，在<a id="_idIndexMarker659"/>部署期间由于错误而导致的失败或延迟的风险，以及由于部署模型的模型决策的不利后果而导致的收入或声誉风险。我们将在第十四章<a href="B16721_14_Final_SK_ePub.xhtml#_idTextAnchor256"><em class="italic">、<em class="italic">更大平台背景下的H2O</em>中更深入地探讨这个话题。</em></a></li>
				<li><em class="italic">您需要MLOps来监控您的模型</em>:PROD中的模型通常需要被监控，以查看输入数据的值与训练数据中的值相比是否随时间而变化(这种结果称为数据漂移)。在这种情况下，模型可能需要重新训练，因为它训练所针对的信号已经改变，这可能导致模型的预测准确性降低。也可以监控偏差、预测分布和评分的其他方面。</li>
				<li>模型监控超出了MOJOs的能力范围。MOJOs关注的是单个分数。监控从根本上跟踪MOJO输入和输出的总体趋势，它是一个独立的技术领域和关注点，这里不做讨论。但是，请注意，H2O有一个执行模型监控和治理的MLOps平台。在<em class="italic">第16章</em>、<em class="italic">机器学习生命周期、人工智能应用和H2O人工智能混合云</em>中对其进行了概述。</li>
			</ul>
			<p>我们刚刚概述了从H2O模型制作到生产评分的整个流程，并确定了该流程的关键点。根据您的需求，这个管道的一部分是非常可变的:在其上部署您的MOJO的目标系统。让我们更详细地探讨这一点。</p>
			<p><a id="_idTextAnchor165"/>H2O mojo的目标生产系统</p>
			<h2 id="_idParaDest-163">MOJOs的一个大优势是它们可以被部署到广泛的生产系统中<a id="_idIndexMarker661"/>。让我们使用下图进行更深入的总结:</h2>
			<p>One large <a id="_idIndexMarker660"/>advantage of MOJOs is that they can be deployed <a id="_idIndexMarker661"/>to a wide range of production systems. Let's dig deeper using the following diagram to summarize:</p>
			<p class="figure-caption">图9.4-MOJO评分的生产系统分类</p>
			<div><div><img src="img/Figure_9.4_B16721.jpg" alt="Figure 9.4 – Taxonomy of production systems for MOJO scoring&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">业务需求在很大程度上决定了评分需要实时、批量还是流式，MOJOs可以处理所有这些数据速度。</p>
			<p>对于MOJO部署，将生产目标系统分为以下三个类别非常有用:</p>
			<p><strong class="bold"> H2O评分系统</strong>:这是H2O提供的H2O评分软件。这些评分器包括一个具有MLOps和丰富的模型监控和治理功能的REST服务器(以及一个生动的路线图，包括批量评分、冠军/挑战者测试、A/B测试等)，一个用于批量数据库表评分的数据库评分器，该评分器输出到一个表或文件，一个文件批量评分器，以及用于流事件的AMQ和卡夫卡评分器。H2O正在积极增加更多的得分手，所以请访问他们的网站以了解最新情况。在<em class="italic">第16章</em>、<em class="italic">机器学习生命周期、人工智能应用和H2O人工智能混合云</em>中更详细地讨论了MLOps计分器。</p>
			<ul>
				<li><strong class="bold">第三方集成</strong>:许多第三方集成了开箱即用的MOJOs，用于对他们的框架或软件进行评分。其他的需要一些胶水来创建一个定制的集成。</li>
				<li><strong class="bold">你自己的DIY系统</strong>:你可以在运行Java环境的软件或框架集成中嵌入MOJOs。集成将需要一个简单的Java <a id="_idIndexMarker662"/>包装器类来将您的<a id="_idIndexMarker663"/>应用程序或框架连接到MOJO数据输入和输出功能(例如，您的REST服务器需要将JSON转换成MOJO数据对象)。H2O用它的MOJO API让这变得简单。用MOJO API包装将在本章后面的代码示例中详细讨论。</li>
				<li>请注意，本章介绍了如何将MOJOs部署到目标系统。整个<a href="B16721_10_Final_SK_ePub.xhtml#_idTextAnchor178"> <em class="italic">第10章</em> </a>、<em class="italic"> H2O模型部署模式、</em>都将致力于浏览MOJO部署到目标系统的多个示例。</li>
			</ul>
			<p>现在我们已经了解了从模型构建到不同制作系统上的实时评分的端到端H2O管道，让我们更仔细地看看它的核心角色:MOJO。</p>
			<p><a id="_idTextAnchor166"/> H2O魔咒深潜</p>
			<h1 id="_idParaDest-164">从部署和评分的角度来看，所有的MOJOs基本上都是相似的。从上游模型构建的角度来看，无论MOJO的来源如何，也就是说，无论H2O广泛多样的模型构建算法(例如，广义线性模型和XGBoost)和技术(例如，堆叠集成和AutoML)以及训练数据集大小(从GBs到TBs)中的哪一种被用于构建最终模型，都是如此。</h1>
			<p>让我们更详细地了解一下这种魔力。</p>
			<p>什么是魔咒？</p>
			<h2 id="_idParaDest-165">一个<strong class="bold"> MOJO </strong>代表优化的模型对象。通过运行下面的代码行<a id="_idIndexMarker666"/>,它从您的模型构建IDE中导出:</h2>
			<p>这会将一个唯一命名的<code>.zip</code>文件下载到您的IDE文件系统中您指定的路径。这个<code>.zip</code>文件就是MOJO，这就是部署的内容。您不需要解压缩它，但是如果您好奇的话，它包含一个描述MOJO的<code>model.ini</code>文件和多个<code>.bin</code>文件，所有这些文件都由<strong class="bold"> MOJO运行时</strong>使用。</p>
			<pre class="source-code">model.download_mojo(path="path/for/my/mojo")</pre>
			<p>什么是MOJO运行时？这是一个名为<code>h2o-genmodel.jar</code>的Java <code>.jar</code>文件，是用于<a id="_idIndexMarker667"/>所有H2O核心MOJOs的通用运行时。换句话说，MOJO是特定于从它们<a id="_idIndexMarker668"/>中派生出来的训练模型的，并且所有的MOJO都被同样地加载到MOJO运行时中。MOJO运行时与Java运行时集成(在H2O软件、第三方软件或您自己的软件中)。下图将MOJO与MOJO运行时相关联。</p>
			<p>What is a MOJO runtime? This is a Java <code>.jar</code> file called <code>h2o-genmodel.jar</code> and is a generic runtime for <a id="_idIndexMarker667"/>all H2O Core MOJOs. In other words, MOJOs are specific to the trained models they <a id="_idIndexMarker668"/>are derived from, and all MOJOs are loaded identically into the MOJO runtime. The MOJO runtime integrates with a Java runtime (in H2O software, third-party software, or your own software). The following diagram relates MOJOs to the MOJO runtime.</p>
			<p class="figure-caption">图9.5-MOJO和MOJO运行时</p>
			<div><div><img src="img/Figure_9.5_B16721.jpg" alt="Figure 9.5 – MOJOs and the MOJO runtime&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">如前所述，MOJOs被部署到一个Java运行时上，更正式的说法是作为一个<a id="_idIndexMarker669"/>依赖库的<code>h2o-genmodel.jar</code>来完成这项工作。软件使用<code>h2o-genmodel</code> API将特定于模型的MOJO加载到通用<code>h2o-genmodel.jar</code>运行时<a id="_idIndexMarker670"/>中。应用程序代码中的实际评分逻辑也使用<code>h2o-genmodel.jar</code>及其API来实现评分和从嵌入式MOJO中提取结果。</p>
			<p>让我们在下一节深入探讨。</p>
			<p><a id="_idTextAnchor168"/>部署MOJO</p>
			<h2 id="_idParaDest-166">如果您将MOJO部署到H2O计分器或集成了MOJO的第三方软件，您只需要MOJO。在这些情况下，您不需要考虑MOJO运行时和API。这是因为这些软件系统已经在幕后实现了<code>h2o-genmodel.jar</code>(使用<code>h2o-genmodel</code> API)，换句话说，在部署和运行的H2O计分器或第三方软件中。</h2>
			<p>在其他情况下，您需要编写嵌入MOJO并提取其评分结果的代码。这段代码通常是一个使用<code>h2o-genmodel</code> API的Java包装类。稍后我们将使用一个代码示例来访问它。</p>
			<p>这种区别很重要，值得加大标注。</p>
			<p>MOJO部署的主要区别</p>
			<p class="callout-heading">当部署到H2O评分软件或集成MOJO的第三方软件时，您只需要MOJO即可(基于配置)。</p>
			<p class="callout">当将MOJO集成到您自己的软件或没有集成MOJO的第三方软件中时，您需要使用<code>h2o-genmodel</code> API编写一个简单的Java包装类。这个包装器需要<code>h2o-genmodel.jar</code>，这是<code>h2o-genmodel</code> API所代表的库。</p>
			<p class="callout">(如果您正在REST服务器上的第三方软件或您自己的软件中使用MOJO预测，您当然不需要MOJO或MOJO运行时。您只需要遵守MOJO的REST端点API。)</p>
			<p class="callout">让我们来看看需要编写包装器的情况。</p>
			<p><a id="_idTextAnchor169"/>使用H2O MOJO API包装MOJO</p>
			<h1 id="_idParaDest-167">在学习如何将MOJOs包装到更大的软件程序中之前，让我们先来接触一些<a id="_idIndexMarker672"/>前兆。</h1>
			<p><a id="_idTextAnchor170"/>获取MOJO运行时</p>
			<h2 id="_idParaDest-168">当你在模型<a id="_idIndexMarker674"/>建立后从IDE下载你的MOJO时，你可以下载<code>h2o-genmodel.jar</code>。这只是在下载语句中添加一个新的参数，如下所示:</h2>
			<p>这种获得<code>h2o-genmodel.jar</code>的方法通常不会在受治理的生产部署中完成。这是因为<code>h2o-genmodel.jar</code>对所有的MOJOs都是通用的，是软件开发人员而不是数据科学家关心的问题。</p>
			<pre class="source-code">Model.download_mojo(path="path/for/my/mojo", </pre>
			<pre class="source-code">                    get_genmodel_jar=True)</pre>
			<p>软件开发者可以从位于https://mvnrepository.com/artifact/ai.h2o/h2o-genmodel的Maven仓库下载MOJO运行时。<code>h2o-genmodel.jar</code>是向后兼容的；它应该适用于H2O-3(或苏打水)版本产生的等于或小于<code>h2o-genmodel.jar</code>版本的魔咒。</p>
			<p>获取MOJO运行时的技巧(h2o-genmodel.jar)</p>
			<p class="callout-heading">数据科学家不必每次从他们的建模ide下载MOJO时都下载MOJO运行时。这是因为MOJO运行时对所有MOJO都是通用的。最佳实践是让您的开发人员(而不是数据科学家)在需要时获取并使用MOJO运行时进行生产部署。这可以通过前面提到的Maven存储库来完成。</p>
			<p class="callout"><a id="_idTextAnchor171"/>H2O-gen model API</p>
			<h2 id="_idParaDest-169"><a id="_idIndexMarker676"/>API的javadoc位于<a href="https://docs.h2o.ai/h2o/latest-stable/h2o-genmodel/javadoc/index.html">https://docs . H2O . ai/H2O/latest-stable/H2O-gen model/javadoc/index . html</a>。注意<a id="_idIndexMarker677"/>这是为最新的H2O-3(或苏打水)准备的。要获得<a id="_idIndexMarker678"/>不同版本，请前往<a href="https://docs.h2o.ai/prior_h2o/index.html">https://docs.h2o.ai/prior_h2o/index.html</a>。</h2>
			<p>总之，<code>h2o-genmodel</code> API用于围绕MOJO构建包装器，因此您的应用程序可以向MOJO提供数据，从中提取预测和决策信息，并将这些结果转换为包装器中的代码。包装器通常是你的<a id="_idIndexMarker679"/>大型应用程序的一部分，可以被看作是你的应用程序和MOJO之间的粘合剂。</p>
			<p>让我们开始吧。</p>
			<p>包装你的魔力的通用方法</p>
			<h2 id="_idParaDest-170">在编写代码之前，先看看您开发的MOJO包装器的应用程序代码的逻辑流程将会很有用。这可以从下图中看出:</h2>
			<p>It will be useful <a id="_idIndexMarker680"/>before writing code to first look at the logical flow of application code for the MOJO wrapper you develop. This can be seen in the following diagram:</p>
			<p class="figure-caption">图9.6–包装MOJO的逻辑视图</p>
			<div><div><img src="img/Figure_9.6_B16721.jpg" alt="Figure 9.6 – Logical view of wrapping a MOJO&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Java包装器通常是它自己的类(或类的一部分),导入<code>h2o-genmodel.jar</code>,并遵循以下一般逻辑步骤:</p>
			<p>将<code>yourMOJO.zip</code>加载到MOJO运行时。回想一下<code>h2o-genmodel.jar</code>是运行时，它保存了处理特定于模型的MOJOs的一般逻辑。这个运行时现在可以在您的特定模型上运行了。</p>
			<ol>
				<li value="1">将数据输入MOJO。为此，使用<code>h2o-genmodel</code>代码将输入的Java数据结构转换成MOJO数据结构。</li>
				<li>获得魔力。这是一行<code>h2o-genmodel</code>代码。</li>
				<li>从MOJO评分结果中提取您需要的信息子集。回想一下，预测结果(或无监督结果)表示预测的各个方面(标签和预测)以及评分决策的各个方面(原因代码、叶节点结果的决策路径等)。</li>
				<li>将提取的<a id="_idIndexMarker681"/>结果转换成应用下游需要的数据结构。</li>
				<li>让我们写一个包装器。</li>
			</ol>
			<p><a id="_idTextAnchor173"/>包装示例–用Java构建批处理文件计分器</p>
			<h2 id="_idParaDest-171">我们正在编写的包装器的目标是对文件中的新数据进行批量评分。评分<a id="_idIndexMarker682"/>的输出将是输入记录、预测和原因代码，所有这些都格式化为一行CSV<a id="_idIndexMarker683"/>。原因代码将是<a id="_idIndexMarker684"/>单个CSV字段，但原因代码将由管道分隔。</h2>
			<p>我们将把这个包装类编译成一个可运行的程序，它接受三个输入参数:</p>
			<p>输入参数1: <code>path/of/batch/file/to/score</code></p>
			<ul>
				<li>输入参数2: <code>path/to/yourMOJO.zip</code></li>
				<li>Shapley值增加了延迟</li>
				<li>Input param 3 (optional): The <code>—shap</code> flag to trigger the return of Shapley reason codes in addition to the scoring prediction for each row in the file<p class="callout-heading">请记住，返回Shapley值会增加额外的计算，因此会增加每次评分的延迟。如果延迟很关键，您可能希望在结果中对有无Shapley原因代码的延迟进行基准测试，以评估是否将它们包括在评分中。</p><p class="callout">我们将使用您在<a href="B16721_08_Final_SK_ePub.xhtml#_idTextAnchor137"> <em class="italic">第8章</em> </a>、<em class="italic"/>中的模型构建练习结束时导出的魔咒。</p></li>
			</ul>
			<p>代码</p>
			<h3>我们的批处理文件计分程序将涉及一个单一的Java类，不包括错误处理和其他<a id="_idIndexMarker685"/>生产质量软件设计。我们的目的是展示将MOJO集成到软件中的基本原理。</h3>
			<p>请注意，下面的代码示例是逐步详细说明的。要从头到尾访问完整的Java代码，请访问位于<a href="https://github.com/PacktPublishing/Machine-Learning-at-Scale-with-H2O/tree/main/chapt9">https://GitHub . com/packt publishing/Machine-Learning-at-Scale-with-H2O/tree/main/chapt 9</a>的GitHub资源库。</p>
			<p>让我们开始吧:</p>
			<p><code>BatchFileScorer</code>。由于这也是一个可执行程序，我们将创建一个<code>main</code>方法来启动代码执行。注意<code>h2o-genmodel</code>库包的<code>import</code>声明:<pre>Import java.io.*; import hex.genmodel.easy.RowData; import hex.genmodel.easy.EasyPredictModelWrapper; import hex.genmodel.easy.prediction.*; import hex.genmodel.MojoModel;  public class BatchFileScorer {   public static void main(String[] args) throws Exception{   // we will fill with steps 2 to 4 that follows   } }</pre></p>
			<ol>
				<li value="1">现在，让我们用代码填充<code>main</code>方法，如以下步骤所示。</li>
			</ol>
			<p><strong class="bold">检索输入参数</strong>:我们从程序的参数中检索输入参数:<pre>// get input parameters File fileToScore = new File(args[0]); String pathToMojo = args[1]; boolean doShapley = args.length == 3   &amp;&amp; args[2].equals("--shap"); </pre></p>
			<ol>
				<li value="2"><strong class="bold">加载MOJO并将其配置为可选地返回原因代码</strong>:我们将<a id="_idIndexMarker686"/> MOJO加载到MOJO运行时并将其配置为返回Shapley值:<pre>// Load the mojo (only once) and configure EasyPredictModelWrapper.Config config =    new EasyPredictModelWrapper.Config(); config.setModel(MojoModel.load(pathToMojo); if (doShapley) config.setEnableContributions(true); EasyPredictModelWrapper model =    new EasyPredictModelWrapper(config);</pre></li>
				<li>在代码后面的所有评分之前，MOJO在这里只加载一次。</li>
			</ol>
			<p>重要的设计点——加载一次您的MOJO</p>
			<p class="callout-heading">加载MOJO可能需要几秒钟，但它只需要加载到您的程序中一次。</p>
			<p class="callout">在发出所有评分请求之前，在包装类中加载一次MOJO(例如，当它初始化时)。你不希望你的低于100毫秒或低于10毫秒的分数之前都有几秒钟的加载时间。</p>
			<p class="callout">现在来看看魔法:生成预测。</p>
			<p><em class="italic">步骤1 </em> : <pre>// get each record from the file BufferedReader br = new BufferedReader(new   FileReader(fileToScore)); // we are skipping the first line (header line) br.readLine(); String record = null; while ((record = br.readLine()) != null) {   // Convert input record to type required by mojo api   RowData mojoRow = convertInput(record);   // make the prediction   BinomialModelPrediction p = model.predictBinomial(mojoRow);   // get results from p and format it to your needs   // in this case, format is csv to write to file   String outputString = formatOutput(record, p, doShapley);   // can write this to file    // but printing to screen for ease of code explanation   System.out.println(outputString);   }</pre>中显示的<code>import</code>语句</p>
			<ol>
				<li value="4">就是这样！您已经加载了MOJO并配置了评分，并且对文件的每一行进行了评分。为了评分，您已经将每条记录从它的应用程序表示(CSV字符串)转换为<code>h2o-genmodel</code>表示(<code>DataRow</code>对象)。您已经编写了一行代码<a id="_idIndexMarker688"/>来记录分数。此外，您还从评分结果中检索了预测和Shapley原因代码(可选)。然后将它格式化为应用程序使用的表示形式。</li>
			</ol>
			<p>深入到代码</p>
			<h3>让我们深入前面代码中的<a id="_idIndexMarker689"/>方法。</h3>
			<p>方法钻取–将您的应用程序数据对象转换为h2o-genmodel数据对象</p>
			<h4>注意，<code>RowData mojoRow</code>是程序代码被转换成<code>h2o-genmodel</code> API数据<a id="_idIndexMarker690"/>对象的地方。在本例中，这是通过如下所示的<code>convertInput(record)</code>方法完成的:</h4>
			<p>我们简单地使用逗号作为分隔符来分割输入，并将每个值分配给H2O <code>RowData</code>对象，它本质上是一个键-值对的映射，其中的键代表<a id="_idIndexMarker691"/>特性名称(即列标题)。使用<code>RowData</code>还有其他选择。</p>
			<pre class="source-code">private static RowData convertInput(String record) {</pre>
			<pre class="source-code">  String[] featureValues = record.split(",");</pre>
			<pre class="source-code">  RowData row = new RowData();</pre>
			<pre class="source-code">  row.put("purpose_te", featureValues[0]);</pre>
			<pre class="source-code">  row.put("addr_state_te", featureValues[1]);</pre>
			<pre class="source-code">  row.put("loan_amnt", featureValues[2]);</pre>
			<pre class="source-code">  row.put("term", featureValues[3]);</pre>
			<pre class="source-code">  row.put("installment", featureValues[4]);</pre>
			<pre class="source-code">  row.put("grade", featureValues[5]);</pre>
			<pre class="source-code">  // omitting features 6 to 24, see code in github repo </pre>
			<pre class="source-code">  row.put("emp_length_missing", featureValues[25]);</pre>
			<pre class="source-code">  return row;</pre>
			<pre class="source-code">}</pre>
			<p>设计决策——将数据对象转换为MOJO API数据对象的选择</p>
			<p class="callout-heading">正如我们在这里所做的，使用<code>h2o-genmodel</code> API的<code>RowData</code>类只是将应用程序数据对象转换成<code>h2o-genmodel</code>对象以提供给MOJO评分的一种方式。查看API，了解可以为您的实现提供更好的代码设计的其他方法。</p>
			<p class="callout">方法钻取–要评分的单行</p>
			<h4>只需要一行代码来对MOJO评分并检索结果:</h4>
			<p>注意，你可能需要一个不同于<code>BinomialModelPrediction</code>的类，这取决于你构建的<a id="_idIndexMarker693"/>模型的类型。查看<code>h2o-genmodel</code> Javadocs，了解使用哪个Java类以及返回什么评分信息的详细信息。</p>
			<pre class="source-code">BinomialModelPrediction p = model.predictBinomial(mojoRow); </pre>
			<p>方法钻取–收集结果并格式化输出</p>
			<h4>我们<a id="_idIndexMarker694"/>最终使用<code>formatOutput(record, p, doShapley)</code>方法从评分结果中构造了<a id="_idIndexMarker695"/>一个字符串。下面是该方法的实现方式:</h4>
			<p>这里的要点是预测结果保存在从评分返回的<code>h2o-genmodel</code> API的<code>BinomialModelPrediction p</code>对象中。我们可以从这个物体中获取很多信息。在我们的例子中，我们检索了由<code>p.label</code>标识的预测类及其概率<code>p.classProbabilities[0]</code>。由于这是一个<code>BinomialModelPrediction</code>，其他类的概率将由<code>p.classProbabilities[1]</code>检索。</p>
			<pre class="source-code">private static String formatOutput(String record,</pre>
			<pre class="source-code">  BinomialModelPrediction p, boolean doShapley) {</pre>
			<pre class="source-code">  // start the ouput string with the record being scored</pre>
			<pre class="source-code">  String outputString = record;</pre>
			<pre class="source-code">  // add prediction to output string</pre>
			<pre class="source-code">  outputString += "   PREDICTION (good=0, bad=1): " + p.label</pre>
			<pre class="source-code">  + " " + p.classProbabilities[0];</pre>
			<pre class="source-code">  // add Shapley values (bar-delimited) to output string</pre>
			<pre class="source-code">  if(doShapley) {</pre>
			<pre class="source-code">    outputString += "  SHAP VALUES &gt; 0.01: ";</pre>
			<pre class="source-code">    for (int i=0; i &lt; p.contributions.length; i++) {</pre>
			<pre class="source-code">        // retrieving only Shap values over 0.01</pre>
			<pre class="source-code">        if (p.contributions[i] &lt;  0.01) continue;</pre>
			<pre class="source-code">        outputString += model.getContributionNames()[i] + ": "</pre>
			<pre class="source-code">        + p.contributions[i] + "|" ;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    return outputString;</pre>
			<pre class="source-code">}</pre>
			<p>然后，我们遍历Shapley原因贡献名称(<code>model.getContributionNames()[i]</code>)和值(<code>p.contributions[i]</code>)的数组。在我们的例子中，我们只检索值超过<code>0.01</code>的原因代码。或者，以<a id="_idIndexMarker696"/>为例，我们可以按值对原因进行排序，并返回前五名。返回所有原因时，偏差作为数组中的最后一个返回，所有要素和偏差的总和等于模型的原始预测值。</p>
			<p>总之，我们使用了一堆代码将所有这些格式化成一个CSV字符串，从原始记录开始，然后附加预测的类及其概率，然后是一个用竖线分隔的原因代码列表。</p>
			<p>运行代码</p>
			<h3>要运行<a id="_idIndexMarker698"/>应用程序，将<code>BatchFileScorer.java</code>和<code>h2o-genmodel.jar</code>编译成一个名为<code>BatchFileScorer.jar</code>的可执行JAR文件。然后，在与<code>BatchFileScorer.jar</code>相同的目录下运行以下命令:</h3>
			<p>要检索Shapley原因代码，将<code>--shap</code>追加到语句中。</p>
			<pre>java -jar BatchFileScorer.jar \  
path/to/file/to/score \
path/to/mojo</pre>
			<p><a id="_idTextAnchor174"/>关于魔咒的其他知识</p>
			<h1 id="_idParaDest-172">现在，您已经准备好部署MOJOs了，无论是否需要包装器，如前一节所述。让我们通过解决下面的次要问题来总结我们的MOJOs知识。</h1>
			<p><a id="_idTextAnchor175"/>检查MOJO决策逻辑</p>
			<h2 id="_idParaDest-173">对于基于树的模型，您可以使用内置于<code>h2o-genmodel.jar</code>的实用程序来生成MOJO中树逻辑的<a id="_idIndexMarker699"/>图形表示。以下是方法。</h2>
			<p>让我们使用我们在前面构建包装类的编码示例中使用的相同的MOJO。在<code>h2o-genmodel.jar</code>所在的命令行上，运行以下命令:</p>
			<p>这将创建一个如下所示的<code>.png</code>文件:</p>
			<pre>java -cp h2o-genmodel.jar hex.genmodel.tools.PrintMojo \ 
-i "path/to/mojo" \
-o tree.png \
--format png \
--tree 0</pre>
			<p>This will create a <code>.png</code> file that looks like this:</p>
			<p class="figure-caption">图9.7–print mojo实用程序的输出</p>
			<div><div><img src="img/Figure_9.7_B16721.jpg" alt="Figure 9.7 – Output of the PrintMojo utility&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">注意，如果您省略了<code>--tree 0</code>，您将生成一个包含所有树的目录。我们已经指定只返回第一个。</p>
			<p>也可以<a id="_idIndexMarker700"/>用<code>dot</code>代替<code>--format</code>。这产生了一种第三方<strong class="bold"> Graphviz </strong>实用程序可以使用的格式，使图形表示比<em class="italic">图9.7 </em>中显示的更加美观。</p>
			<p>或者，如果您希望将这个输出包含在编程中使用，对于<code>–format</code>，声明<code>.json</code>，它将文件输出为JSON格式。</p>
			<p>有关更多详细信息和配置备选方案，请参见H2O文档:<a href="https://docs.h2o.ai/h2o/latest-stable/h2o-docs/productionizing.html#viewing-a-mojo-model">https://docs . H2O . ai/H2O/latest-stable/H2O-docs/productionizing . html # viewing-a-mojo-model</a>。</p>
			<p><a id="_idTextAnchor176"/> MOJO和POJO</p>
			<h2 id="_idParaDest-174">好吧，让我们这么说吧:魔咒不是唯一的H2O可部署工件。在<a id="_idIndexMarker702"/>mojo之前，只有<code>h2o-genmodel</code> API来构建包装器<a id="_idIndexMarker704"/>类，正如我们之前讨论的。他们也有点不同。让我们比较，对比，总结。</h2>
			<p>MOJO和POJO的相似之处</p>
			<h3>以下是<a id="_idIndexMarker706"/>mojo和POJOs的相似之处:</h3>
			<p>它们都是在构建模型后从IDE中导出的(或者从H2O流UI中导出)。</p>
			<ul>
				<li>它们都以相同的方式部署:它们都运行在JVM中，根据目标评分系统(H2O评分系统、第三方或您自己的软件程序)有包装器或无包装器的区别，它们都使用MOJO运行时(<code>h2o-genmodel.jar</code>)和相同的API和Javadoc。</li>
				<li>MOJO和POJO的差异</li>
			</ul>
			<h3>以下是mojo<a id="_idIndexMarker708"/>和POJOs的<a id="_idIndexMarker707"/>区别:</h3>
			<p>POJO导出为需要编译的单个<code>.java</code>文件，而MOJO导出为单个<code>.zip</code>文件，如前所述。</p>
			<ul>
				<li>POJOs包含整个树来导航模型，而MOJOs包含树元数据并在<code>h2o-genmodel.zip</code>中使用通用树遍历代码来导航模型。树结构越大，POJO就越大。</li>
				<li>POJOs比mojo大得多(通常大20-25倍)，得分时比mojo慢(慢2-3倍)。一般来说，POJO越大，它与任何基于相同模型构建的MOJO相比就越慢。</li>
				<li>大型POJOs可能会有编译问题。H2O不支持超过1 GB的POJOs。</li>
				<li>何时使用MOJO或POJO</li>
			</ul>
			<h3>您应该将POJOs视为已弃用但仍受支持(除了大于1GB)的，并且有时在<a id="_idIndexMarker709"/>边缘情况下需要。要知道MOJOs并不是所有算法都完全支持的，所以在这些情况下，你不得不使用POJOs。因此，在可能的情况下使用MOJOs，在不太可能的情况下使用POJOs。</h3>
			<p>部署决策–MOJO还是POJO？</p>
			<p class="callout-heading">将MOJOs视为当前的首选技术，将POJOs视为与部署类似但已被弃用但仍受支持的技术(除了大于1 GB的技术)。MOJOs的优势主要在于得分速度和占地面积。</p>
			<p class="callout">某些算法不支持MOJOs。查看H2O文档，了解当前对MOJOs和POJOs的支持注意事项。</p>
			<p class="callout">我们现在准备总结。</p>
			<p><a id="_idTextAnchor177"/>总结</p>
			<h1 id="_idParaDest-175">我们从从模型构建到模型部署的高层次视角开始了这一章。我们看到，MOJO为H2O的这一过渡搭建了桥梁，MOJO是一种可部署的已训练模型的表示形式，易于从模型构建中生成，并且易于部署以实现快速模型评分。</h1>
			<p>然后，我们仔细研究了MOJOs可以部署的目标系统的范围，发现这些系统必须在Java运行时中运行，否则就会非常多样化。MOJOs可以在实时、批处理和流式系统上进行评分，分为H2O评分器(由H2O提供和支持的评分软件)、第三方集成(由H2O以外的公司提供和支持的软件)和您的软件集成(您构建和维护的软件)。</p>
			<p>目标系统的这种分类有助于我们确定您是否可以直接部署导出的MOJO，或者您是否需要使用<code>h2o-genmodel</code> API将其包装在Java类中，以将其嵌入评分软件中。H2O计分器和一些第三方计分器只需要导出的MOJO，不需要实现包装器。</p>
			<p>然后，我们详细研究了MOJO和MOJO运行时，以及它们与需要和不需要包装器的部署之间的关系。我们描述了MOJO包装器的一般结构，并编写了一个包装器来对文件中的记录进行批量评分。我们的编码让我们对MOJO API有了更好的理解，该API用于与您的应用程序中的MOJO进行交互。这种理解包括如何使用API来加载MOJO、将数据结构化为MOJO可以使用的类型、使用MOJO进行评分，以及从评分结果中检索预测和原因代码。</p>
			<p>然后，我们学习了如何在MOJO API中使用一个方便的工具来为您的模型获取MOJO中决策逻辑的可视化、JSON或dot表示。</p>
			<p>最后，我们介绍了MOJO的前身POJO，并将其描述为在MOJO API的部署和使用方面与MOJO相似，但不赞成使用，但仍受支持，因此用于MOJO不能使用的少数情况。</p>
			<p>现在，我们非常详细地了解了MOJO，以及它是如何灵活地部署到各种生产评分系统的。让我们进入下一章，我们将通过描述这些系统上的具体MOJO部署来展示这种灵活性和多样性。</p>
			<p>Now, we understand in great detail the MOJO and how it is flexibly deployed to a diversity of production scoring systems. Let's move to the next chapter where we will exhibit this flexibility and diversity by describing concrete MOJO deployments on a handful of these systems.</p>
		</div>
	

</body></html>