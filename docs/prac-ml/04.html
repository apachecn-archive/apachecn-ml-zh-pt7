<html><head/><body>



<title>Chapter 4. Machine Learning Tools, Libraries, and Frameworks</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title"><a id="ch04"/>第四章。机器学习工具、库和框架</h1></div></div></div><p>在前一章中，我们介绍了机器学习解决方案架构和技术平台Hadoop的实现方面。在这一章中，我们将看看一些被广泛采用的和即将出现的机器学习工具、库和框架。本章是后续章节的入门，因为它涵盖了如何使用已识别的机器学习框架的现成功能来实现特定的机器学习算法。</p><p>我们将首先介绍市场上可用的开源和商业机器学习库或工具的情况，并挑选出五大开源选项。对于每个确定的选项，从安装步骤开始，学习语法，实现复杂的机器学习算法，到绘制图表，我们将涵盖所有内容。按照出现的顺序，本章对读者来说是强制性的，因为它是后面章节中所有示例实现的基础。</p><p>每个确定的框架都可以作为独立的库运行，也可以在Hadoop上运行。除了学习如何编程和实现机器学习算法之外，我们还将介绍每个已确定的框架如何在Hadoop上集成和运行；这就是这些教程与网上主流教程的不同之处。</p><p>本章将深入介绍此处列出的主题:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">商业和开源机器学习库的简要列表。</li><li class="listitem" style="list-style-type: disc">涵盖的顶级库或框架有R、Mahout、Julia、Python(特别是机器学习库)和Spark。</li><li class="listitem" style="list-style-type: disc">Apache Mahout <a id="id491" class="indexterm"/>是一个用于运行基于Hadoop构建的机器学习算法的框架，是一个基于Java的开源机器学习选项。这个框架也可以独立工作。它以对大量数据运行机器学习算法而闻名。这个框架是Hadoop生态系统组件的一部分，有它的分布。</li><li class="listitem" style="list-style-type: disc">r是一个开源的机器学习和数据挖掘工具，在机器学习社区中被广泛采用。这个框架库既可以独立工作，也可以使用Hadoop runtime R扩展在Hadoop上运行。</li><li class="listitem" style="list-style-type: disc">Julia是一种开源的高性能编程语言，支持以分布式和并行的方式运行数值和统计计算功能。</li><li class="listitem" style="list-style-type: disc">Python是一种<a id="id494" class="indexterm"/>解释的高级编程语言，旨在尝试不同的东西，它不属于传统的瀑布式开发方式。我们将探索基本的Python库— <strong> NumPy </strong> <a id="id495" class="indexterm"/>和<strong> SciPy </strong> <a id="id496" class="indexterm"/>，并使用scikit-learn来执行我们的第一个机器学习程序。此外，我们将探索如何用Python编写Hadoop MapReduce程序。</li><li class="listitem" style="list-style-type: disc">Apache Spark <a id="id497" class="indexterm"/>及其机器学习核心库:Spark是一个集群计算系统，具有用于Java、Python和Scala的API。我们将探索用于机器学习的<strong> MLlib API </strong> <a id="id498" class="indexterm"/>，并为Apache Hadoop使用一个版本。重点将是探索Spark Java APIs。</li><li class="listitem" style="list-style-type: disc">Spring XD <a id="id499" class="indexterm"/>及相关机器学习库简介。</li><li class="listitem" style="list-style-type: disc">对于每个已确定的机器学习框架，与Hadoop的集成将是主要关注点。</li></ul></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec23"/>机器学习工具——一个景观</h1></div></div></div><p>在过去的几十年里，市场上有几个开源和<a id="id500" class="indexterm"/>商业机器学习框架和工具在发展。虽然机器学习领域本身正在为不同领域的不同需求构建强大的算法，但我们现在看到大规模机器学习的开源选项激增，这些选项已经达到了相当高的成熟度，并被数据科学和机器学习社区广泛采用。</p><p>该模型在最近几年发生了重大变化，研究人员被鼓励在开源模型下发布他们的软件。由于作者在发布他们使用算法实现进行机器学习的工作时会面临一些问题，因此任何通过数据科学社区的使用进行审查和即兴创作的工作都被认为更有价值。</p><p>下图显示了市场上一些重要的商业和开源机器学习框架和工具的概念模型。本章<a id="id501" class="indexterm"/>将深入介绍突出显示的内容。</p><div><img src="img/B03980_04_01.jpg" alt="Machine learning tools – A landscape"/></div><p>其中一些库围绕特定的编程语言，如Java、Python、C++、Scala等等。其中一些库，如Julia、Spark和Mahout，已经支持分布式和并行处理，其他库如R和Python可以在Hadoop上作为MapReduce函数运行。</p><p>在以下章节中，对于<a id="id502" class="indexterm"/>每个突出显示的机器学习库，将涵盖以下内容:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">库或工具的概述，以及支持的开箱即用机器学习功能的详细信息</li><li class="listitem" style="list-style-type: disc">安装、设置和配置指南</li><li class="listitem" style="list-style-type: disc">介绍语法和基本数据处理功能，然后介绍高级机器学习功能的示例实现</li><li class="listitem" style="list-style-type: disc">可视化和绘图样本(如适用)</li><li class="listitem" style="list-style-type: disc">Hadoop平台上的集成和执行</li></ul></div></div></div>





<title>Apache Mahout</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title">阿帕奇看象人</h1></div></div></div><p>Apache Mahout是一个<a id="id503" class="indexterm"/>机器学习库，与Apache Hadoop打包在一起，是Hadoop生态系统的重要组成部分。</p><p>Mahout于2008年作为Apache Lucene(一个开源搜索引擎)的子项目出现。Lucene是一个API，它实现了搜索、文本挖掘和信息检索技术。这些搜索和文本分析中的大多数都在内部应用了机器学习技术。为搜索引擎构建的推荐引擎开始于一个叫做Mahout的新的子项目。Mahout的意思是大象的<em>骑手，表示机器学习算法在Hadoop上的运行。这是一个可扩展的机器学习实现，也可以在独立模式下运行(不与Hadoop紧密集成)。</em></p><div><img src="img/B03980_04_02.jpg" alt="Apache Mahout"/></div><p>Mahout是一组基本的机器学习Java库，用于分类、聚类、模式挖掘等等。尽管Mahout今天提供了对机器学习算法子集的支持，但它仍然是最受欢迎的框架之一，因为它固有地支持对数亿行的大型数据集进行分析，这些数据集本质上也可以是非结构化的。</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec54"/>看象人是如何工作的？</h2></div></div></div><p>Mahout实现了<a id="id504" class="indexterm"/> Hadoop MapReduce，最重要的方面是它工作在Hadoop之上，应用了分布式计算范式。</p><div><img src="img/B03980_04_03.jpg" alt="How does Mahout work?"/></div><p>下面是Mahout目前实现的一些具体的机器学习任务:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>协同过滤/推荐</strong>:这个<a id="id505" class="indexterm"/>接受用户输入并找到用户可能喜欢的项目</li><li class="listitem" style="list-style-type: disc"><strong>集群</strong>:它将一组<a id="id506" class="indexterm"/>文档作为输入，并根据它们引用/所属的主题对它们进行分组</li><li class="listitem" style="list-style-type: disc"><strong>分类</strong>:这需要一堆<a id="id507" class="indexterm"/>文档，基于现有的文档分类，了解给定文档可能属于哪个类别，并将文档映射到那个类别</li><li class="listitem" style="list-style-type: disc"><strong>频繁项目集挖掘</strong>:这将<a id="id508" class="indexterm"/>一堆项目作为输入，并基于对真实事件的学习，识别哪些项目出现或一起出现</li></ul></div><p>有一些特定的<a id="id509" class="indexterm"/>算法，例如逻辑回归和SVM(关于这些算法的更多内容将在后面的章节中介绍)，它们不能并行化，也不能在独立模式下运行。</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec55"/>安装和设置Apache Mahout</h2></div></div></div><p>在这一章中，我们将<a id="id510" class="indexterm"/>看看如何在独立模式和<a id="id511" class="indexterm"/> Hadoop上运行Mahout。虽然在撰写本书时，Apache Mahout已经有了新的1.0版本，但是在所有的例子中，我们将使用0.9版本(最新的稳定版本)。使用的操作系统是Ubuntu 12.04桌面32位版本。</p><p>以下是安装Apache Mahout的依赖项和关键要求:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">JDK (1.6或以上；在本书中，我们将使用1.7 u9版本作为示例)</li><li class="listitem" style="list-style-type: disc">Maven (2.2或以上；我们将在本书中使用3.0.4作为例子)</li><li class="listitem" style="list-style-type: disc">Apache Hadoop(2.0；不是强制性的，因为Mahout可以在本地运行)</li><li class="listitem" style="list-style-type: disc">Apache Mahout (0.9发行版)</li><li class="listitem" style="list-style-type: disc">开发环境—Eclipse IDE (Luna)</li></ul></div><p>在<a class="link" href="ch03.html" title="Chapter 3. An Introduction to Hadoop's Architecture and Ecosystem">第3章</a>、<em>Hadoop架构和生态系统介绍</em>中，我们已经了解了Apache Hadoop 2.0单节点安装是如何完成的，以及所需的先决条件，如Java。</p><p>在这一章中，我们将介绍<a id="id512" class="indexterm"/>为开发环境设置Maven和Eclipse，以及配置Apache Mahout在Hadoop上和Hadoop下运行。由于考虑的平台和相关框架都是开源的，我们将使用Windows 7专业版托管的VirtualBox机器仿真器<a id="id513" class="indexterm"/>。</p><p>您可能还记得，Hadoop不能作为根用户运行，因此我们为此创建了一个用户— <code class="literal">practical-ml</code>来安装和运行一切。</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec49"/>设置Maven</h3></div></div></div><p>建议使用<a id="id514" class="indexterm"/> Maven来获得所需的Mahout jars，使用Mahout可以很容易地切换到任何新版本。如果没有Maven，下载依赖项会变得更加复杂。有关Maven的具体特性及其在应用程序开发中的效用的更多详细信息，请参考<a class="ulink" href="https://www.packtpub.com/application-development/apache-maven-3-cookbook">https://www . packtpub . com/application-development/Apache-Maven-3-cookbook</a>。</p><p>maven 3 . 0 . 4版可以从Apache网站的镜像之一下载。以下命令可用于此目的:</p><div><pre class="programlisting">
<strong>wget http://it.apache.contactlab.it/maven/maven-3/3.0.4/binaries/apachemaven-3.0.4-bin.tar.gz</strong>
</pre></div><p>要手动安装Maven，请执行以下说明:</p><div><ol class="orderedlist arabic"><li class="listitem">将发行版归档文件(即<code class="literal">apache-maven-3.0.4-bin.tar.gz</code>)解压到您希望安装Maven 3.0.4的目录中。</li><li class="listitem">有了这些指令，将选择<code class="literal">/usr/local/apache-maven</code>路径。将从归档文件中创建一个<code class="literal">apache-maven-3.0.4</code>子目录。</li><li class="listitem">以下几行需要追加到<code class="literal">.bashrc</code>文件中:<div> <pre class="programlisting">export M2_HOME=/usr/local/apache-maven-3.0.4 export M2=$M2_HOME/bin export PATH=$M2:$PATH export JAVA_HOME=$HOME/programs/jdk</pre> </div></li></ol></div><p><code class="literal">JAVA_HOME</code>应指向安装JDK的位置。例如，导出<code class="literal">JAVA_HOME=/usr/java/jdk1.7. $JAVA_HOME/bin</code>在您的<code class="literal">PATH</code>环境变量中。<code class="literal">PATH</code>变量是在Java安装期间设置的。这个要验证一下。</p><p>我们现在可以通过运行以下命令来检查Maven是否成功安装:</p><div><pre class="programlisting">
<strong>mvn –version</strong>
</pre></div><p>如果有任何<a id="id515" class="indexterm"/>代理设置，我们将不得不显式更新<code class="literal">settings.xml</code>文件中的代理设置，该文件位于Maven安装的<code class="literal">conf</code>文件夹中。</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec50"/>使用Eclipse IDE设置Apache Mahout</h3></div></div></div><p>接下来详细介绍的过程<a id="id516" class="indexterm"/>涵盖了设置<a id="id517" class="indexterm"/> Mahout环境、代码库、访问示例、运行、调试以及使用Eclipse IDE测试它们的步骤。这是推荐的设置方式，也是为开发团队设置Apache Mahout的最简单的方式。</p><p>执行以下步骤来获取Apache Mahout tar，解压缩它并导航到安装。</p><div><ol class="orderedlist arabic"><li class="listitem">Set up Eclipse IDE.<p>Eclipse <a id="id518" class="indexterm"/>的最新版本可以从以下链接下载:</p><p><a class="ulink" href="https://www.eclipse.org/downloads/">https://www.eclipse.org/downloads/</a></p></li><li class="listitem">使用下面的命令从直接链接下载Mahout发行版:<div> <pre class="programlisting"> <strong>$ wget -c http://archive.apache.org/dist/mahout/0.9/mahout-distribution-0.9.tar.gz</strong> </pre> </div></li><li class="listitem">使用以下命令从其中提取归档文件:<div> <pre class="programlisting"> <strong>$ tar zxf mahout-distribution-0.9.tar.gz</strong> </pre> </div></li><li class="listitem">Convert the project into an Eclipse project:<div><pre class="programlisting">
<strong>$ cd mahout-distribution-0.9</strong>
<strong>$ mvn eclipse: eclipse</strong>
</pre></div><p>前面的命令构建了Eclipse项目。</p></li><li class="listitem">将<code class="literal">M2_REPO</code> classpath变量设置为指向本地存储库路径。以下命令将所有Maven jars添加到Eclipse类路径:<div> <pre class="programlisting"> <strong>mvn -Declipse.workspace= eclipse:add-maven-repo</strong> </pre> </div></li><li class="listitem">Now, let's <a id="id519" class="indexterm"/>import the Eclipse Mahout <a id="id520" class="indexterm"/>projects.<p>从菜单中导航，<strong>文件</strong> | <strong>导入</strong> | <strong>常规</strong> | <strong>现有项目</strong>到<strong>工作区</strong>。</p><div><img src="img/B03980_04_04.jpg" alt="Setting-up Apache Mahout using Eclipse IDE"/></div></li></ol></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec51"/>在没有Eclipse的情况下设置Apache Mahout</h3></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">使用下面的命令从直接链接下载<a id="id521" class="indexterm"/> Mahout发行版:<div> <pre class="programlisting"> <strong>$ wget -c http://archive.apache.org/dist/mahout/0.9/mahout-distribution-0.9.tar.gz</strong> </pre> </div></li><li class="listitem">将Mahout分发解压到<code class="literal">/usr/local</code>文件夹:<div> <pre class="programlisting"> <strong>$ cd /usr/local</strong> <strong>$ sudo tar xzf mahout-distribution-0.9.tar.gz</strong> <strong>$ sudo mv mahout-distribution-0.9.tar.gz mahout</strong> <strong>$ sudo chown –R practical-ml:hadoop mahout</strong> </pre> </div></li><li class="listitem">Set the Java, Maven, and Mahout paths in the <code class="literal">.bashrc</code> file.<p>使用下面的命令打开<code class="literal">.bashrc</code>文件:</p><div><pre class="programlisting">
<strong>gedit ~/.bashrc</strong>
</pre></div><p>将以下内容添加到文件中:</p><div><pre class="programlisting">export MAHOUT_HOME = /usr/local/mahout
path=$path:$MAHOUT_HOME/bin
export M2_HOME=/usr/local/maven
export PATH=$M2:$PATH
export M2=$M2_HOME/bin
PATH=$PATH:$JAVA_HOME/bin;$M2_HOME/bin</pre></div></li><li class="listitem">To run Mahout in the local mode (this means in the standalone mode where there is no need for Hadoop, and the algorithms will not run in parallel or MapReduce mode).<p>使用以下命令将本地模式设置为true:</p><div><pre class="programlisting">
<strong>$MAHOUT_LOCAL=true</strong>
</pre></div><p>这将迫使Mahout不去寻找<code class="literal">$HADOOP_CONF_DIR</code>中的Hadoop配置。</p><p><code class="literal">MAHOUT_LOCAL</code>已设置，所以我们不将<code class="literal">HADOOP_CONF_DIR</code>添加到类路径中。</p></li></ol></div><p>有一种方法可以在Hadoop上运行<a id="id522" class="indexterm"/> Mahout。首先，确保Hadoop 2.x安装和配置成功。然后，按照以下说明操作:</p><div><ol class="orderedlist arabic"><li class="listitem">Set <code class="literal">$HADOOP_HOME</code>, <code class="literal">$HADOOP_CONF_DIR</code> are set and added to <code class="literal">$PATH</code>.<div><pre class="programlisting">
<strong>export HADOOP_CONF_DIR=$HADOOP_HOME/conf</strong>
</pre></div><p>上面设置了Hadoop运行的模式(例如在<code class="literal">core-site.xml</code>、<code class="literal">hdfs-site.xml</code>、<code class="literal">mapred-site.xml</code>等等)。)</p></li><li class="listitem">现在，使用下面的命令启动Hadoop实例:<div> <pre class="programlisting"> <strong>$HADOOP_HOME/bin/start-all.sh</strong> </pre> </div></li><li class="listitem">检查<code class="literal">http://localhost:50030</code>和<code class="literal">http://localhost:50070</code>URL以确认<a id="id523" class="indexterm"/> Hadoop是否启动并运行。</li><li class="listitem">通过从Mahout目录运行以下Maven命令，使用Maven构建Apache Mahout:<div><pre class="programlisting"> <strong>/usr/local/mahout$ mvn install</strong> </pre></div></li></ol></div><p>成功安装后会看到以下输出:</p><div><img src="img/B03980_04_05.jpg" alt="Setting up Apache Mahout without Eclipse"/></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec56"/>看象人包</h2></div></div></div><p>下图描述了Mahout中的<a id="id524" class="indexterm"/>不同的包，它们为几种机器学习算法提供了一些现成的支持。核心模块是实用程序、数学向量、集合、Hadoop和MapReduce，用于并行处理，文件系统用于分布式存储。</p><p>此外，核心模块之上是<a id="id525" class="indexterm"/>机器学习包，如下所示:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">分类</li><li class="listitem" style="list-style-type: disc">使聚集</li><li class="listitem" style="list-style-type: disc">进化算法</li><li class="listitem" style="list-style-type: disc">推荐人</li><li class="listitem" style="list-style-type: disc">回归</li><li class="listitem" style="list-style-type: disc">设备功率监察器(Facility Power Monitor)</li><li class="listitem" style="list-style-type: disc">维度缩减<div> <img src="img/B03980_04_06.jpg" alt="Mahout Packages"/> </div></li></ul></div><p>更多的细节在前面的包中有详细的介绍，在接下来的章节中会有使用每个包来解决问题的示例实现。</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec57"/>在Mahout中实现矢量</h2></div></div></div><p>正如我们所理解的，为了<a id="id527" class="indexterm"/>在Mahout中演示大多数机器学习<a id="id528" class="indexterm"/>算法的实现，我们需要经典Mahout数据集格式的数据。核心部分的代码主要是使用一些Mahout现成的脚本，并对设置做一些小的修改。下面给出了标准流程:</p><div><ol class="orderedlist arabic"><li class="listitem">Create sequence files from the raw text files.<p><strong>序列文件</strong> <a id="id529" class="indexterm"/>主要是数据的键/值对表示的二进制编码。接下来给出的属性是表示元数据详细信息的关键头元素:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">版本</li><li class="listitem" style="list-style-type: disc">键名</li><li class="listitem" style="list-style-type: disc">值名</li><li class="listitem" style="list-style-type: disc">压缩</li></ul></div></li><li class="listitem">从序列文件生成向量。更多关于生成序列文件的实际命令将在后面的章节中介绍，同时演示每个已识别的机器学习算法的实现。</li><li class="listitem">在这些工作向量上运行函数</li></ol></div><p>Mahout中有不同类型的vector实现，这些定义通常也适用。</p><div><img src="img/B03980_04_07.jpg" alt="Implementing vectors in Mahout"/></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>密集向量</strong>:这些<a id="id530" class="indexterm"/>向量通常是一个doubles的数组，这个向量的大小与数据集中的特征数量相同。由于所有条目都是预先分配的，与零值无关，因此这些向量被称为密集向量。</li><li class="listitem" style="list-style-type: disc"><strong>稀疏向量</strong>:这些<a id="id531" class="indexterm"/>向量是向量数组，仅用非零值或空值表示。对于稀疏向量，有两个子类别:随机访问和顺序访问稀疏向量。<div> <ul class="itemizedlist"> <li class="listitem" style="list-style-type: disc"> <strong>随机访问稀疏向量</strong>:随机访问稀疏向量是HashMap <a id="id532" class="indexterm"/>表示<a id="id533" class="indexterm"/>，其中键是一个整数值，值是一个double值。在任何给定的时间点，都可以通过传入给定的键来访问值。</li> <li class="listitem" style="list-style-type: disc"> <strong>顺序访问稀疏向量</strong>:这些向量只不过是一组两个数组<a id="id534" class="indexterm"/>，其中第一个数组<a id="id535" class="indexterm"/>是键数组(整数)，第二个数组是值数组(双精度)。与随机访问稀疏向量不同，这些向量针对线性读取进行了优化。同样，只对非零值进行存储。</li></ul></div><div><div><h3 class="title"><a id="note04"/>注</h3> <p>有关使用Apache Mahout的详细理解，请参考Apache Mahout的Packt出版物，标题为<em> Apache Mahout食谱</em>。</p></div>T37】</div></li></ul></div><p>虽然本节涵盖了一个为与Hadoop一起工作而构建的框架，但只做了很小的配置更改，在下一节中，我们将介绍市场上广泛采用的强大选项—R。Hadoop提供了显式适配器，使R程序能够在MapReduce模型中工作，这将在下一节中介绍。</p></div></div>





<title>R</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title"><a id="ch04lvl1sec25"/> R</h1></div></div></div><p>r是一种用于数据分析的<a id="id536" class="indexterm"/>语言，被用作机器学习、统计计算和数据挖掘领域的主要驱动程序，并为基本和高级可视化或图形提供了一个全面的平台。如今，R是几乎所有数据科学家或潜在数据科学家都拥有或<em>必须</em>学习的一项基本技能。</p><p>r主要是一个GNU项目，众所周知它类似于S语言，S语言最初是由约翰·钱伯斯和他的团队在贝尔实验室(以前叫美国电话电报公司，现在叫朗讯科技)开发的。S最初的目标是支持所有的统计功能，并被核心统计人员广泛使用。</p><p>R附带了大量的开放源码包，可以免费下载和配置，并根据需要安装或加载到R环境中。这些包为各种各样的统计技术提供现成的支持，包括线性和非线性建模、时间序列分析、分类、聚类等等。</p><p>除此之外，还提供了高度可扩展的图形功能。对这些高级图形功能的支持是R的主要优势，因为其输出以出版质量图著称。除此之外，R还支持许多开源的图形库和可视化工具，它们本质上都是开源的和商业化的。</p><p>尽管在核心上，R并不意味着在分布式环境中工作或以并行模式运行算法，但有几个可用的扩展(开源和商业的)使R更具可伸缩性并支持大型数据集。在这一章中，我们将介绍R如何与Apache Hadoop集成，从而运行和利用MapReduce功能。</p><p>最重要的是，R是被广泛采用的自由软件，有许多提交者和支持团体一直致力于保持它在数据科学领域的高度相关性。</p><p>下面列出了R目前支持的一些关键功能:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">有效管理和存储模型所操作的数据的能力</li><li class="listitem" style="list-style-type: disc">为数组、向量和矩阵等的计算提供一些核心函数套件</li><li class="listitem" style="list-style-type: disc">几个现成的机器学习功能，可以按需加载，有助于轻松实施数据科学项目</li><li class="listitem" style="list-style-type: disc">高级和复杂的图形功能，可以轻松使用，并有助于为企业所有者生成有价值的仪表板</li><li class="listitem" style="list-style-type: disc">一个由采纳者和提交者组成的广泛而活跃的社区，通过大量软件包的扩展而迅速发展</li><li class="listitem" style="list-style-type: disc">r被认为是一个支持新开发的交互式数据分析方法的平台</li></ul></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec58"/>安装和设置R</h2></div></div></div><p>对于本书中的所有例子<a id="id538" class="indexterm"/>，我们将使用R的稳定版本2.15.1和所有<a id="id540" class="indexterm"/>最新R包的<a id="id539" class="indexterm"/> CRAN参考。</p><p>参考<a class="ulink" href="https://cran.r-project.org/bin/windows/base/old/2.15.1/">https://cran.r-project.org/bin/windows/base/old/2.15.1/</a>链接下载R for Windows。</p><p>详细的安装过程见<a class="ulink" href="https://cran.r-project.org/doc/manuals/R-admin.html#Top">https://cran.r-project.org/doc/manuals/R-admin.html#Top</a>。</p><p>我们可以在R GUI或IDE RStudio中使用R。下面是R界面的截图，用户可以在成功安装R GUI和R IDE以及RStudio后看到。</p><div><img src="img/B03980_04_08.jpg" alt="Installing and setting up R"/></div><p>我们需要通过菜单路径<strong>包</strong> | <strong>设置起重机镜像</strong>来设置起重机镜像路径，以便能够访问和加载所需的R包</p><div><img src="img/B03980_04_09.jpg" alt="Installing and setting up R"/></div><p>下面的截图<a id="id541" class="indexterm"/>显示了一个镜像站点列表，开发者可以从中选择最合适的一个:</p><div><img src="img/B03980_04_10.jpg" alt="Installing and setting up R"/></div><p>R编辑器可用于<a id="id543" class="indexterm"/>编写任何高级操作，结果可在<a id="id544" class="indexterm"/>控制台上看到，如下所示:</p><div><img src="img/B03980_04_11.jpg" alt="Installing and setting up R"/></div><p>以下是图形绘图的屏幕截图:</p><div><img src="img/B03980_04_12.jpg" alt="Installing and setting up R"/></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec59"/>将R与Apache Hadoop集成</h2></div></div></div><p>到目前为止，我们已经看到了<a id="id545" class="indexterm"/> Apache Hadoop及其核心组件，HDFS和YARN (MapReduce 2.0)，以及R。我们可以通过三种不同的方式来看待R与Hadoop的集成，从而支持大规模机器学习。</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec52"/>方法1——在Hadoop中使用R和流式API</h3></div></div></div><p>为了将R <a id="id546" class="indexterm"/>函数与Hadoop集成并在MapReduce模式下运行，Hadoop支持R的流API。这些流API主要帮助运行任何可以在MapReduce模式下访问和操作标准I/O的脚本。因此，在R的情况下，不会有任何使用R的显式客户端集成。以下是R和流的示例:</p><div><pre class="programlisting">$ ${HADOOP_HOME}/bin/Hadoop jar
${HADOOP_HOME}/contrib/streaming/*.jar \
-inputformat
org.apache.hadoop.mapred.TextInputFormat \
-input input_data.txt \
-output \
-mapper /home/tst/src/map.R \
-reducer /home/tst/src/reduce.R \
-file /home/tst/src/map.R \
-file /home/tst/src/reduce.R</pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec53"/>方法2——使用R</h3></div></div></div><p>在R中有一个名为Rhipe的包，允许在R中运行MapReduce作业。有一些先决条件:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">r需要安装在Hadoop集群中的每个DataNode上</li><li class="listitem" style="list-style-type: disc">将在每个DataNode上安装并提供协议缓冲器(有关协议缓冲器的更多信息<a id="id548" class="indexterm"/>请参考<a class="ulink" href="http://wiki.apache.org/hadoop/ProtocolBuffers">http://wiki.apache.org/hadoop/ProtocolBuffers</a>)</li><li class="listitem" style="list-style-type: disc">Rhipe应该在每个数据节点上都可用</li></ul></div><p>以下是使用R中的<code class="literal">Rhipe</code>库实现MapReduce的<a id="id549" class="indexterm"/>示例格式:</p><div><pre class="programlisting">library(Rhipe)
rhinit(TRUE, TRUE);
map&lt;-expression ( {lapply (map.values, function(mapper)…)})
reduce&lt;-expression(
pre = {…},
reduce = {…},
post = {…},
)
x &lt;- rhmr(map=map, reduce=reduce,
 ifolder=inputPath,
 ofolder=outputPath,
 inout=c('text', 'text'),
 jobname='test name'))
rhex(x)</pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec54"/>方法3——使用RHadoop</h3></div></div></div><p>RHadoop与<a id="id550" class="indexterm"/> Rhipe非常相似，它有助于在MapReduce模式下运行R函数。这是一个由Revolution Analytics构建的开源库。以下是一些软件包，它们是RHadoop库的一部分:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong> plyrmr </strong>:这是一个包<a id="id551" class="indexterm"/>，为运行在Hadoop上的大型数据集的常见数据操作需求提供函数</li><li class="listitem" style="list-style-type: disc">rmr :这是一个包<a id="id552" class="indexterm"/>，它有一个集成了R和Hadoop的函数集合</li><li class="listitem" style="list-style-type: disc">rdfs :这是一个包<a id="id553" class="indexterm"/>，有帮助接口R和HDFS的功能</li><li class="listitem" style="list-style-type: disc"><strong> rhbase </strong>:这是一个<a id="id554" class="indexterm"/>包，有帮助接口R和hbase的功能</li></ul></div><p>下面是一个使用rmr包的例子，演示了使用这个包中的函数集成R和Hadoop的步骤:</p><div><pre class="programlisting">library(rmr)
maplogic&lt;-function(k,v) { …}
reducelogic&lt;-function(k,vv) { …}
mapreduce( input ="data.txt",
output="output",
textinputformat =rawtextinputformat,
map = maplogic,
reduce=reducelogic
)</pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec55"/>R/Hadoop集成方法概述</h3></div></div></div><p>总之，<a id="id555" class="indexterm"/>前面的三种方法都产生了结果<a id="id556" class="indexterm"/>并促进了R和Hadoop的集成。他们帮助scale R对大规模数据进行操作，这将有助于HDFS。这些方法各有利弊。以下是总结的结论:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Hadoop Streaming API是所有方法中最简单的，因为在安装和设置要求方面没有复杂性</li><li class="listitem" style="list-style-type: disc">Rhipe和RHadoop都需要在Hadoop集群上设置R和相关的包</li><li class="listitem" style="list-style-type: disc">关于实现方法，Streaming API更像是一个命令行映射，reduce函数是函数的输入，而Rhipe和RHadoop都允许开发人员在R</li><li class="listitem" style="list-style-type: disc">对于Hadoop Streaming API，不需要客户端集成，而Rhipe和RHadoop都需要客户端集成</li><li class="listitem" style="list-style-type: disc">扩展机器学习的替代方案是Apache Mahout、Apache Hive以及Revolution Analytics、Segue framework等公司的一些商业版R</li></ul></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec56"/>在R中实现(使用示例)</h3></div></div></div><p>在这一节中，我们将简要介绍R的一些实现方面，并重点学习语法和理解一些核心函数及其用法。</p><div><div><div><div><h4 class="title"><a id="ch04lvl4sec08"/> R表情</h4></div></div></div><p>r可以作为简单的<a id="id557" class="indexterm"/>数学计算器；以下是使用它的一些基本方法。以下是在R控制台上看到的内容:</p><div><pre class="programlisting">&gt; 1+1
[1] 2
&gt; "Welcome to R!"
[1] "Welcome to R!"
&gt; 6*7
[1] 42
&gt; 10&lt;22
[1] TRUE
&gt; 2+7==5
[1] FALSE</pre></div><div><div><div><div><h5 class="title"><a id="ch04lvl5sec04"/>作业</h5></div></div></div><p>用于给<a id="id558" class="indexterm"/>变量赋值，并对该变量进行一些操作:</p><p>案例1:分配数值:</p><div><pre class="programlisting">&gt; x&lt;-24
&gt; x/2
[1] 12</pre></div><p>案例2:分配字符串文字:</p><div><pre class="programlisting">&gt; x &lt;- "Try R!"
[1] "Try R!"
&gt; x
[1] " Try R!"</pre></div><p>案例3:分配逻辑值:</p><div><pre class="programlisting">&gt; x &lt;- TRUE
[1] TRUE</pre></div></div><div><div><div><div><h5 class="title"><a id="ch04lvl5sec05"/>职能</h5></div></div></div><p>有许多现成的函数，要调用R中的函数，我们应该提供函数名并传递所需的参数。下面是一些函数和结果的例子，如在R控制台中看到的:</p><div><pre class="programlisting">&gt; sum(4,3,5,7)
[1] 19
&gt; rep("Fun!", times=3)
[1] " Fun!" "Fun!" "Fun!"
&gt; sqrt(81)
[1] 9</pre></div><p>下面是获取R中某个函数的帮助的命令:</p><div><pre class="programlisting">&gt; help(sum)
sum package: base R Documentation

Sum of Vector Elements

Description:

     'sum' returns the sum of all the values present in its arguments.

Usage:

     sum(..., na.rm = FALSE)</pre></div></div></div><div><div><div><div><h4 class="title"><a id="ch04lvl4sec09"/> R载体</h4></div></div></div><p>根据定义，vector是一个简单的<a id="id560" class="indexterm"/>值列表，它构成了R数据类型的核心。许多机器学习功能利用了这些。</p><p>以下是一些关键功能及其使用环境:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>函数/语法</p>
</th><th style="text-align: left" valign="bottom">
<p>目的</p>
</th><th style="text-align: left" valign="bottom">
<p>例子</p>
</th><th style="text-align: left" valign="bottom">
<p>R控制台上的输出</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">m:n</code></p>
</td><td style="text-align: left" valign="top">
<p>从<code class="literal">m</code>到<code class="literal">n</code>输出数字，增量为1</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal"> &gt; 5:9</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">[1] 5 6 7 8 9</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">seq(m,n)</code></p>
</td><td style="text-align: left" valign="top">
<p>从<code class="literal">m</code>到<code class="literal">n</code>的输出数字增加1</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal"> &gt; seq(5,9)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">[1] 5 6 7 8 9</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">seq(m,n, i)</code></p>
</td><td style="text-align: left" valign="top">
<p>从<code class="literal">m</code>到<code class="literal">n</code>输出数字，增量为<code class="literal">i</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal"> &gt; seq(1,3,0.5)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">[1] 1 1.5 2 2.5 3</code></p>
</td></tr></tbody></table></div><div><div><div><div><h5 class="title"><a id="ch04lvl5sec06"/>分配、访问和操纵向量</h5></div></div></div><p>下面的<a id="id561" class="indexterm"/>表格包含了在R中创建、访问和<a id="id563" class="indexterm"/>操作矩阵的<a id="id562" class="indexterm"/>示例:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>目的</p>
</th><th style="text-align: left" valign="bottom">
<p>例子</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>创建文字向量</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">&gt; sentence &lt;- c('practical', 'machine', 'learning')</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>访问向量的第三值</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">&gt; sentence[3]</code></p>
<p><code class="literal">[1] "learning."</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>更新向量中的值</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">&gt; sentence[1] &lt;- "implementing"</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>向向量添加新值</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">&gt; sentence[4] &lt;- "algorithms"</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>获取给定索引的值</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">&gt; sentence[c(1,3)]</code></p>
<p><code class="literal">[1] "implementing" "learning"</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>获取索引范围的值</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">&gt; sentence[2:4]</code></p>
<p><code class="literal">[1] "machine" "learning" "algorithms"</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>添加一系列新值</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">&gt; sentence[5:7] &lt;- c('for','large','datasets')</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>将<a id="id564" class="indexterm"/>矢量值增加1</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">&gt; a &lt;- c(1, 2, 3)</code></p>
<p><code class="literal">&gt; a + 1</code></p>
<p><code class="literal">[1] 2 3 4</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>将向量中的每个值除以一个值</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">&gt; a / 2</code></p>
<p><code class="literal">[1] 0.5 1.0 1.5</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>将向量的每个<a id="id565" class="indexterm"/>值乘以一个值</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">&gt; a*2</code></p>
<p><code class="literal">[1] 2 4 6</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>添加两个<a id="id566" class="indexterm"/>向量</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">&gt; b &lt;- c(4, 5, 6)</code></p>
<p><code class="literal">&gt; a + b</code></p>
<p><code class="literal">[1] 5 7 9</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>比较两个向量</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">&gt; a == c(1, 99, 3)</code></p>
<p><code class="literal">[1]  TRUE FALSE  TRUE</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>对向量的每个值应用函数</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">&gt; sqrt(a)</code></p>
<p><code class="literal">[1] 1.000000 1.414214 1.732051</code></p>
</td></tr></tbody></table></div></div></div><div><div><div><div><h4 class="title"><a id="ch04lvl4sec10"/> R矩阵</h4></div></div></div><p>矩阵是有行和列的二维<a id="id567" class="indexterm"/>向量。下表提供了在R中创建、访问和操作矩阵的示例:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>目的</p>
</th><th style="text-align: left" valign="bottom">
<p>例子</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>创建一个默认值为零的3 X 4矩阵</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">&gt; matrix(0, 3, 4)</code></p>
<p><code class="literal">     [,1] [,2] [,3] [,4]</code></p>
<p><code class="literal">[1,]    0    0    0    0</code></p>
<p><code class="literal">[2,]    0    0    0    0</code></p>
<p><code class="literal">[3,]    0    0    0    0</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>用一系列值初始化矩阵</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">&gt; a &lt;- 1:12</code></p>
<p><code class="literal">&gt; m &lt;- matrix(a, 3, 4)</code></p>
<p><code class="literal">     [,1] [,2] [,3] [,4]</code></p>
<p><code class="literal">[1,]    1    4    7   10</code></p>
<p><code class="literal">[2,]    2    5    8   11</code></p>
<p><code class="literal">[3,]    3    6    9   12</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>从矩阵中访问值</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">&gt; m[2, 3]</code></p>
<p><code class="literal">[1] 8</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>为矩阵中选择的位置赋值</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">&gt; m[1, 4] &lt;- 0</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>检索选择的整行或一列的数组</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">&gt; m[2,]</code></p>
<p><code class="literal">[1] 2 5 8 11</code></p>
<p><code class="literal">&gt; m[3,]</code></p>
<p><code class="literal">[1] 7 8 9</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>检索更大矩阵的<a id="id568" class="indexterm"/>子集</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">&gt; m[, 2:4]</code></p>
<p><code class="literal">     [,1] [,2] [,3]</code></p>
<p><code class="literal">[1,]    4    7    10</code></p>
<p><code class="literal">[2,]    5    8    11</code></p>
</td></tr></tbody></table></div></div><div><div><div><div><h4 class="title"><a id="ch04lvl4sec11"/> R因子</h4></div></div></div><p>在数据分析和机器学习中，对数据进行分组或分类是很常见的。例如，好客户或坏客户。r的<code class="literal">factor</code>数据类型用于跟踪分类数据。所有需要做的就是定义一个类别向量，并将其作为参数传递给<code class="literal">factor</code>函数。</p><p>以下示例演示了使用<code class="literal">factors</code>创建和分配类别:</p><div><pre class="programlisting">&gt; ornaments &lt;- c('ring', 'chain', 'bangle', 'anklet', 'nosepin', 'earring', 'ring', 'anklet')
&gt; ornamenttypes &lt;- factor(ornaments)
&gt; print(ornamenttypes)
[1] ring chain bangle anklet nosepin earring
Levels: anklet bangle chain earring nosepin ring</pre></div><p>每个定义的类别通常都有一个与文字相关联的整数值。将<code class="literal">factor</code>传递给<a id="id570" class="indexterm"/>函数<code class="literal">as.integer</code>将给出整数等效值，如下所示:</p><div><pre class="programlisting">&gt; as.integer(ornamenttypes)
[1] 6 3 2 1 5 4 6 1</pre></div></div><div><div><div><div><h4 class="title"><a id="ch04lvl4sec12"/> R数据帧</h4></div></div></div><p>数据帧与<a id="id571" class="indexterm"/>数据库表的概念相关。这种数据类型在R中非常强大，它有助于将数据集的不同相关属性联系在一起。例如，购买的商品数量与总账单价值和总体适用折扣有关系。应该有一种方法来链接这些属性，而数据框有助于做到这一点:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>目的</p>
</th><th style="text-align: left" valign="bottom">
<p>例子</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>创建数据框并检查值</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">&gt; purchase &lt;- data.frame(totalbill, noitems, discount</code></p>
<p><code class="literal">&gt; print(purchase)</code></p>
<p><code class="literal">  totalbill noitems discount</code></p>
<p><code class="literal">1     300    5      10</code></p>
<p><code class="literal">2     200    3       7.5</code></p>
<p><code class="literal">3     100    1       5</code></p>
<p><code class="literal">)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>使用索引或标签访问数据帧的数据</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">&gt; purchase[[2]]</code></p>
<p><code class="literal">[1]  5 3 1</code></p>
<p><code class="literal">&gt; purchase[["totalbill"]]</code></p>
<p><code class="literal">[1] 300 200 100</code></p>
<p><code class="literal">&gt; purchase$discount</code></p>
<p><code class="literal">[1]  10 7.5 5</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>用CSV文件中的数据加载数据<a id="id572" class="indexterm"/>帧</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">&gt; list.files()</code></p>
<p><code class="literal">[1] "monthlypurchases.csv"</code></p>
<p><code class="literal">&gt; read.csv("monthlypurchases.csv")</code></p>
<p><code class="literal">         Amount    Items Discount</code></p>
<p><code class="literal">1 2500             35    15</code></p>
<p><code class="literal">2 5464             42    25</code></p>
<p><code class="literal">3 1245             8     6</code></p>
</td></tr></tbody></table></div></div><div><div><div><div><h4 class="title"><a id="ch04lvl4sec13"/> R统计框架</h4></div></div></div><p>r支持一系列现成的统计函数，帮助统计人员解释数据。下表显示了一些带有示例的函数:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>功能</p>
</th><th style="text-align: left" valign="bottom">
<p>例子</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>平均</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">limbs &lt;- c(4, 3, 4, 3, 2, 4, 4, 4)</code></p>
<p><code class="literal">names(limbs) &lt;- c('One-Eye', 'Peg-Leg', 'Smitty', 'Hook', 'Scooter', 'Dan', 'Mikey', 'Blackbeard')</code></p>
<p><code class="literal">&gt; mean(limbs)</code></p>
<p><code class="literal">[1] 3.5</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>中位数</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">&gt; median(limbs)</code></p>
<p><code class="literal">[1] 4</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>标准偏差</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">&gt; pounds &lt;- c(45000, 50000, 35000, 40000, 35000, 45000, 10000, 15000)</code></p>
<p><code class="literal">&gt; deviation &lt;- sd(pounds)</code></p>
</td></tr></tbody></table></div><p>包含的每段R代码都保存在扩展名为<code class="literal">.R</code>的文件中用于运行。</p><p>在这一节中，我们已经看到了如何设置R以及如何使用一些基本的函数和数据类型。我们将在接下来的章节中探索许多机器学习的特定包。</p><div><div><h3 class="title"><a id="note05"/>注意</h3><p>有关使用R进行机器学习的详细理解，请参考Packt针对R的出版物，标题为<em>使用R进行机器学习</em>。</p></div></div></div></div></div></div>





<title>Julia</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title">朱莉娅</h1></div></div></div><p>最近，Julia作为Python的高性能替代品，在机器学习和数据科学领域获得了广泛的欢迎和采用。Julia是一种动态编程语言，旨在支持分布式和并行计算，因此方便快捷。</p><p>Julia中的性能是JIT编译器和类型接口特性的结果。此外，与其他数字编程语言不同，Julia不强制执行值的矢量化。与R、MATLAB和Python类似，Julia为高级数值计算提供了便利和表现力。</p><p>以下是朱莉娅的一些主要特征:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">核心的API和数学原语操作都是用Julia写的</li><li class="listitem" style="list-style-type: disc">它由丰富类型组成，用于构造和描述对象</li><li class="listitem" style="list-style-type: disc">Julia支持多重分派，这使得可以在多种参数组合中使用函数</li><li class="listitem" style="list-style-type: disc">它有助于为不同的参数类型自动生成专门的代码</li><li class="listitem" style="list-style-type: disc">成熟的性能与C等静态编译语言不相上下</li><li class="listitem" style="list-style-type: disc">它是一种免费的开源编程语言(麻省理工学院许可)</li><li class="listitem" style="list-style-type: disc">用户定义的类型和内置类型一样快速紧凑</li><li class="listitem" style="list-style-type: disc">它不强制或要求矢量化代码来提高性能</li><li class="listitem" style="list-style-type: disc">它是为分布式并行计算而设计的</li><li class="listitem" style="list-style-type: disc">Julia附带了协同例程和轻量级线程</li><li class="listitem" style="list-style-type: disc">Julia支持直接调用C函数的能力</li><li class="listitem" style="list-style-type: disc">用于管理流程的类似外壳的功能</li><li class="listitem" style="list-style-type: disc">它提供了类似Lisp的宏</li></ul></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec60"/>安装和设置朱莉娅</h2></div></div></div><p>我们将使用茱莉亚的最新版本<a id="id578" class="indexterm"/>,这是在写这本书的时候可用的——v 0 . 3 . 4。</p><p>Julia程序可以通过以下方式构建和执行:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">使用Julia命令行</li><li class="listitem" style="list-style-type: disc">使用Juno——Julia的IDE</li><li class="listitem" style="list-style-type: disc">在<a class="ulink" href="https://juliabox.org/">https://juliabox.org/</a>使用<a id="id579" class="indexterm"/>现成可用的环境，在那里可以使用浏览器访问Julia环境</li></ul></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec57"/>下载和使用Julia的命令行版本</h3></div></div></div><p>使用链接<a class="ulink" href="http://julialang.org/downloads/">http://julialang.org/downloads/</a>下载<a id="id580" class="indexterm"/>所需的<a id="id581" class="indexterm"/>茱莉亚版本。</p><div><ol class="orderedlist arabic"><li class="listitem">下载<a id="id583" class="indexterm"/>适当的可执行文件并运行。<div> <img src="img/B03980_04_13.jpg" alt="Downloading and using the command line version of Julia"/> </div></li><li class="listitem">安装成功后，打开Julia控制台，Julia就可以使用了。<div> <img src="img/B03980_04_14.jpg" alt="Downloading and using the command line version of Julia"/> </div></li></ol></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec58"/>使用Juno IDE运行Julia</h3></div></div></div><p>Juno IDE <a id="id584" class="indexterm"/>让开发Julia代码变得简单。从http://junolab.org/docs/install.html<a class="ulink" href="http://junolab.org/docs/install.html">下载最新的Juno IDE </a><a id="id585" class="indexterm"/>版本。</p><p>Juno拥有Julia的核心API和功能，有助于简化开发过程。下面是如何使用Juno的屏幕截图:</p><div><img src="img/B03980_04_15.jpg" alt="Using Juno IDE for running Julia"/></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec59"/>通过浏览器使用Julia</h3></div></div></div><p>使用这个选项不需要安装任何Julia。按照以下步骤在线访问<a id="id587" class="indexterm"/> Julia环境:</p><div><ol class="orderedlist arabic"><li class="listitem">从浏览器<div> <img src="img/B03980_04_16.jpg" alt="Using Julia via the browser"/> </div>访问<a class="ulink" href="https://juliabox.org/">https://juliabox.org/</a></li><li class="listitem">使用Google帐户登录。这将为登录用户创建一个唯一的Julia实例。这将提供对Julia控制台和IJulia实例的访问。</li></ol></div><p>使用我们之前看到的三种<a id="id588" class="indexterm"/>方法中的一种，我们可以访问<a id="id589" class="indexterm"/> Julia控制台，从那里可以执行Julia代码。包含的每段Julia代码都构建在一个扩展名为<code class="literal">.jl</code>的文件中。</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec61"/>从命令行运行Julia代码</h2></div></div></div><p>Julia在<a id="id590" class="indexterm"/>运行时编译代码，并使用<strong>实时</strong> ( <strong> JIT </strong> ) <a id="id592" class="indexterm"/>编译器将每个方法翻译成<a id="id591" class="indexterm"/>机器码。在内部，它利用<a id="id593" class="indexterm"/> <strong>低级虚拟机</strong> ( <strong> LLVM </strong>)进行优化和代码生成。LLVM是一个成熟的项目，是标准编译器技术的集合。这是作为iOS的一部分使用的。</p><p>从选择的shell中，运行以下命令:</p><div><pre class="programlisting">&lt;&lt;/path/to/Julia&gt;&gt;/myjuliascript.jl</pre></div><p>或者，从Julia命令行安装中打开Julia控制台，并运行以下命令:</p><div><pre class="programlisting">julia&gt; include("&lt;&lt;path/to/juliascript&gt;&gt;/myjuliascript.jl")</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec62"/>在Julia中实现(带示例)</h2></div></div></div><p>在这一节中，我们将讨论编码Julia和理解语法中的一些基本主题。在本节结束时，读者应该能够轻松地编写Julia脚本并运行。关于语法，Julia编程语言与MATLAB非常相似。</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec63"/>使用变量和赋值</h2></div></div></div><p>Julia中的变量，像任何其他的<a id="id594" class="indexterm"/>编程语言一样，用于存储和操作<a id="id595" class="indexterm"/>数据。以下是定义、分配和操作变量和值的示例:</p><div><pre class="programlisting"># Assign a numeric value to a variable
julia&gt; x = 10
10

# Perform a simple mathematical manipulation of variables
julia&gt; x + 1
11

# Assigning or reassigning values to variables.
julia&gt; x = 1 + 1
2

# Assigning a string literal to a variable
julia&gt; x = "Hello World!"
"Hello, World!"</pre></div><p>作为一种数学编程语言，Julia提供了几个基本常数。下面是一个可以直接在代码中使用的示例。此外，我们可以定义常量并重新赋值:</p><div><pre class="programlisting">julia&gt; pi
π = 3.1415926535897...</pre></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec60"/>数字原语</h3></div></div></div><p>对于任何支持基于数字的计算的数学编程语言来说，整数和浮点值构成了基本的构建模块，被称为数字原语。</p><p>Julia提供了对大量数字原语的支持，这些原语是广泛的、非常完善的数学函数。</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec61"/>数据结构</h3></div></div></div><p>除了所有的原始数据类型，如向量、矩阵、元组、字典、集合等等，Julia还支持几种数据结构。以下是一些表示用法的示例:</p><div><pre class="programlisting"># Vector
b = [4, 5, 6]
b[1] # =&gt; 4
b[end] # =&gt; 6

# Matrix
matrix = [1 2; 3 4]

# Tuple
tup = (1, 2, 3)
tup[1] # =&gt; 1
tup[1] = 3 # =&gt; ERROR #since tuples are immutable, assigning a value results in an error

# Dictionary
dict = ["one"=&gt; 1, "two"=&gt; 2, "three"=&gt; 3]
dict["one"] # =&gt; 1

# Set
filled_set = Set(1,2,2,3,4)</pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec62"/>使用字符串和字符串操作</h3></div></div></div><p>下面是一些在Julia中用字符串操作<a id="id599" class="indexterm"/>的例子<a id="id598" class="indexterm"/>:</p><div><pre class="programlisting">split("I love learning Julia ! ")
# =&gt; 5-element Array{SubString{ASCIIString},1}:
"I"
"love."
"learning."
"Julia"
"!"

join(["It seems to be interesting", "to see",
"how it works"], ", ")
# =&gt; "It seems interesting, to see, how it works."</pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec63"/>套餐</h3></div></div></div><p>Julia附带了几个包<a id="id600" class="indexterm"/>，这些包具有内置的功能，并且支持许多开箱即用的功能来实现机器学习算法。以下是列表:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Images.jl</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Graphs.jl</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">DataFrames.jl</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">DimensionalityReduction.jl</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Distributions.jl</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">NLOpt.jl</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ArgParse.jl</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Logging.jl</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">FactCheck.jl</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">METADATA.jl</code></li></ul></div><p>更多关于茱莉亚包的细节<a id="id601" class="indexterm"/>可以在<a class="ulink" href="https://github.com/JuliaLang/">https://github.com/JuliaLang/</a>获得。</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec64"/>互操作性</h3></div></div></div><p>下一节将介绍Julia与其他各种编程语言的集成。</p><div><div><div><div><h4 class="title"><a id="ch04lvl4sec14"/>与C集成</h4></div></div></div><p>Julia是灵活的，没有任何包装器，支持直接调用C函数。下面的示例演示了这是如何实现的:</p><div><pre class="programlisting">julia&gt; ccall(:clock, Int32, ())
2292761
julia&gt; ccall(:getenv, Ptr{Uint8int8}, (Ptr{Uint8},), "SHELL")
Ptr{Uint8} @0x00007fff5fbffc45
julia&gt; bytestring(ans)
"/bin/bash"</pre></div></div><div><div><div><div><h4 class="title"><a id="ch04lvl4sec15"/>与Python集成</h4></div></div></div><p>类似于C <a id="id604" class="indexterm"/>函数调用，Julia支持直接调用Python函数。重要的是我们已经安装了<code class="literal">PyCall</code>包来实现这个功能。<code class="literal">PyCall.jl</code>提供Julia和Python之间的自动类型转换。例如，Julia数组被转换为NumPy数组。</p><p>以下示例演示了如何从Julia代码中调用Python函数:</p><div><pre class="programlisting">julia&gt; using PyCall # Installed with Pkg.add("PyCall")
julia&gt; @pyimport math
julia&gt; math.sin(math.pi / 4) - sin(pi / 4)
0.0
julia&gt; @pyimport pylab
julia&gt; x = linspace(0,2*pi,1000); y = sin(3*x + 4*cos(2*x));
julia&gt; pylab.plot(x, y; color="red", linewidth=2.0, linestyle="--")
julia&gt; pylab.show()</pre></div></div><div><div><div><div><h4 class="title"><a id="ch04lvl4sec16"/>与MATLAB集成</h4></div></div></div><p>以下示例<a id="id605" class="indexterm"/>演示了集成Julia以调用MATLAB函数:</p><div><pre class="programlisting">using MATLAB

function sampleFunction(bmap::BitMatrix)
@mput bmap
@matlab bmapthin = bwmorph(bmap, "thin", inf)
convert(BitArray, @mget bmapthin)
end</pre></div></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec65"/>图形和标图</h3></div></div></div><p>朱莉娅有几个帮助制作图表的软件包。这里列出了其中的一些<a id="id607" class="indexterm"/>:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Gadfly.jl</code>:这非常类似于ggplot2</li><li class="listitem" style="list-style-type: disc"><code class="literal">Winston.jl</code>:这非常类似于Matplotlib</li><li class="listitem" style="list-style-type: disc"><code class="literal">Gaston.jl</code>:这与gnuplot接口</li></ul></div><p>这里的例子演示了如何使用<code class="literal">PyPlot</code>:</p><div><pre class="programlisting">using PyPlot
x = linspace(-2pi, 2pi)
y = sin(x)
plot(x, y, "--b")</pre></div><div><img src="img/B03980_04_17.jpg" alt="Graphics and plotting"/></div></div></div><div><div><div><div><h2 class="title">收养朱莉娅的好处</h2></div></div></div><p>以下是在机器学习实现中采用Julia的一些直接好处:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Julia在不影响性能的情况下促进了快速原型开发</li><li class="listitem" style="list-style-type: disc">它本质上支持代码的并行化</li><li class="listitem" style="list-style-type: disc">它提供了一种更简单的方法来表达具有特殊Julia类型的算法</li><li class="listitem" style="list-style-type: disc">Julia可以轻松调用或集成C、Python、MATLAB和C++</li><li class="listitem" style="list-style-type: disc">热情、友好和支持的社区为Julia提供了便利</li><li class="listitem" style="list-style-type: disc">它与Hadoop一起工作，并利用基于配置单元的查询</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec65"/>集成Julia和Hadoop</h2></div></div></div><p>将任何<a id="id610" class="indexterm"/>编程语言与Hadoop集成通常意味着存储在Hadoop中的数据应该是可访问的，并且程序应该能够对数据执行特定的逻辑。这可以通过从Hadoop中检索数据并使其更接近程序来实现，也可以通过将程序移动到数据并在MapReduce或并行处理模式下执行来实现。显然，在第一种情况下，从Hadoop中获取数据并提交给执行逻辑的代码，需要足够的RAM来保存和处理内存中的数据，这可能会限制在真正大的卷上运行的能力。在第二种情况下，将代码用于跨数据节点分布的数据，逻辑应该是可并行化的，并且应该构建Map和Reduce逻辑。</p><p>Julia与Hadoop平台的集成还处于初级阶段，目前详细介绍的方法是之前描述的第一种方法，其中使用标准ODBC连接从Julia代码建立到Hadoop/HDFS的连接。数据被提取到RAM中供进一步处理。现在，这段代码可以直接在DataNode上运行，并可以更新HDFS数据。</p><p>我们将使用通过以下链接从GitHub获得的<a id="id611" class="indexterm"/>:</p><p><a class="ulink" href="https://github.com/quinnj/ODBC.jl">https://github.com/quinnj/ODBC.jl</a></p><p>这是Julia的一个简单的底层ODBC接口。它可以通过Julia包管理器使用以下命令进行安装:</p><p>以下命令创建一个Julia包存储库(对所有包只运行一次)</p><div><pre class="programlisting">
<strong>julia&gt; Pkg.init()</strong>
</pre></div><p>以下命令创建<code class="literal">ODBC repo</code>文件夹并下载<code class="literal">ODBC</code>包和依赖项(如果需要)</p><div><pre class="programlisting">
<strong>julia&gt; Pkg.add("ODBC")</strong>
</pre></div><p>下面的命令加载了要使用的<a id="id612" class="indexterm"/> ODBC模块(需要与每个新的Julia实例一起运行)</p><div><pre class="programlisting">
<strong>julia&gt; using ODBC</strong>
</pre></div><p>以下是一些可用于Hadoop/HDFS的重要函数:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">要使用ODBC数据源进行连接，用户和密码使用— <code class="literal">co = ODBC.connect("mydatasource",usr="johndoe",pwd="12345")</code>。</li><li class="listitem" style="list-style-type: disc">使用<code class="literal">disconnect(connection::Connection=conn)</code>断开连接。</li><li class="listitem" style="list-style-type: disc">使用连接字符串连接时，使用<code class="literal">advancedconnect(conn_string::String)</code>。</li><li class="listitem" style="list-style-type: disc">为了进行查询并获取数据源上的数据子集，这个查询字符串是一个将在HDFS上运行的Hive查询— <code class="literal">query(connecti on Connection=conn, querystring; fi le=: DataFrame,delim='\t')</code>。</li></ul></div><p>这里给出了一个示例实现:</p><p>使用以下命令加载ODBC模块:</p><div><pre class="programlisting">
<strong>using ODBC</strong>
</pre></div><p>要通过配置单元连接到Hadoop集群，请使用以下命令:</p><div><pre class="programlisting">
<strong>hiveconn = ODBC.connect("servername"; usr="your-user-name", pwd="your-password-here")</strong>
</pre></div><p>要编写配置单元查询并将其存储为Julia字符串，请使用以下命令:</p><div><pre class="programlisting">
<strong>hive_query_string = "select …;"</strong>
</pre></div><p>要运行查询，请使用以下命令将结果直接保存到文件:</p><div><pre class="programlisting">
<strong>query(hive_query_string, hiveconn;output="C:\\sample.csv",delim=',')</strong>
</pre></div><p>Julia程序现在可以访问这个文件中的数据来执行机器学习算法。</p></div></div>





<title>Python</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title"><a id="ch04lvl1sec27"/> Python</h1></div></div></div><p>Python是机器学习和数据科学领域中被广泛采用的编程或脚本语言之一。Python总是以其易于学习、实现和维护而闻名。Python具有高度的可移植性，可以在基于Unix、Windows和Mac平台上运行。随着Pydoop和SciPy等库的出现，它在大数据分析领域的相关性大大增加了。 Some把Python在解决机器学习问题上受欢迎的关键原因列举如下:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">众所周知，Python非常适合数据分析</li><li class="listitem" style="list-style-type: disc">它是一种多功能的脚本语言，可用于编写一些基本的快速而复杂的脚本来测试一些基本的功能，也可用于利用其全功能工具包的实时应用程序</li><li class="listitem" style="list-style-type: disc">Python自带完整的机器学习包(参考【http://mloss.org/software/】T2)，可以即插即用</li></ul></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec66"/>Python中的工具包选项</h2></div></div></div><p>在我们深入了解Python中有哪些工具箱选项之前，让我们先了解一下在选择工具箱选项之前应该考虑的权衡。</p><p>对于合适的工具包，我们应该评估的一些问题如下:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">我的绩效优先级是什么？我需要离线或实时处理实现吗？</li><li class="listitem" style="list-style-type: disc">工具包有多透明？我可以自己定制库吗？</li><li class="listitem" style="list-style-type: disc">社区地位如何？bug修复的速度有多快，社区支持和专家交流的可用性如何？</li></ul></div><p>Python中有三个选项:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">使用Python外部绑定。这些是市场上流行的软件包的接口，比如Matlab、R、Octave等等。如果我们在前面提到的框架中已经有了一些实现，并且正在考虑无缝迁移到Python中，那么这个选项将会很好地工作。</li><li class="listitem" style="list-style-type: disc">使用基于Python的工具包。有一些用Python编写的工具包附带了一堆算法。下一节将介绍一些Python工具包。</li><li class="listitem" style="list-style-type: disc">写你的逻辑/工具包。</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec67"/>Python的实现(使用示例)</h2></div></div></div><p>Python有两个核心工具包，其中<a id="id616" class="indexterm"/>更多的是构建模块，这里列出的几乎所有专业工具包都使用这些核心工具包。这些措施如下:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">NumPy  : NumPy <a id="id617" class="indexterm"/>是关于用Python构建的快速高效的数组</li><li class="listitem" style="list-style-type: disc">这是NumPy内置的一系列标准运算的算法</li></ul></div><p>有很多基于C/C++的实现，比如LIBLINEAR、LIBSVM、OpenCV等等</p><p>现在让我们看看一些流行的Python工具包，以及在撰写本书的一年时间内更新的工具包:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong> NLTK </strong>:这代表<a id="id619" class="indexterm"/>自然语言工具包。这里重点介绍一下<a id="id620" class="indexterm"/> <strong>自然语言处理</strong> ( <strong> NLP </strong>)。</li><li class="listitem" style="list-style-type: disc"><strong> mlpy </strong>:这是机器学习<a id="id621" class="indexterm"/>算法工具包，支持一些关键的机器学习算法，如分类、回归和聚类等。</li><li class="listitem" style="list-style-type: disc"><strong> PyML </strong>:这个<a id="id622" class="indexterm"/>工具包重点是<a id="id623" class="indexterm"/> <strong>支持向量机</strong> ( <strong> SVM </strong>)。我们将在接下来的章节中详细介绍这一点。</li><li class="listitem" style="list-style-type: disc"><strong> PyBrain </strong>:这个工具包<a id="id624" class="indexterm"/>专注于神经网络和相关功能。</li><li class="listitem" style="list-style-type: disc"><strong> mdp-toolkit </strong>:这个工具包的重点是数据处理，它支持调度和并行处理。</li><li class="listitem" style="list-style-type: disc"><strong> scikit-learn </strong>:这是<a id="id626" class="indexterm"/>最流行的工具包之一，最近被数据科学家广泛采用。它支持有监督的和无监督的学习，对特征选择和可视化有一些特殊的支持。有一个大型团队正在积极地构建这个工具包，并以其出色的文档而闻名。</li><li class="listitem" style="list-style-type: disc"><strong> Pydoop </strong>:这个<a id="id627" class="indexterm"/>是Python与Hadoop平台的集成。</li></ul></div><p><strong> Pydoop </strong>和<strong> SciPy </strong>和<a id="id628" class="indexterm"/>在大数据分析领域有大量部署。</p><p>在本章中，我们将探索scikit-learn工具包，并在接下来的章节中使用该工具包演示我们的所有示例。</p><p>对于Python程序员来说，使用scikit-learn可以非常容易地将机器学习引入生产系统。</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec66"/>安装Python并设置scikit-learn</h3></div></div></div><p>以下是安装Python和scikit-learn的核心<a id="id629" class="indexterm"/> Python <a id="id630" class="indexterm"/>工具包版本和依赖关系:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Python (&gt;= 2.6或&gt; = 3.3)</li><li class="listitem" style="list-style-type: disc">NumPy (&gt;= 1.6.1)</li><li class="listitem" style="list-style-type: disc">SciPy (&gt;= 0.9)。</li><li class="listitem" style="list-style-type: disc">一个有效的C++编译器</li></ul></div><p>我们将使用轮子包(<code class="literal">.whl</code>文件)用于scikit——从PyPI学习，并使用pip实用程序安装它。</p><p>要在您的主目录中安装，请使用以下命令:</p><div><pre class="programlisting">
<strong>python setup.py install --home</strong>
</pre></div><p>要直接从GitHub使用git <a id="id631" class="indexterm"/> repo <a id="id632" class="indexterm"/>在本地磁盘上安装scikit-learn，请使用以下命令:</p><div><pre class="programlisting">
<strong>% git clone git://github.com/scikit-learn/scikit-learn/</strong>
<strong>% cd scikit-learn</strong>
</pre></div><div><div><div><div><h4 class="title"><a id="ch04lvl4sec17"/>加载数据</h4></div></div></div><p>Scikit-learn附带了一些标准数据集，例如，<code class="literal">iris</code>和<code class="literal">digits</code>数据集可用于构建和运行机器学习算法。</p><p>以下是加载scikit-learn附带的标准数据集的一些步骤:</p><div><pre class="programlisting">&gt;&gt;&gt; from sklearn import datasets
&gt;&gt;&gt; iris = datasets.load_iris()
&gt;&gt;&gt; digits = datasets.load_digits()
&gt;&gt;&gt; print digits.data
[[ 0. 0. 5. ..., 0. 0. 0.]
[ 0. 0. 0. ..., 10. 0. 0.]
[ 0. 0. 0. ..., 16. 9. 0.]
...,
[ 0. 0. 1. ..., 6. 0. 0.]
[ 0. 0. 2. ..., 12. 0. 0.]
[ 0. 0. 10. ..., 12. 1. 0.]]
&gt;&gt;&gt; digits.target
array([0, 1, 2, ..., 8, 9, 8])</pre></div></div></div></div></div>





<title>Apache Spark</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title"><a id="ch04lvl1sec28"/>阿帕奇火花</h1></div></div></div><p>Apache Spark <a id="id633" class="indexterm"/>是一个用于快速、大数据或大规模处理的开源框架，支持流、SQL、机器学习和图形处理。这个框架是用Scala实现的，支持Java、Scala、Python等编程语言。性能是传统Hadoop堆栈的10到20倍。Spark是一个通用框架，它允许交互式编程以及对流的支持。Spark可以在独立模式下与支持Hadoop格式(如SequenceFiles或InputFormats)的Hadoop一起工作。它包括本地文件系统、Hive、HBase、Cassandra和亚马逊S3等。</p><p>我们将在本书的所有例子中使用Spark 1.2.0。</p><p>下图描述了Apache Spark的<a id="id634" class="indexterm"/>核心模块:</p><div><img src="img/B03980_04_24.jpg" alt="Apache Spark"/></div><p>Spark框架的一些基本功能包括任务调度、与存储系统的交互、容错和内存管理。Spark遵循一种被称为<a id="id635" class="indexterm"/> <strong>的编程范式，即弹性分布式数据集</strong> ( <strong> RDD </strong>)。这主要与管理分布式数据存储和并行计算有关。</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong> Spark SQL </strong>是Spark的<a id="id636" class="indexterm"/>包，用于查询和处理结构化和非结构化数据。这个包的核心功能是:<div> <ul class="itemizedlist"> <li class="listitem" style="list-style-type: disc">以便于从各种结构化源(如Hive、JSON等)加载数据</li> <li class="listitem" style="list-style-type: disc">以便提供SQL和常规Python或Java或Scala代码之间的集成，并提供构建自定义函数的能力，这些函数可以在分布式数据上并行执行</li> <li class="listitem" style="list-style-type: disc">以支持通过标准数据库<a id="id637" class="indexterm"/>连接(JDBC/ODBC)从外部工具进行基于SQL的查询，包括<strong> Tableau </strong> </li> </ul> </div></li><li class="listitem" style="list-style-type: disc"><strong> Spark Streaming </strong> <a id="id638" class="indexterm"/>模块用于处理实时、大规模的数据流。这个API不同于Hadoop的流I/O API。</li><li class="listitem" style="list-style-type: disc"><strong> MLib </strong>模块<a id="id639" class="indexterm"/>提供开箱即用的机器学习算法功能，可扩展并可在集群上运行。</li><li class="listitem" style="list-style-type: disc"><strong> GraphX </strong>模块<a id="id640" class="indexterm"/>提供图形操作功能。</li></ul></div><p>在本章中，我们将学习如何结合Scala编程语言使用Spark。现在让我们快速了解一下Scala，并学习如何用Scala编码。</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec68"/> Scala</h2></div></div></div><p>Scala <a id="id641" class="indexterm"/>是一种强类型编程语言，需要<a id="id642" class="indexterm"/> <strong> JVM </strong> ( <strong> Java虚拟机</strong>)才能运行。它是一个独立的平台，可以利用Java APIs。我们将使用解释提示来运行Scala和Spark。这里的命令提示符显示了如何使用解释提示符运行Scala和Spark。</p><div><img src="img/B03980_04_18.jpg" alt="Scala"/></div><p>让我们来看一些<a id="id643" class="indexterm"/> Scala的例子。</p><p>以下代码可以直接粘贴到命令提示符中:</p><div><pre class="programlisting">//Default variables are assigned to any expressions
scala&gt;8 * 5 + 2
Res0: Int = 42
Scala&gt;0.5 * res0
Res1= Double = 21.0
//All simple data types are objects
scala&gt;"Hello, " + res0
Res2: java.lang.String = Hello, 42
scala&gt;10.toString()
Res2: String = 10
scala&gt;a.+(b)
Res1: Int = 200            //So you can consider , the operator as a method
A method b as a shorthand for a.method(b)
scala&gt;val myVal: String = "Foo"
keyword "val" this means that a variable cannot change value  (immutable variable)
scala&gt;var myVar:String = "Foo"
the keyword var means that it is a variable that can be changed (mutable variable)
scala&gt; def cube(a: Int): Int = a * a * a
cube: (a: Int)Int
scala&gt; myNumbers.map(x =&gt; cube(x))
res8: List[Int] = List(1, 8, 27, 64, 125, 64, 27)
scala&gt; myNumbers.map(x =&gt; x * x * x)
res9: List[Int] = List(1, 8, 27, 64, 125, 64, 27)
scala&gt; val myNumbers = List(1,2,3,4,5,4,3)
myNumbers: List[Int] = List(1, 2, 3, 4, 5, 4, 3)
scala&gt; def factorial(n:Int):Int = if (n==0) 1 else n * factorial(n-1)
factorial: (n: Int)Int
scala&gt; myNumbers.map(factorial)
res18: List[Int] = List(1, 2, 6, 24, 120, 24, 6)
scala&gt; myNumbers.map(factorial).sum
res19: Int = 183
scala&gt; var factor = 3
factor: Int = 3
scala&gt; val multiplier = (i:Int) =&gt; i * factor
multiplier: Int =&gt; Int = &lt;function1&gt;
scala&gt; val l1 = List(1,2,3,4,5) map multiplier
l1: List[Int] = List(3, 6, 9, 12, 15)
scala&gt; factor = 5
factor: Int = 5</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec69"/>使用弹性分布式数据集编程(RDD)</h2></div></div></div><p>rdd是Spark处理数据的核心抽象。它们是不可变的分布式元素集合。Spark中的所有功能都只能在rdd上运行。</p><p>Spark自动将rdd中包含的数据作为分区分布在集群中的节点上，并支持在这些节点上执行并行处理。rdd可以通过从外部数据集导入或在驱动程序中分发集合来创建。以下命令演示了此功能:</p><div><pre class="programlisting">scala&gt; val c = file.filter(line =&gt; line.contains("and"))</pre></div><p><code class="literal">collect()</code>方法将把输出写到控制台:</p><div><pre class="programlisting">scala&gt;c.collect()</pre></div><p>结果的输出通常保存到外部存储系统。<code class="literal">count()</code>函数给出输出行数。下面将打印出这些行:</p><div><pre class="programlisting">scala&gt;println("input had " + c.count() + " lines")</pre></div><p><code class="literal">take()</code>函数将从结果中获取<em> n </em>条记录:</p><div><pre class="programlisting">scala&gt;c.take(10).foreach(println)</pre></div><p>Spark以懒惰的方式处理RDDs，以提高处理大型数据集的效率。</p><p>要在多个动作中重用RDD，可以使用<code class="literal">RDD.persist()</code>让Spark持久化它。</p><p>我们可以要求Spark将我们的数据保存在不同的地方。在第一次计算之后，Spark会将RDD内容存储在内存中(跨集群中的机器进行分区),并在将来的操作中重用它们。</p><p>因此，以下是处理rdd的基本步骤:</p><div><ol class="orderedlist arabic"><li class="listitem">从外部数据创建输入rdd。</li><li class="listitem">使用转换来转换它们以定义新的rdd，例如<code class="literal">filter()</code>。</li><li class="listitem">使用<code class="literal">persist()</code>存储中间rdd以备再次使用。</li><li class="listitem">调用任何需要的函数(如<code class="literal">count()</code>)启动并行计算过程。</li></ol></div><p>下面是一个<a id="id645" class="indexterm"/>RDD在Scala中使用Pi估算的例子:</p><div><pre class="programlisting">scala&gt;var NUM_SAMPLES=5
scala&gt; val count = sc.parallelize(1 to NUM_SAMPLES).map{i =&gt;
     | val x = Math.random()
     | val y = Math.random()
     |  if (x*x + y*y &lt; 1) 1 else 0
     | }.reduce(_ + _)
scala&gt;println("Pi is roughly " + 4.0 * count / NUM_SAMPLES)</pre></div></div></div>





<title>Spring XD</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title"><a id="ch04lvl1sec29"/>春XD</h1></div></div></div><p>虽然这本书不包括演示机器学习算法的<a id="id646" class="indexterm"/> Spring XD框架，但这里给出了一个小的介绍，因为这是在机器学习世界中迅速出现的。</p><p>XD代表极端数据。这个开源框架由Pivotal团队(前身为SpringSource)构建，作为开发和部署大数据应用的一站式商店。</p><p>Spring XD是一个分布式、可扩展的框架，它统一了实时、批量的数据接收和分析功能，并支持数据导出。Spring XD建立在Spring Integration和Spring Batch框架之上。</p><p>以下是一些<a id="id647" class="indexterm"/>关键特性:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Spring XD是批处理和流工作负载的统一平台。它是一个开放的、可扩展的运行时。</li><li class="listitem" style="list-style-type: disc">它是一个可扩展的高性能分布式数据接收框架，可以从包括HDFS、NOSQL或Splunk在内的各种来源接收数据。</li><li class="listitem" style="list-style-type: disc">它支持在摄取时进行实时分析，例如收集指标和计算值。</li><li class="listitem" style="list-style-type: disc">它通过批处理作业进行工作流管理，包括与标准RDBMS和Hadoop系统的交互。</li><li class="listitem" style="list-style-type: disc">这是一种<a id="id648" class="indexterm"/>可扩展的高性能数据导出，例如，从HDFS到RDBMS或NoSQL数据库。</li></ul></div><p>众所周知，Spring XD实现了Lambda架构，该架构在理论上被定义为支持批处理和实时处理。关于Lambda架构等进化架构的更多信息，请参见<a class="link" href="ch14.html" title="Chapter 14. New generation data architectures for Machine learning">第14章</a>、<em>机器学习的新一代数据架构</em>。</p><p>Spring XD架构主要<a id="id649" class="indexterm"/>有三个架构层来帮助促进前面的特性:</p><div><ol class="orderedlist arabic"><li class="listitem"><strong>速度层</strong>:这是关于实时访问和处理数据的<a id="id650" class="indexterm"/>。这一过程使系统保持最新。<div> <img src="img/B03980_04_19.jpg" alt="Spring XD"/> </div></li><li class="listitem"><strong>批处理层</strong>:批处理层<a id="id651" class="indexterm"/>可以访问完整的主数据集，也称为数据湖，意思是<em>真实的来源</em>。<div> <img src="img/B03980_04_20.jpg" alt="Spring XD"/> </div></li><li class="listitem"><strong>服务层</strong>:服务<a id="id652" class="indexterm"/>层更像是一个查询层，负责向未订阅的消费者公开数据后处理。这一层使得批量数据可查询，并且通常以高吞吐量驱动的响应而闻名。<div> <img src="img/B03980_04_23.jpg" alt="Spring XD"/> </div></li></ol></div><p>这里显示了Spring XD运行时架构(source Pivotal):</p><div><img src="img/B03980_04_22.jpg" alt="Spring XD"/></div></div>





<title>Summary</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title"><a id="ch04lvl1sec30"/>总结</h1></div></div></div><p>在本章中，我们了解了实现机器学习的开源选项，并涵盖了库、工具和框架(如Apache Mahout、Python、R、Julia和Apache Spark的MLib)的安装、实现和执行。重要的是，我们讨论了这些框架与大数据平台(Apache Hadoop)的集成。本章更多的是为后面的章节打下基础，在后面的章节中我们将学习如何使用这些框架来实现特定的机器学习算法。</p></div>
</body></html>