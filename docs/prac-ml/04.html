<html><head/><body>



<title>Chapter 4. Machine Learning Tools, Libraries, and Frameworks</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title"><a id="ch04"/>第四章。机器学习工具、库和框架</h1></div></div></div><p>在前一章中，我们介绍了机器学习解决方案架构和技术平台 Hadoop 的实现方面。在这一章中，我们将看看一些被广泛采用的和即将出现的机器学习工具、库和框架。本章是后续章节的入门，因为它涵盖了如何使用已识别的机器学习框架的现成功能来实现特定的机器学习算法。</p><p>我们将首先介绍市场上可用的开源和商业机器学习库或工具的情况，并挑选出五大开源选项。对于每个确定的选项，从安装步骤开始，学习语法，实现复杂的机器学习算法，到绘制图表，我们将涵盖所有内容。按照出现的顺序，本章对读者来说是强制性的，因为它是后面章节中所有示例实现的基础。</p><p>每个确定的框架都可以作为独立的库运行，也可以在 Hadoop 上运行。除了学习如何编程和实现机器学习算法之外，我们还将介绍每个已确定的框架如何在 Hadoop 上集成和运行；这就是这些教程与网上主流教程的不同之处。</p><p>本章将深入介绍此处列出的主题:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">商业和开源机器学习库的简要列表。</li><li class="listitem" style="list-style-type: disc">涵盖的顶级库或框架有 R、Mahout、Julia、Python(特别是机器学习库)和 Spark。</li><li class="listitem" style="list-style-type: disc">Apache Mahout <a id="id491" class="indexterm"/>是一个用于运行基于 Hadoop 构建的机器学习算法的框架，是一个基于 Java 的开源机器学习选项。这个框架也可以独立工作。它以对大量数据运行机器学习算法而闻名。这个框架是 Hadoop 生态系统组件的一部分，有它的分布。</li><li class="listitem" style="list-style-type: disc">r 是一个开源的机器学习和数据挖掘工具，在机器学习社区中被广泛采用。这个框架库既可以独立工作，也可以使用 Hadoop runtime R 扩展在 Hadoop 上运行。</li><li class="listitem" style="list-style-type: disc">Julia 是一种开源的高性能编程语言，支持以分布式和并行的方式运行数值和统计计算功能。</li><li class="listitem" style="list-style-type: disc">Python 是一种<a id="id494" class="indexterm"/>解释的高级编程语言，旨在尝试不同的东西，它不属于传统的瀑布式开发方式。我们将探索基本的 Python 库— <strong> NumPy </strong> <a id="id495" class="indexterm"/>和<strong> SciPy </strong> <a id="id496" class="indexterm"/>，并使用 scikit-learn 来执行我们的第一个机器学习程序。此外，我们将探索如何用 Python 编写 Hadoop MapReduce 程序。</li><li class="listitem" style="list-style-type: disc">Apache Spark <a id="id497" class="indexterm"/>及其机器学习核心库:Spark 是一个集群计算系统，具有用于 Java、Python 和 Scala 的 API。我们将探索用于机器学习的<strong> MLlib API </strong> <a id="id498" class="indexterm"/>，并为 Apache Hadoop 使用一个版本。重点将是探索 Spark Java APIs。</li><li class="listitem" style="list-style-type: disc">Spring XD <a id="id499" class="indexterm"/>及相关机器学习库简介。</li><li class="listitem" style="list-style-type: disc">对于每个已确定的机器学习框架，与 Hadoop 的集成将是主要关注点。</li></ul></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec23"/>机器学习工具——一个景观</h1></div></div></div><p>在过去的几十年里，市场上有几个开源和<a id="id500" class="indexterm"/>商业机器学习框架和工具在发展。虽然机器学习领域本身正在为不同领域的不同需求构建强大的算法，但我们现在看到大规模机器学习的开源选项激增，这些选项已经达到了相当高的成熟度，并被数据科学和机器学习社区广泛采用。</p><p>该模型在最近几年发生了重大变化，研究人员被鼓励在开源模型下发布他们的软件。由于作者在发布他们使用算法实现进行机器学习的工作时会面临一些问题，因此任何通过数据科学社区的使用进行审查和即兴创作的工作都被认为更有价值。</p><p>下图显示了市场上一些重要的商业和开源机器学习框架和工具的概念模型。本章<a id="id501" class="indexterm"/>将深入介绍突出显示的内容。</p><div><img src="img/B03980_04_01.jpg" alt="Machine learning tools – A landscape"/></div><p>其中一些库围绕特定的编程语言，如 Java、Python、C++、Scala 等等。其中一些库，如 Julia、Spark 和 Mahout，已经支持分布式和并行处理，其他库如 R 和 Python 可以在 Hadoop 上作为 MapReduce 函数运行。</p><p>在以下章节中，对于<a id="id502" class="indexterm"/>每个突出显示的机器学习库，将涵盖以下内容:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">库或工具的概述，以及支持的开箱即用机器学习功能的详细信息</li><li class="listitem" style="list-style-type: disc">安装、设置和配置指南</li><li class="listitem" style="list-style-type: disc">介绍语法和基本数据处理功能，然后介绍高级机器学习功能的示例实现</li><li class="listitem" style="list-style-type: disc">可视化和绘图样本(如适用)</li><li class="listitem" style="list-style-type: disc">Hadoop 平台上的集成和执行</li></ul></div></div></div>





<title>Apache Mahout</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title">阿帕奇看象人</h1></div></div></div><p>Apache Mahout 是一个<a id="id503" class="indexterm"/>机器学习库，与 Apache Hadoop 打包在一起，是 Hadoop 生态系统的重要组成部分。</p><p>Mahout 于 2008 年作为 Apache Lucene(一个开源搜索引擎)的子项目出现。Lucene 是一个 API，它实现了搜索、文本挖掘和信息检索技术。这些搜索和文本分析中的大多数都在内部应用了机器学习技术。为搜索引擎构建的推荐引擎开始于一个叫做 Mahout 的新的子项目。Mahout 的意思是大象的<em>骑手，表示机器学习算法在 Hadoop 上的运行。这是一个可扩展的机器学习实现，也可以在独立模式下运行(不与 Hadoop 紧密集成)。</em></p><div><img src="img/B03980_04_02.jpg" alt="Apache Mahout"/></div><p>Mahout 是一组基本的机器学习 Java 库，用于分类、聚类、模式挖掘等等。尽管 Mahout 今天提供了对机器学习算法子集的支持，但它仍然是最受欢迎的框架之一，因为它固有地支持对数亿行的大型数据集进行分析，这些数据集本质上也可以是非结构化的。</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec54"/>看象人是如何工作的？</h2></div></div></div><p>Mahout 实现了<a id="id504" class="indexterm"/> Hadoop MapReduce，最重要的方面是它工作在 Hadoop 之上，应用了分布式计算范式。</p><div><img src="img/B03980_04_03.jpg" alt="How does Mahout work?"/></div><p>下面是 Mahout 目前实现的一些具体的机器学习任务:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>协同过滤/推荐</strong>:这个<a id="id505" class="indexterm"/>接受用户输入并找到用户可能喜欢的项目</li><li class="listitem" style="list-style-type: disc"><strong>集群</strong>:它将一组<a id="id506" class="indexterm"/>文档作为输入，并根据它们引用/所属的主题对它们进行分组</li><li class="listitem" style="list-style-type: disc"><strong>分类</strong>:这需要一堆<a id="id507" class="indexterm"/>文档，基于现有的文档分类，了解给定文档可能属于哪个类别，并将文档映射到那个类别</li><li class="listitem" style="list-style-type: disc"><strong>频繁项目集挖掘</strong>:这将<a id="id508" class="indexterm"/>一堆项目作为输入，并基于对真实事件的学习，识别哪些项目出现或一起出现</li></ul></div><p>有一些特定的<a id="id509" class="indexterm"/>算法，例如逻辑回归和 SVM(关于这些算法的更多内容将在后面的章节中介绍)，它们不能并行化，也不能在独立模式下运行。</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec55"/>安装和设置 Apache Mahout</h2></div></div></div><p>在这一章中，我们将<a id="id510" class="indexterm"/>看看如何在独立模式和<a id="id511" class="indexterm"/> Hadoop 上运行 Mahout。虽然在撰写本书时，Apache Mahout 已经有了新的 1.0 版本，但是在所有的例子中，我们将使用 0.9 版本(最新的稳定版本)。使用的操作系统是 Ubuntu 12.04 桌面 32 位版本。</p><p>以下是安装 Apache Mahout 的依赖项和关键要求:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">JDK (1.6 或以上；在本书中，我们将使用 1.7 u9 版本作为示例)</li><li class="listitem" style="list-style-type: disc">Maven (2.2 或以上；我们将在本书中使用 3.0.4 作为例子)</li><li class="listitem" style="list-style-type: disc">Apache Hadoop(2.0；不是强制性的，因为 Mahout 可以在本地运行)</li><li class="listitem" style="list-style-type: disc">Apache Mahout (0.9 发行版)</li><li class="listitem" style="list-style-type: disc">开发环境—Eclipse IDE (Luna)</li></ul></div><p>在<a class="link" href="ch03.html" title="Chapter 3. An Introduction to Hadoop's Architecture and Ecosystem">第 3 章</a>、<em>Hadoop 架构和生态系统介绍</em>中，我们已经了解了 Apache Hadoop 2.0 单节点安装是如何完成的，以及所需的先决条件，如 Java。</p><p>在这一章中，我们将介绍<a id="id512" class="indexterm"/>为开发环境设置 Maven 和 Eclipse，以及配置 Apache Mahout 在 Hadoop 上和 Hadoop 下运行。由于考虑的平台和相关框架都是开源的，我们将使用 Windows 7 专业版托管的 VirtualBox 机器仿真器<a id="id513" class="indexterm"/>。</p><p>您可能还记得，Hadoop 不能作为根用户运行，因此我们为此创建了一个用户— <code class="literal">practical-ml</code>来安装和运行一切。</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec49"/>设置 Maven</h3></div></div></div><p>建议使用<a id="id514" class="indexterm"/> Maven 来获得所需的 Mahout jars，使用 Mahout 可以很容易地切换到任何新版本。如果没有 Maven，下载依赖项会变得更加复杂。有关 Maven 的具体特性及其在应用程序开发中的效用的更多详细信息，请参考<a class="ulink" href="https://www.packtpub.com/application-development/apache-maven-3-cookbook">https://www . packtpub . com/application-development/Apache-Maven-3-cookbook</a>。</p><p>maven 3 . 0 . 4 版可以从 Apache 网站的镜像之一下载。以下命令可用于此目的:</p><div><pre class="programlisting">
<strong>wget http://it.apache.contactlab.it/maven/maven-3/3.0.4/binaries/apachemaven-3.0.4-bin.tar.gz</strong>
</pre></div><p>要手动安装 Maven，请执行以下说明:</p><div><ol class="orderedlist arabic"><li class="listitem">将发行版归档文件(即<code class="literal">apache-maven-3.0.4-bin.tar.gz</code>)解压到您希望安装 Maven 3.0.4 的目录中。</li><li class="listitem">有了这些指令，将选择<code class="literal">/usr/local/apache-maven</code>路径。将从归档文件中创建一个<code class="literal">apache-maven-3.0.4</code>子目录。</li><li class="listitem">以下几行需要追加到<code class="literal">.bashrc</code>文件中:<div> <pre class="programlisting">export M2_HOME=/usr/local/apache-maven-3.0.4 export M2=$M2_HOME/bin export PATH=$M2:$PATH export JAVA_HOME=$HOME/programs/jdk</pre> </div></li></ol></div><p><code class="literal">JAVA_HOME</code>应指向安装 JDK 的位置。例如，导出<code class="literal">JAVA_HOME=/usr/java/jdk1.7. $JAVA_HOME/bin</code>在您的<code class="literal">PATH</code>环境变量中。<code class="literal">PATH</code>变量是在 Java 安装期间设置的。这个要验证一下。</p><p>我们现在可以通过运行以下命令来检查 Maven 是否成功安装:</p><div><pre class="programlisting">
<strong>mvn –version</strong>
</pre></div><p>如果有任何<a id="id515" class="indexterm"/>代理设置，我们将不得不显式更新<code class="literal">settings.xml</code>文件中的代理设置，该文件位于 Maven 安装的<code class="literal">conf</code>文件夹中。</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec50"/>使用 Eclipse IDE 设置 Apache Mahout</h3></div></div></div><p>接下来详细介绍的过程<a id="id516" class="indexterm"/>涵盖了设置<a id="id517" class="indexterm"/> Mahout 环境、代码库、访问示例、运行、调试以及使用 Eclipse IDE 测试它们的步骤。这是推荐的设置方式，也是为开发团队设置 Apache Mahout 的最简单的方式。</p><p>执行以下步骤来获取 Apache Mahout tar，解压缩它并导航到安装。</p><div><ol class="orderedlist arabic"><li class="listitem">Set up Eclipse IDE.<p>Eclipse <a id="id518" class="indexterm"/>的最新版本可以从以下链接下载:</p><p><a class="ulink" href="https://www.eclipse.org/downloads/">https://www.eclipse.org/downloads/</a></p></li><li class="listitem">使用下面的命令从直接链接下载 Mahout 发行版:<div> <pre class="programlisting"> <strong>$ wget -c http://archive.apache.org/dist/mahout/0.9/mahout-distribution-0.9.tar.gz</strong> </pre> </div></li><li class="listitem">使用以下命令从其中提取归档文件:<div> <pre class="programlisting"> <strong>$ tar zxf mahout-distribution-0.9.tar.gz</strong> </pre> </div></li><li class="listitem">Convert the project into an Eclipse project:<div><pre class="programlisting">
<strong>$ cd mahout-distribution-0.9</strong>
<strong>$ mvn eclipse: eclipse</strong>
</pre></div><p>前面的命令构建了 Eclipse 项目。</p></li><li class="listitem">将<code class="literal">M2_REPO</code> classpath 变量设置为指向本地存储库路径。以下命令将所有 Maven jars 添加到 Eclipse 类路径:<div> <pre class="programlisting"> <strong>mvn -Declipse.workspace= eclipse:add-maven-repo</strong> </pre> </div></li><li class="listitem">Now, let's <a id="id519" class="indexterm"/>import the Eclipse Mahout <a id="id520" class="indexterm"/>projects.<p>从菜单中导航，<strong>文件</strong> | <strong>导入</strong> | <strong>常规</strong> | <strong>现有项目</strong>到<strong>工作区</strong>。</p><div><img src="img/B03980_04_04.jpg" alt="Setting-up Apache Mahout using Eclipse IDE"/></div></li></ol></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec51"/>在没有 Eclipse 的情况下设置 Apache Mahout</h3></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">使用下面的命令从直接链接下载<a id="id521" class="indexterm"/> Mahout 发行版:<div> <pre class="programlisting"> <strong>$ wget -c http://archive.apache.org/dist/mahout/0.9/mahout-distribution-0.9.tar.gz</strong> </pre> </div></li><li class="listitem">将 Mahout 分发解压到<code class="literal">/usr/local</code>文件夹:<div> <pre class="programlisting"> <strong>$ cd /usr/local</strong> <strong>$ sudo tar xzf mahout-distribution-0.9.tar.gz</strong> <strong>$ sudo mv mahout-distribution-0.9.tar.gz mahout</strong> <strong>$ sudo chown –R practical-ml:hadoop mahout</strong> </pre> </div></li><li class="listitem">Set the Java, Maven, and Mahout paths in the <code class="literal">.bashrc</code> file.<p>使用下面的命令打开<code class="literal">.bashrc</code>文件:</p><div><pre class="programlisting">
<strong>gedit ~/.bashrc</strong>
</pre></div><p>将以下内容添加到文件中:</p><div><pre class="programlisting">export MAHOUT_HOME = /usr/local/mahout
path=$path:$MAHOUT_HOME/bin
export M2_HOME=/usr/local/maven
export PATH=$M2:$PATH
export M2=$M2_HOME/bin
PATH=$PATH:$JAVA_HOME/bin;$M2_HOME/bin</pre></div></li><li class="listitem">To run Mahout in the local mode (this means in the standalone mode where there is no need for Hadoop, and the algorithms will not run in parallel or MapReduce mode).<p>使用以下命令将本地模式设置为 true:</p><div><pre class="programlisting">
<strong>$MAHOUT_LOCAL=true</strong>
</pre></div><p>这将迫使 Mahout 不去寻找<code class="literal">$HADOOP_CONF_DIR</code>中的 Hadoop 配置。</p><p><code class="literal">MAHOUT_LOCAL</code>已设置，所以我们不将<code class="literal">HADOOP_CONF_DIR</code>添加到类路径中。</p></li></ol></div><p>有一种方法可以在 Hadoop 上运行<a id="id522" class="indexterm"/> Mahout。首先，确保 Hadoop 2.x 安装和配置成功。然后，按照以下说明操作:</p><div><ol class="orderedlist arabic"><li class="listitem">Set <code class="literal">$HADOOP_HOME</code>, <code class="literal">$HADOOP_CONF_DIR</code> are set and added to <code class="literal">$PATH</code>.<div><pre class="programlisting">
<strong>export HADOOP_CONF_DIR=$HADOOP_HOME/conf</strong>
</pre></div><p>上面设置了 Hadoop 运行的模式(例如在<code class="literal">core-site.xml</code>、<code class="literal">hdfs-site.xml</code>、<code class="literal">mapred-site.xml</code>等等)。)</p></li><li class="listitem">现在，使用下面的命令启动 Hadoop 实例:<div> <pre class="programlisting"> <strong>$HADOOP_HOME/bin/start-all.sh</strong> </pre> </div></li><li class="listitem">检查<code class="literal">http://localhost:50030</code>和<code class="literal">http://localhost:50070</code>URL 以确认<a id="id523" class="indexterm"/> Hadoop 是否启动并运行。</li><li class="listitem">通过从 Mahout 目录运行以下 Maven 命令，使用 Maven 构建 Apache Mahout:<div><pre class="programlisting"> <strong>/usr/local/mahout$ mvn install</strong> </pre></div></li></ol></div><p>成功安装后会看到以下输出:</p><div><img src="img/B03980_04_05.jpg" alt="Setting up Apache Mahout without Eclipse"/></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec56"/>看象人包</h2></div></div></div><p>下图描述了 Mahout 中的<a id="id524" class="indexterm"/>不同的包，它们为几种机器学习算法提供了一些现成的支持。核心模块是实用程序、数学向量、集合、Hadoop 和 MapReduce，用于并行处理，文件系统用于分布式存储。</p><p>此外，核心模块之上是<a id="id525" class="indexterm"/>机器学习包，如下所示:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">分类</li><li class="listitem" style="list-style-type: disc">使聚集</li><li class="listitem" style="list-style-type: disc">进化算法</li><li class="listitem" style="list-style-type: disc">推荐人</li><li class="listitem" style="list-style-type: disc">回归</li><li class="listitem" style="list-style-type: disc">设备功率监察器(Facility Power Monitor)</li><li class="listitem" style="list-style-type: disc">维度缩减<div> <img src="img/B03980_04_06.jpg" alt="Mahout Packages"/> </div></li></ul></div><p>更多的细节在前面的包中有详细的介绍，在接下来的章节中会有使用每个包来解决问题的示例实现。</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec57"/>在 Mahout 中实现矢量</h2></div></div></div><p>正如我们所理解的，为了<a id="id527" class="indexterm"/>在 Mahout 中演示大多数机器学习<a id="id528" class="indexterm"/>算法的实现，我们需要经典 Mahout 数据集格式的数据。核心部分的代码主要是使用一些 Mahout 现成的脚本，并对设置做一些小的修改。下面给出了标准流程:</p><div><ol class="orderedlist arabic"><li class="listitem">Create sequence files from the raw text files.<p><strong>序列文件</strong> <a id="id529" class="indexterm"/>主要是数据的键/值对表示的二进制编码。接下来给出的属性是表示元数据详细信息的关键头元素:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">版本</li><li class="listitem" style="list-style-type: disc">键名</li><li class="listitem" style="list-style-type: disc">值名</li><li class="listitem" style="list-style-type: disc">压缩</li></ul></div></li><li class="listitem">从序列文件生成向量。更多关于生成序列文件的实际命令将在后面的章节中介绍，同时演示每个已识别的机器学习算法的实现。</li><li class="listitem">在这些工作向量上运行函数</li></ol></div><p>Mahout 中有不同类型的 vector 实现，这些定义通常也适用。</p><div><img src="img/B03980_04_07.jpg" alt="Implementing vectors in Mahout"/></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>密集向量</strong>:这些<a id="id530" class="indexterm"/>向量通常是一个 doubles 的数组，这个向量的大小与数据集中的特征数量相同。由于所有条目都是预先分配的，与零值无关，因此这些向量被称为密集向量。</li><li class="listitem" style="list-style-type: disc"><strong>稀疏向量</strong>:这些<a id="id531" class="indexterm"/>向量是向量数组，仅用非零值或空值表示。对于稀疏向量，有两个子类别:随机访问和顺序访问稀疏向量。<div> <ul class="itemizedlist"> <li class="listitem" style="list-style-type: disc"> <strong>随机访问稀疏向量</strong>:随机访问稀疏向量是 HashMap <a id="id532" class="indexterm"/>表示<a id="id533" class="indexterm"/>，其中键是一个整数值，值是一个 double 值。在任何给定的时间点，都可以通过传入给定的键来访问值。</li> <li class="listitem" style="list-style-type: disc"> <strong>顺序访问稀疏向量</strong>:这些向量只不过是一组两个数组<a id="id534" class="indexterm"/>，其中第一个数组<a id="id535" class="indexterm"/>是键数组(整数)，第二个数组是值数组(双精度)。与随机访问稀疏向量不同，这些向量针对线性读取进行了优化。同样，只对非零值进行存储。</li></ul></div><div><div><h3 class="title"><a id="note04"/>注</h3> <p>有关使用 Apache Mahout 的详细理解，请参考 Apache Mahout 的 Packt 出版物，标题为<em> Apache Mahout 食谱</em>。</p></div>T37】</div></li></ul></div><p>虽然本节涵盖了一个为与 Hadoop 一起工作而构建的框架，但只做了很小的配置更改，在下一节中，我们将介绍市场上广泛采用的强大选项—R。Hadoop 提供了显式适配器，使 R 程序能够在 MapReduce 模型中工作，这将在下一节中介绍。</p></div></div>





<title>R</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title"><a id="ch04lvl1sec25"/> R</h1></div></div></div><p>r 是一种用于数据分析的<a id="id536" class="indexterm"/>语言，被用作机器学习、统计计算和数据挖掘领域的主要驱动程序，并为基本和高级可视化或图形提供了一个全面的平台。如今，R 是几乎所有数据科学家或潜在数据科学家都拥有或<em>必须</em>学习的一项基本技能。</p><p>r 主要是一个 GNU 项目，众所周知它类似于 S 语言，S 语言最初是由约翰·钱伯斯和他的团队在贝尔实验室(以前叫美国电话电报公司，现在叫朗讯科技)开发的。S 最初的目标是支持所有的统计功能，并被核心统计人员广泛使用。</p><p>R 附带了大量的开放源码包，可以免费下载和配置，并根据需要安装或加载到 R 环境中。这些包为各种各样的统计技术提供现成的支持，包括线性和非线性建模、时间序列分析、分类、聚类等等。</p><p>除此之外，还提供了高度可扩展的图形功能。对这些高级图形功能的支持是 R 的主要优势，因为其输出以出版质量图著称。除此之外，R 还支持许多开源的图形库和可视化工具，它们本质上都是开源的和商业化的。</p><p>尽管在核心上，R 并不意味着在分布式环境中工作或以并行模式运行算法，但有几个可用的扩展(开源和商业的)使 R 更具可伸缩性并支持大型数据集。在这一章中，我们将介绍 R 如何与 Apache Hadoop 集成，从而运行和利用 MapReduce 功能。</p><p>最重要的是，R 是被广泛采用的自由软件，有许多提交者和支持团体一直致力于保持它在数据科学领域的高度相关性。</p><p>下面列出了 R 目前支持的一些关键功能:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">有效管理和存储模型所操作的数据的能力</li><li class="listitem" style="list-style-type: disc">为数组、向量和矩阵等的计算提供一些核心函数套件</li><li class="listitem" style="list-style-type: disc">几个现成的机器学习功能，可以按需加载，有助于轻松实施数据科学项目</li><li class="listitem" style="list-style-type: disc">高级和复杂的图形功能，可以轻松使用，并有助于为企业所有者生成有价值的仪表板</li><li class="listitem" style="list-style-type: disc">一个由采纳者和提交者组成的广泛而活跃的社区，通过大量软件包的扩展而迅速发展</li><li class="listitem" style="list-style-type: disc">r 被认为是一个支持新开发的交互式数据分析方法的平台</li></ul></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec58"/>安装和设置 R</h2></div></div></div><p>对于本书中的所有例子<a id="id538" class="indexterm"/>，我们将使用 R 的稳定版本 2.15.1 和所有<a id="id540" class="indexterm"/>最新 R 包的<a id="id539" class="indexterm"/> CRAN 参考。</p><p>参考<a class="ulink" href="https://cran.r-project.org/bin/windows/base/old/2.15.1/">https://cran.r-project.org/bin/windows/base/old/2.15.1/</a>链接下载 R for Windows。</p><p>详细的安装过程见<a class="ulink" href="https://cran.r-project.org/doc/manuals/R-admin.html#Top">https://cran.r-project.org/doc/manuals/R-admin.html#Top</a>。</p><p>我们可以在 R GUI 或 IDE RStudio 中使用 R。下面是 R 界面的截图，用户可以在成功安装 R GUI 和 R IDE 以及 RStudio 后看到。</p><div><img src="img/B03980_04_08.jpg" alt="Installing and setting up R"/></div><p>我们需要通过菜单路径<strong>包</strong> | <strong>设置起重机镜像</strong>来设置起重机镜像路径，以便能够访问和加载所需的 R 包</p><div><img src="img/B03980_04_09.jpg" alt="Installing and setting up R"/></div><p>下面的截图<a id="id541" class="indexterm"/>显示了一个镜像站点列表，开发者可以从中选择最合适的一个:</p><div><img src="img/B03980_04_10.jpg" alt="Installing and setting up R"/></div><p>R 编辑器可用于<a id="id543" class="indexterm"/>编写任何高级操作，结果可在<a id="id544" class="indexterm"/>控制台上看到，如下所示:</p><div><img src="img/B03980_04_11.jpg" alt="Installing and setting up R"/></div><p>以下是图形绘图的屏幕截图:</p><div><img src="img/B03980_04_12.jpg" alt="Installing and setting up R"/></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec59"/>将 R 与 Apache Hadoop 集成</h2></div></div></div><p>到目前为止，我们已经看到了<a id="id545" class="indexterm"/> Apache Hadoop 及其核心组件，HDFS 和 YARN (MapReduce 2.0)，以及 R。我们可以通过三种不同的方式来看待 R 与 Hadoop 的集成，从而支持大规模机器学习。</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec52"/>方法 1——在 Hadoop 中使用 R 和流式 API</h3></div></div></div><p>为了将 R <a id="id546" class="indexterm"/>函数与 Hadoop 集成并在 MapReduce 模式下运行，Hadoop 支持 R 的流 API。这些流 API 主要帮助运行任何可以在 MapReduce 模式下访问和操作标准 I/O 的脚本。因此，在 R 的情况下，不会有任何使用 R 的显式客户端集成。以下是 R 和流的示例:</p><div><pre class="programlisting">$ ${HADOOP_HOME}/bin/Hadoop jar
${HADOOP_HOME}/contrib/streaming/*.jar \
-inputformat
org.apache.hadoop.mapred.TextInputFormat \
-input input_data.txt \
-output \
-mapper /home/tst/src/map.R \
-reducer /home/tst/src/reduce.R \
-file /home/tst/src/map.R \
-file /home/tst/src/reduce.R</pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec53"/>方法 2——使用 R</h3></div></div></div><p>在 R 中有一个名为 Rhipe 的包，允许在 R 中运行 MapReduce 作业。有一些先决条件:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">r 需要安装在 Hadoop 集群中的每个 DataNode 上</li><li class="listitem" style="list-style-type: disc">将在每个 DataNode 上安装并提供协议缓冲器(有关协议缓冲器的更多信息<a id="id548" class="indexterm"/>请参考<a class="ulink" href="http://wiki.apache.org/hadoop/ProtocolBuffers">http://wiki.apache.org/hadoop/ProtocolBuffers</a>)</li><li class="listitem" style="list-style-type: disc">Rhipe 应该在每个数据节点上都可用</li></ul></div><p>以下是使用 R 中的<code class="literal">Rhipe</code>库实现 MapReduce 的<a id="id549" class="indexterm"/>示例格式:</p><div><pre class="programlisting">library(Rhipe)
rhinit(TRUE, TRUE);
map&lt;-expression ( {lapply (map.values, function(mapper)…)})
reduce&lt;-expression(
pre = {…},
reduce = {…},
post = {…},
)
x &lt;- rhmr(map=map, reduce=reduce,
 ifolder=inputPath,
 ofolder=outputPath,
 inout=c('text', 'text'),
 jobname='test name'))
rhex(x)</pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec54"/>方法 3——使用 RHadoop</h3></div></div></div><p>RHadoop 与<a id="id550" class="indexterm"/> Rhipe 非常相似，它有助于在 MapReduce 模式下运行 R 函数。这是一个由 Revolution Analytics 构建的开源库。以下是一些软件包，它们是 RHadoop 库的一部分:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong> plyrmr </strong>:这是一个包<a id="id551" class="indexterm"/>，为运行在 Hadoop 上的大型数据集的常见数据操作需求提供函数</li><li class="listitem" style="list-style-type: disc">rmr :这是一个包<a id="id552" class="indexterm"/>，它有一个集成了 R 和 Hadoop 的函数集合</li><li class="listitem" style="list-style-type: disc">rdfs :这是一个包<a id="id553" class="indexterm"/>，有帮助接口 R 和 HDFS 的功能</li><li class="listitem" style="list-style-type: disc"><strong> rhbase </strong>:这是一个<a id="id554" class="indexterm"/>包，有帮助接口 R 和 hbase 的功能</li></ul></div><p>下面是一个使用 rmr 包的例子，演示了使用这个包中的函数集成 R 和 Hadoop 的步骤:</p><div><pre class="programlisting">library(rmr)
maplogic&lt;-function(k,v) { …}
reducelogic&lt;-function(k,vv) { …}
mapreduce( input ="data.txt",
output="output",
textinputformat =rawtextinputformat,
map = maplogic,
reduce=reducelogic
)</pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec55"/>R/Hadoop 集成方法概述</h3></div></div></div><p>总之，<a id="id555" class="indexterm"/>前面的三种方法都产生了结果<a id="id556" class="indexterm"/>并促进了 R 和 Hadoop 的集成。他们帮助 scale R 对大规模数据进行操作，这将有助于 HDFS。这些方法各有利弊。以下是总结的结论:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Hadoop Streaming API 是所有方法中最简单的，因为在安装和设置要求方面没有复杂性</li><li class="listitem" style="list-style-type: disc">Rhipe 和 RHadoop 都需要在 Hadoop 集群上设置 R 和相关的包</li><li class="listitem" style="list-style-type: disc">关于实现方法，Streaming API 更像是一个命令行映射，reduce 函数是函数的输入，而 Rhipe 和 RHadoop 都允许开发人员在 R</li><li class="listitem" style="list-style-type: disc">对于 Hadoop Streaming API，不需要客户端集成，而 Rhipe 和 RHadoop 都需要客户端集成</li><li class="listitem" style="list-style-type: disc">扩展机器学习的替代方案是 Apache Mahout、Apache Hive 以及 Revolution Analytics、Segue framework 等公司的一些商业版 R</li></ul></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec56"/>在 R 中实现(使用示例)</h3></div></div></div><p>在这一节中，我们将简要介绍 R 的一些实现方面，并重点学习语法和理解一些核心函数及其用法。</p><div><div><div><div><h4 class="title"><a id="ch04lvl4sec08"/> R 表情</h4></div></div></div><p>r 可以作为简单的<a id="id557" class="indexterm"/>数学计算器；以下是使用它的一些基本方法。以下是在 R 控制台上看到的内容:</p><div><pre class="programlisting">&gt; 1+1
[1] 2
&gt; "Welcome to R!"
[1] "Welcome to R!"
&gt; 6*7
[1] 42
&gt; 10&lt;22
[1] TRUE
&gt; 2+7==5
[1] FALSE</pre></div><div><div><div><div><h5 class="title"><a id="ch04lvl5sec04"/>作业</h5></div></div></div><p>用于给<a id="id558" class="indexterm"/>变量赋值，并对该变量进行一些操作:</p><p>案例 1:分配数值:</p><div><pre class="programlisting">&gt; x&lt;-24
&gt; x/2
[1] 12</pre></div><p>案例 2:分配字符串文字:</p><div><pre class="programlisting">&gt; x &lt;- "Try R!"
[1] "Try R!"
&gt; x
[1] " Try R!"</pre></div><p>案例 3:分配逻辑值:</p><div><pre class="programlisting">&gt; x &lt;- TRUE
[1] TRUE</pre></div></div><div><div><div><div><h5 class="title"><a id="ch04lvl5sec05"/>职能</h5></div></div></div><p>有许多现成的函数，要调用 R 中的函数，我们应该提供函数名并传递所需的参数。下面是一些函数和结果的例子，如在 R 控制台中看到的:</p><div><pre class="programlisting">&gt; sum(4,3,5,7)
[1] 19
&gt; rep("Fun!", times=3)
[1] " Fun!" "Fun!" "Fun!"
&gt; sqrt(81)
[1] 9</pre></div><p>下面是获取 R 中某个函数的帮助的命令:</p><div><pre class="programlisting">&gt; help(sum)
sum package: base R Documentation

Sum of Vector Elements

Description:

     'sum' returns the sum of all the values present in its arguments.

Usage:

     sum(..., na.rm = FALSE)</pre></div></div></div><div><div><div><div><h4 class="title"><a id="ch04lvl4sec09"/> R 载体</h4></div></div></div><p>根据定义，vector 是一个简单的<a id="id560" class="indexterm"/>值列表，它构成了 R 数据类型的核心。许多机器学习功能利用了这些。</p><p>以下是一些关键功能及其使用环境:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>函数/语法</p>
</th><th style="text-align: left" valign="bottom">
<p>目的</p>
</th><th style="text-align: left" valign="bottom">
<p>例子</p>
</th><th style="text-align: left" valign="bottom">
<p>R 控制台上的输出</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">m:n</code></p>
</td><td style="text-align: left" valign="top">
<p>从<code class="literal">m</code>到<code class="literal">n</code>输出数字，增量为 1</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal"> &gt; 5:9</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">[1] 5 6 7 8 9</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">seq(m,n)</code></p>
</td><td style="text-align: left" valign="top">
<p>从<code class="literal">m</code>到<code class="literal">n</code>的输出数字增加 1</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal"> &gt; seq(5,9)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">[1] 5 6 7 8 9</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">seq(m,n, i)</code></p>
</td><td style="text-align: left" valign="top">
<p>从<code class="literal">m</code>到<code class="literal">n</code>输出数字，增量为<code class="literal">i</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal"> &gt; seq(1,3,0.5)</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">[1] 1 1.5 2 2.5 3</code></p>
</td></tr></tbody></table></div><div><div><div><div><h5 class="title"><a id="ch04lvl5sec06"/>分配、访问和操纵向量</h5></div></div></div><p>下面的<a id="id561" class="indexterm"/>表格包含了在 R 中创建、访问和<a id="id563" class="indexterm"/>操作矩阵的<a id="id562" class="indexterm"/>示例:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>目的</p>
</th><th style="text-align: left" valign="bottom">
<p>例子</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>创建文字向量</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">&gt; sentence &lt;- c('practical', 'machine', 'learning')</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>访问向量的第三值</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">&gt; sentence[3]</code></p>
<p><code class="literal">[1] "learning."</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>更新向量中的值</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">&gt; sentence[1] &lt;- "implementing"</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>向向量添加新值</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">&gt; sentence[4] &lt;- "algorithms"</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>获取给定索引的值</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">&gt; sentence[c(1,3)]</code></p>
<p><code class="literal">[1] "implementing" "learning"</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>获取索引范围的值</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">&gt; sentence[2:4]</code></p>
<p><code class="literal">[1] "machine" "learning" "algorithms"</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>添加一系列新值</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">&gt; sentence[5:7] &lt;- c('for','large','datasets')</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>将<a id="id564" class="indexterm"/>矢量值增加 1</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">&gt; a &lt;- c(1, 2, 3)</code></p>
<p><code class="literal">&gt; a + 1</code></p>
<p><code class="literal">[1] 2 3 4</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>将向量中的每个值除以一个值</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">&gt; a / 2</code></p>
<p><code class="literal">[1] 0.5 1.0 1.5</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>将向量的每个<a id="id565" class="indexterm"/>值乘以一个值</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">&gt; a*2</code></p>
<p><code class="literal">[1] 2 4 6</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>添加两个<a id="id566" class="indexterm"/>向量</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">&gt; b &lt;- c(4, 5, 6)</code></p>
<p><code class="literal">&gt; a + b</code></p>
<p><code class="literal">[1] 5 7 9</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>比较两个向量</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">&gt; a == c(1, 99, 3)</code></p>
<p><code class="literal">[1]  TRUE FALSE  TRUE</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>对向量的每个值应用函数</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">&gt; sqrt(a)</code></p>
<p><code class="literal">[1] 1.000000 1.414214 1.732051</code></p>
</td></tr></tbody></table></div></div></div><div><div><div><div><h4 class="title"><a id="ch04lvl4sec10"/> R 矩阵</h4></div></div></div><p>矩阵是有行和列的二维<a id="id567" class="indexterm"/>向量。下表提供了在 R 中创建、访问和操作矩阵的示例:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>目的</p>
</th><th style="text-align: left" valign="bottom">
<p>例子</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>创建一个默认值为零的 3 X 4 矩阵</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">&gt; matrix(0, 3, 4)</code></p>
<p><code class="literal">     [,1] [,2] [,3] [,4]</code></p>
<p><code class="literal">[1,]    0    0    0    0</code></p>
<p><code class="literal">[2,]    0    0    0    0</code></p>
<p><code class="literal">[3,]    0    0    0    0</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>用一系列值初始化矩阵</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">&gt; a &lt;- 1:12</code></p>
<p><code class="literal">&gt; m &lt;- matrix(a, 3, 4)</code></p>
<p><code class="literal">     [,1] [,2] [,3] [,4]</code></p>
<p><code class="literal">[1,]    1    4    7   10</code></p>
<p><code class="literal">[2,]    2    5    8   11</code></p>
<p><code class="literal">[3,]    3    6    9   12</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>从矩阵中访问值</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">&gt; m[2, 3]</code></p>
<p><code class="literal">[1] 8</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>为矩阵中选择的位置赋值</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">&gt; m[1, 4] &lt;- 0</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>检索选择的整行或一列的数组</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">&gt; m[2,]</code></p>
<p><code class="literal">[1] 2 5 8 11</code></p>
<p><code class="literal">&gt; m[3,]</code></p>
<p><code class="literal">[1] 7 8 9</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>检索更大矩阵的<a id="id568" class="indexterm"/>子集</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">&gt; m[, 2:4]</code></p>
<p><code class="literal">     [,1] [,2] [,3]</code></p>
<p><code class="literal">[1,]    4    7    10</code></p>
<p><code class="literal">[2,]    5    8    11</code></p>
</td></tr></tbody></table></div></div><div><div><div><div><h4 class="title"><a id="ch04lvl4sec11"/> R 因子</h4></div></div></div><p>在数据分析和机器学习中，对数据进行分组或分类是很常见的。例如，好客户或坏客户。r 的<code class="literal">factor</code>数据类型用于跟踪分类数据。所有需要做的就是定义一个类别向量，并将其作为参数传递给<code class="literal">factor</code>函数。</p><p>以下示例演示了使用<code class="literal">factors</code>创建和分配类别:</p><div><pre class="programlisting">&gt; ornaments &lt;- c('ring', 'chain', 'bangle', 'anklet', 'nosepin', 'earring', 'ring', 'anklet')
&gt; ornamenttypes &lt;- factor(ornaments)
&gt; print(ornamenttypes)
[1] ring chain bangle anklet nosepin earring
Levels: anklet bangle chain earring nosepin ring</pre></div><p>每个定义的类别通常都有一个与文字相关联的整数值。将<code class="literal">factor</code>传递给<a id="id570" class="indexterm"/>函数<code class="literal">as.integer</code>将给出整数等效值，如下所示:</p><div><pre class="programlisting">&gt; as.integer(ornamenttypes)
[1] 6 3 2 1 5 4 6 1</pre></div></div><div><div><div><div><h4 class="title"><a id="ch04lvl4sec12"/> R 数据帧</h4></div></div></div><p>数据帧与<a id="id571" class="indexterm"/>数据库表的概念相关。这种数据类型在 R 中非常强大，它有助于将数据集的不同相关属性联系在一起。例如，购买的商品数量与总账单价值和总体适用折扣有关系。应该有一种方法来链接这些属性，而数据框有助于做到这一点:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>目的</p>
</th><th style="text-align: left" valign="bottom">
<p>例子</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>创建数据框并检查值</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">&gt; purchase &lt;- data.frame(totalbill, noitems, discount</code></p>
<p><code class="literal">&gt; print(purchase)</code></p>
<p><code class="literal">  totalbill noitems discount</code></p>
<p><code class="literal">1     300    5      10</code></p>
<p><code class="literal">2     200    3       7.5</code></p>
<p><code class="literal">3     100    1       5</code></p>
<p><code class="literal">)</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>使用索引或标签访问数据帧的数据</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">&gt; purchase[[2]]</code></p>
<p><code class="literal">[1]  5 3 1</code></p>
<p><code class="literal">&gt; purchase[["totalbill"]]</code></p>
<p><code class="literal">[1] 300 200 100</code></p>
<p><code class="literal">&gt; purchase$discount</code></p>
<p><code class="literal">[1]  10 7.5 5</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>用 CSV 文件中的数据加载数据<a id="id572" class="indexterm"/>帧</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">&gt; list.files()</code></p>
<p><code class="literal">[1] "monthlypurchases.csv"</code></p>
<p><code class="literal">&gt; read.csv("monthlypurchases.csv")</code></p>
<p><code class="literal">         Amount    Items Discount</code></p>
<p><code class="literal">1 2500             35    15</code></p>
<p><code class="literal">2 5464             42    25</code></p>
<p><code class="literal">3 1245             8     6</code></p>
</td></tr></tbody></table></div></div><div><div><div><div><h4 class="title"><a id="ch04lvl4sec13"/> R 统计框架</h4></div></div></div><p>r 支持一系列现成的统计函数，帮助统计人员解释数据。下表显示了一些带有示例的函数:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>功能</p>
</th><th style="text-align: left" valign="bottom">
<p>例子</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>平均</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">limbs &lt;- c(4, 3, 4, 3, 2, 4, 4, 4)</code></p>
<p><code class="literal">names(limbs) &lt;- c('One-Eye', 'Peg-Leg', 'Smitty', 'Hook', 'Scooter', 'Dan', 'Mikey', 'Blackbeard')</code></p>
<p><code class="literal">&gt; mean(limbs)</code></p>
<p><code class="literal">[1] 3.5</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>中位数</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">&gt; median(limbs)</code></p>
<p><code class="literal">[1] 4</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>标准偏差</p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">&gt; pounds &lt;- c(45000, 50000, 35000, 40000, 35000, 45000, 10000, 15000)</code></p>
<p><code class="literal">&gt; deviation &lt;- sd(pounds)</code></p>
</td></tr></tbody></table></div><p>包含的每段 R 代码都保存在扩展名为<code class="literal">.R</code>的文件中用于运行。</p><p>在这一节中，我们已经看到了如何设置 R 以及如何使用一些基本的函数和数据类型。我们将在接下来的章节中探索许多机器学习的特定包。</p><div><div><h3 class="title"><a id="note05"/>注意</h3><p>有关使用 R 进行机器学习的详细理解，请参考 Packt 针对 R 的出版物，标题为<em>使用 R 进行机器学习</em>。</p></div></div></div></div></div></div>





<title>Julia</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title">朱莉娅</h1></div></div></div><p>最近，Julia 作为 Python 的高性能替代品，在机器学习和数据科学领域获得了广泛的欢迎和采用。Julia 是一种动态编程语言，旨在支持分布式和并行计算，因此方便快捷。</p><p>Julia 中的性能是 JIT 编译器和类型接口特性的结果。此外，与其他数字编程语言不同，Julia 不强制执行值的矢量化。与 R、MATLAB 和 Python 类似，Julia 为高级数值计算提供了便利和表现力。</p><p>以下是朱莉娅的一些主要特征:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">核心的 API 和数学原语操作都是用 Julia 写的</li><li class="listitem" style="list-style-type: disc">它由丰富类型组成，用于构造和描述对象</li><li class="listitem" style="list-style-type: disc">Julia 支持多重分派，这使得可以在多种参数组合中使用函数</li><li class="listitem" style="list-style-type: disc">它有助于为不同的参数类型自动生成专门的代码</li><li class="listitem" style="list-style-type: disc">成熟的性能与 C 等静态编译语言不相上下</li><li class="listitem" style="list-style-type: disc">它是一种免费的开源编程语言(麻省理工学院许可)</li><li class="listitem" style="list-style-type: disc">用户定义的类型和内置类型一样快速紧凑</li><li class="listitem" style="list-style-type: disc">它不强制或要求矢量化代码来提高性能</li><li class="listitem" style="list-style-type: disc">它是为分布式并行计算而设计的</li><li class="listitem" style="list-style-type: disc">Julia 附带了协同例程和轻量级线程</li><li class="listitem" style="list-style-type: disc">Julia 支持直接调用 C 函数的能力</li><li class="listitem" style="list-style-type: disc">用于管理流程的类似外壳的功能</li><li class="listitem" style="list-style-type: disc">它提供了类似 Lisp 的宏</li></ul></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec60"/>安装和设置朱莉娅</h2></div></div></div><p>我们将使用茱莉亚的最新版本<a id="id578" class="indexterm"/>,这是在写这本书的时候可用的——v 0 . 3 . 4。</p><p>Julia 程序可以通过以下方式构建和执行:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">使用 Julia 命令行</li><li class="listitem" style="list-style-type: disc">使用 Juno——Julia 的 IDE</li><li class="listitem" style="list-style-type: disc">在<a class="ulink" href="https://juliabox.org/">https://juliabox.org/</a>使用<a id="id579" class="indexterm"/>现成可用的环境，在那里可以使用浏览器访问 Julia 环境</li></ul></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec57"/>下载和使用 Julia 的命令行版本</h3></div></div></div><p>使用链接<a class="ulink" href="http://julialang.org/downloads/">http://julialang.org/downloads/</a>下载<a id="id580" class="indexterm"/>所需的<a id="id581" class="indexterm"/>茱莉亚版本。</p><div><ol class="orderedlist arabic"><li class="listitem">下载<a id="id583" class="indexterm"/>适当的可执行文件并运行。<div> <img src="img/B03980_04_13.jpg" alt="Downloading and using the command line version of Julia"/> </div></li><li class="listitem">安装成功后，打开 Julia 控制台，Julia 就可以使用了。<div> <img src="img/B03980_04_14.jpg" alt="Downloading and using the command line version of Julia"/> </div></li></ol></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec58"/>使用 Juno IDE 运行 Julia</h3></div></div></div><p>Juno IDE <a id="id584" class="indexterm"/>让开发 Julia 代码变得简单。从 http://junolab.org/docs/install.html<a class="ulink" href="http://junolab.org/docs/install.html">下载最新的 Juno IDE </a><a id="id585" class="indexterm"/>版本。</p><p>Juno 拥有 Julia 的核心 API 和功能，有助于简化开发过程。下面是如何使用 Juno 的屏幕截图:</p><div><img src="img/B03980_04_15.jpg" alt="Using Juno IDE for running Julia"/></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec59"/>通过浏览器使用 Julia</h3></div></div></div><p>使用这个选项不需要安装任何 Julia。按照以下步骤在线访问<a id="id587" class="indexterm"/> Julia 环境:</p><div><ol class="orderedlist arabic"><li class="listitem">从浏览器<div> <img src="img/B03980_04_16.jpg" alt="Using Julia via the browser"/> </div>访问<a class="ulink" href="https://juliabox.org/">https://juliabox.org/</a></li><li class="listitem">使用 Google 帐户登录。这将为登录用户创建一个唯一的 Julia 实例。这将提供对 Julia 控制台和 IJulia 实例的访问。</li></ol></div><p>使用我们之前看到的三种<a id="id588" class="indexterm"/>方法中的一种，我们可以访问<a id="id589" class="indexterm"/> Julia 控制台，从那里可以执行 Julia 代码。包含的每段 Julia 代码都构建在一个扩展名为<code class="literal">.jl</code>的文件中。</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec61"/>从命令行运行 Julia 代码</h2></div></div></div><p>Julia 在<a id="id590" class="indexterm"/>运行时编译代码，并使用<strong>实时</strong> ( <strong> JIT </strong> ) <a id="id592" class="indexterm"/>编译器将每个方法翻译成<a id="id591" class="indexterm"/>机器码。在内部，它利用<a id="id593" class="indexterm"/> <strong>低级虚拟机</strong> ( <strong> LLVM </strong>)进行优化和代码生成。LLVM 是一个成熟的项目，是标准编译器技术的集合。这是作为 iOS 的一部分使用的。</p><p>从选择的 shell 中，运行以下命令:</p><div><pre class="programlisting">&lt;&lt;/path/to/Julia&gt;&gt;/myjuliascript.jl</pre></div><p>或者，从 Julia 命令行安装中打开 Julia 控制台，并运行以下命令:</p><div><pre class="programlisting">julia&gt; include("&lt;&lt;path/to/juliascript&gt;&gt;/myjuliascript.jl")</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec62"/>在 Julia 中实现(带示例)</h2></div></div></div><p>在这一节中，我们将讨论编码 Julia 和理解语法中的一些基本主题。在本节结束时，读者应该能够轻松地编写 Julia 脚本并运行。关于语法，Julia 编程语言与 MATLAB 非常相似。</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec63"/>使用变量和赋值</h2></div></div></div><p>Julia 中的变量，像任何其他的<a id="id594" class="indexterm"/>编程语言一样，用于存储和操作<a id="id595" class="indexterm"/>数据。以下是定义、分配和操作变量和值的示例:</p><div><pre class="programlisting"># Assign a numeric value to a variable
julia&gt; x = 10
10

# Perform a simple mathematical manipulation of variables
julia&gt; x + 1
11

# Assigning or reassigning values to variables.
julia&gt; x = 1 + 1
2

# Assigning a string literal to a variable
julia&gt; x = "Hello World!"
"Hello, World!"</pre></div><p>作为一种数学编程语言，Julia 提供了几个基本常数。下面是一个可以直接在代码中使用的示例。此外，我们可以定义常量并重新赋值:</p><div><pre class="programlisting">julia&gt; pi
π = 3.1415926535897...</pre></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec60"/>数字原语</h3></div></div></div><p>对于任何支持基于数字的计算的数学编程语言来说，整数和浮点值构成了基本的构建模块，被称为数字原语。</p><p>Julia 提供了对大量数字原语的支持，这些原语是广泛的、非常完善的数学函数。</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec61"/>数据结构</h3></div></div></div><p>除了所有的原始数据类型，如向量、矩阵、元组、字典、集合等等，Julia 还支持几种数据结构。以下是一些表示用法的示例:</p><div><pre class="programlisting"># Vector
b = [4, 5, 6]
b[1] # =&gt; 4
b[end] # =&gt; 6

# Matrix
matrix = [1 2; 3 4]

# Tuple
tup = (1, 2, 3)
tup[1] # =&gt; 1
tup[1] = 3 # =&gt; ERROR #since tuples are immutable, assigning a value results in an error

# Dictionary
dict = ["one"=&gt; 1, "two"=&gt; 2, "three"=&gt; 3]
dict["one"] # =&gt; 1

# Set
filled_set = Set(1,2,2,3,4)</pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec62"/>使用字符串和字符串操作</h3></div></div></div><p>下面是一些在 Julia 中用字符串操作<a id="id599" class="indexterm"/>的例子<a id="id598" class="indexterm"/>:</p><div><pre class="programlisting">split("I love learning Julia ! ")
# =&gt; 5-element Array{SubString{ASCIIString},1}:
"I"
"love."
"learning."
"Julia"
"!"

join(["It seems to be interesting", "to see",
"how it works"], ", ")
# =&gt; "It seems interesting, to see, how it works."</pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec63"/>套餐</h3></div></div></div><p>Julia 附带了几个包<a id="id600" class="indexterm"/>，这些包具有内置的功能，并且支持许多开箱即用的功能来实现机器学习算法。以下是列表:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Images.jl</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Graphs.jl</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">DataFrames.jl</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">DimensionalityReduction.jl</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Distributions.jl</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">NLOpt.jl</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ArgParse.jl</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Logging.jl</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">FactCheck.jl</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">METADATA.jl</code></li></ul></div><p>更多关于茱莉亚包的细节<a id="id601" class="indexterm"/>可以在<a class="ulink" href="https://github.com/JuliaLang/">https://github.com/JuliaLang/</a>获得。</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec64"/>互操作性</h3></div></div></div><p>下一节将介绍 Julia 与其他各种编程语言的集成。</p><div><div><div><div><h4 class="title"><a id="ch04lvl4sec14"/>与 C 集成</h4></div></div></div><p>Julia 是灵活的，没有任何包装器，支持直接调用 C 函数。下面的示例演示了这是如何实现的:</p><div><pre class="programlisting">julia&gt; ccall(:clock, Int32, ())
2292761
julia&gt; ccall(:getenv, Ptr{Uint8int8}, (Ptr{Uint8},), "SHELL")
Ptr{Uint8} @0x00007fff5fbffc45
julia&gt; bytestring(ans)
"/bin/bash"</pre></div></div><div><div><div><div><h4 class="title"><a id="ch04lvl4sec15"/>与 Python 集成</h4></div></div></div><p>类似于 C <a id="id604" class="indexterm"/>函数调用，Julia 支持直接调用 Python 函数。重要的是我们已经安装了<code class="literal">PyCall</code>包来实现这个功能。<code class="literal">PyCall.jl</code>提供 Julia 和 Python 之间的自动类型转换。例如，Julia 数组被转换为 NumPy 数组。</p><p>以下示例演示了如何从 Julia 代码中调用 Python 函数:</p><div><pre class="programlisting">julia&gt; using PyCall # Installed with Pkg.add("PyCall")
julia&gt; @pyimport math
julia&gt; math.sin(math.pi / 4) - sin(pi / 4)
0.0
julia&gt; @pyimport pylab
julia&gt; x = linspace(0,2*pi,1000); y = sin(3*x + 4*cos(2*x));
julia&gt; pylab.plot(x, y; color="red", linewidth=2.0, linestyle="--")
julia&gt; pylab.show()</pre></div></div><div><div><div><div><h4 class="title"><a id="ch04lvl4sec16"/>与 MATLAB 集成</h4></div></div></div><p>以下示例<a id="id605" class="indexterm"/>演示了集成 Julia 以调用 MATLAB 函数:</p><div><pre class="programlisting">using MATLAB

function sampleFunction(bmap::BitMatrix)
@mput bmap
@matlab bmapthin = bwmorph(bmap, "thin", inf)
convert(BitArray, @mget bmapthin)
end</pre></div></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec65"/>图形和标图</h3></div></div></div><p>朱莉娅有几个帮助制作图表的软件包。这里列出了其中的一些<a id="id607" class="indexterm"/>:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Gadfly.jl</code>:这非常类似于 ggplot2</li><li class="listitem" style="list-style-type: disc"><code class="literal">Winston.jl</code>:这非常类似于 Matplotlib</li><li class="listitem" style="list-style-type: disc"><code class="literal">Gaston.jl</code>:这与 gnuplot 接口</li></ul></div><p>这里的例子演示了如何使用<code class="literal">PyPlot</code>:</p><div><pre class="programlisting">using PyPlot
x = linspace(-2pi, 2pi)
y = sin(x)
plot(x, y, "--b")</pre></div><div><img src="img/B03980_04_17.jpg" alt="Graphics and plotting"/></div></div></div><div><div><div><div><h2 class="title">收养朱莉娅的好处</h2></div></div></div><p>以下是在机器学习实现中采用 Julia 的一些直接好处:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Julia 在不影响性能的情况下促进了快速原型开发</li><li class="listitem" style="list-style-type: disc">它本质上支持代码的并行化</li><li class="listitem" style="list-style-type: disc">它提供了一种更简单的方法来表达具有特殊 Julia 类型的算法</li><li class="listitem" style="list-style-type: disc">Julia 可以轻松调用或集成 C、Python、MATLAB 和 C++</li><li class="listitem" style="list-style-type: disc">热情、友好和支持的社区为 Julia 提供了便利</li><li class="listitem" style="list-style-type: disc">它与 Hadoop 一起工作，并利用基于配置单元的查询</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec65"/>集成 Julia 和 Hadoop</h2></div></div></div><p>将任何<a id="id610" class="indexterm"/>编程语言与 Hadoop 集成通常意味着存储在 Hadoop 中的数据应该是可访问的，并且程序应该能够对数据执行特定的逻辑。这可以通过从 Hadoop 中检索数据并使其更接近程序来实现，也可以通过将程序移动到数据并在 MapReduce 或并行处理模式下执行来实现。显然，在第一种情况下，从 Hadoop 中获取数据并提交给执行逻辑的代码，需要足够的 RAM 来保存和处理内存中的数据，这可能会限制在真正大的卷上运行的能力。在第二种情况下，将代码用于跨数据节点分布的数据，逻辑应该是可并行化的，并且应该构建 Map 和 Reduce 逻辑。</p><p>Julia 与 Hadoop 平台的集成还处于初级阶段，目前详细介绍的方法是之前描述的第一种方法，其中使用标准 ODBC 连接从 Julia 代码建立到 Hadoop/HDFS 的连接。数据被提取到 RAM 中供进一步处理。现在，这段代码可以直接在 DataNode 上运行，并可以更新 HDFS 数据。</p><p>我们将使用通过以下链接从 GitHub 获得的<a id="id611" class="indexterm"/>:</p><p><a class="ulink" href="https://github.com/quinnj/ODBC.jl">https://github.com/quinnj/ODBC.jl</a></p><p>这是 Julia 的一个简单的底层 ODBC 接口。它可以通过 Julia 包管理器使用以下命令进行安装:</p><p>以下命令创建一个 Julia 包存储库(对所有包只运行一次)</p><div><pre class="programlisting">
<strong>julia&gt; Pkg.init()</strong>
</pre></div><p>以下命令创建<code class="literal">ODBC repo</code>文件夹并下载<code class="literal">ODBC</code>包和依赖项(如果需要)</p><div><pre class="programlisting">
<strong>julia&gt; Pkg.add("ODBC")</strong>
</pre></div><p>下面的命令加载了要使用的<a id="id612" class="indexterm"/> ODBC 模块(需要与每个新的 Julia 实例一起运行)</p><div><pre class="programlisting">
<strong>julia&gt; using ODBC</strong>
</pre></div><p>以下是一些可用于 Hadoop/HDFS 的重要函数:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">要使用 ODBC 数据源进行连接，用户和密码使用— <code class="literal">co = ODBC.connect("mydatasource",usr="johndoe",pwd="12345")</code>。</li><li class="listitem" style="list-style-type: disc">使用<code class="literal">disconnect(connection::Connection=conn)</code>断开连接。</li><li class="listitem" style="list-style-type: disc">使用连接字符串连接时，使用<code class="literal">advancedconnect(conn_string::String)</code>。</li><li class="listitem" style="list-style-type: disc">为了进行查询并获取数据源上的数据子集，这个查询字符串是一个将在 HDFS 上运行的 Hive 查询— <code class="literal">query(connecti on Connection=conn, querystring; fi le=: DataFrame,delim='\t')</code>。</li></ul></div><p>这里给出了一个示例实现:</p><p>使用以下命令加载 ODBC 模块:</p><div><pre class="programlisting">
<strong>using ODBC</strong>
</pre></div><p>要通过配置单元连接到 Hadoop 集群，请使用以下命令:</p><div><pre class="programlisting">
<strong>hiveconn = ODBC.connect("servername"; usr="your-user-name", pwd="your-password-here")</strong>
</pre></div><p>要编写配置单元查询并将其存储为 Julia 字符串，请使用以下命令:</p><div><pre class="programlisting">
<strong>hive_query_string = "select …;"</strong>
</pre></div><p>要运行查询，请使用以下命令将结果直接保存到文件:</p><div><pre class="programlisting">
<strong>query(hive_query_string, hiveconn;output="C:\\sample.csv",delim=',')</strong>
</pre></div><p>Julia 程序现在可以访问这个文件中的数据来执行机器学习算法。</p></div></div>





<title>Python</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title"><a id="ch04lvl1sec27"/> Python</h1></div></div></div><p>Python 是机器学习和数据科学领域中被广泛采用的编程或脚本语言之一。Python 总是以其易于学习、实现和维护而闻名。Python 具有高度的可移植性，可以在基于 Unix、Windows 和 Mac 平台上运行。随着 Pydoop 和 SciPy 等库的出现，它在大数据分析领域的相关性大大增加了。 Some 把 Python 在解决机器学习问题上受欢迎的关键原因列举如下:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">众所周知，Python 非常适合数据分析</li><li class="listitem" style="list-style-type: disc">它是一种多功能的脚本语言，可用于编写一些基本的快速而复杂的脚本来测试一些基本的功能，也可用于利用其全功能工具包的实时应用程序</li><li class="listitem" style="list-style-type: disc">Python 自带完整的机器学习包(参考【http://mloss.org/software/】T2)，可以即插即用</li></ul></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec66"/>Python 中的工具包选项</h2></div></div></div><p>在我们深入了解 Python 中有哪些工具箱选项之前，让我们先了解一下在选择工具箱选项之前应该考虑的权衡。</p><p>对于合适的工具包，我们应该评估的一些问题如下:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">我的绩效优先级是什么？我需要离线或实时处理实现吗？</li><li class="listitem" style="list-style-type: disc">工具包有多透明？我可以自己定制库吗？</li><li class="listitem" style="list-style-type: disc">社区地位如何？bug 修复的速度有多快，社区支持和专家交流的可用性如何？</li></ul></div><p>Python 中有三个选项:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">使用 Python 外部绑定。这些是市场上流行的软件包的接口，比如 Matlab、R、Octave 等等。如果我们在前面提到的框架中已经有了一些实现，并且正在考虑无缝迁移到 Python 中，那么这个选项将会很好地工作。</li><li class="listitem" style="list-style-type: disc">使用基于 Python 的工具包。有一些用 Python 编写的工具包附带了一堆算法。下一节将介绍一些 Python 工具包。</li><li class="listitem" style="list-style-type: disc">写你的逻辑/工具包。</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec67"/>Python 的实现(使用示例)</h2></div></div></div><p>Python 有两个核心工具包，其中<a id="id616" class="indexterm"/>更多的是构建模块，这里列出的几乎所有专业工具包都使用这些核心工具包。这些措施如下:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">NumPy  : NumPy <a id="id617" class="indexterm"/>是关于用 Python 构建的快速高效的数组</li><li class="listitem" style="list-style-type: disc">这是 NumPy 内置的一系列标准运算的算法</li></ul></div><p>有很多基于 C/C++的实现，比如 LIBLINEAR、LIBSVM、OpenCV 等等</p><p>现在让我们看看一些流行的 Python 工具包，以及在撰写本书的一年时间内更新的工具包:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong> NLTK </strong>:这代表<a id="id619" class="indexterm"/>自然语言工具包。这里重点介绍一下<a id="id620" class="indexterm"/> <strong>自然语言处理</strong> ( <strong> NLP </strong>)。</li><li class="listitem" style="list-style-type: disc"><strong> mlpy </strong>:这是机器学习<a id="id621" class="indexterm"/>算法工具包，支持一些关键的机器学习算法，如分类、回归和聚类等。</li><li class="listitem" style="list-style-type: disc"><strong> PyML </strong>:这个<a id="id622" class="indexterm"/>工具包重点是<a id="id623" class="indexterm"/> <strong>支持向量机</strong> ( <strong> SVM </strong>)。我们将在接下来的章节中详细介绍这一点。</li><li class="listitem" style="list-style-type: disc"><strong> PyBrain </strong>:这个工具包<a id="id624" class="indexterm"/>专注于神经网络和相关功能。</li><li class="listitem" style="list-style-type: disc"><strong> mdp-toolkit </strong>:这个工具包的重点是数据处理，它支持调度和并行处理。</li><li class="listitem" style="list-style-type: disc"><strong> scikit-learn </strong>:这是<a id="id626" class="indexterm"/>最流行的工具包之一，最近被数据科学家广泛采用。它支持有监督的和无监督的学习，对特征选择和可视化有一些特殊的支持。有一个大型团队正在积极地构建这个工具包，并以其出色的文档而闻名。</li><li class="listitem" style="list-style-type: disc"><strong> Pydoop </strong>:这个<a id="id627" class="indexterm"/>是 Python 与 Hadoop 平台的集成。</li></ul></div><p><strong> Pydoop </strong>和<strong> SciPy </strong>和<a id="id628" class="indexterm"/>在大数据分析领域有大量部署。</p><p>在本章中，我们将探索 scikit-learn 工具包，并在接下来的章节中使用该工具包演示我们的所有示例。</p><p>对于 Python 程序员来说，使用 scikit-learn 可以非常容易地将机器学习引入生产系统。</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec66"/>安装 Python 并设置 scikit-learn</h3></div></div></div><p>以下是安装 Python 和 scikit-learn 的核心<a id="id629" class="indexterm"/> Python <a id="id630" class="indexterm"/>工具包版本和依赖关系:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Python (&gt;= 2.6 或&gt; = 3.3)</li><li class="listitem" style="list-style-type: disc">NumPy (&gt;= 1.6.1)</li><li class="listitem" style="list-style-type: disc">SciPy (&gt;= 0.9)。</li><li class="listitem" style="list-style-type: disc">一个有效的 C++编译器</li></ul></div><p>我们将使用轮子包(<code class="literal">.whl</code>文件)用于 scikit——从 PyPI 学习，并使用 pip 实用程序安装它。</p><p>要在您的主目录中安装，请使用以下命令:</p><div><pre class="programlisting">
<strong>python setup.py install --home</strong>
</pre></div><p>要直接从 GitHub 使用 git <a id="id631" class="indexterm"/> repo <a id="id632" class="indexterm"/>在本地磁盘上安装 scikit-learn，请使用以下命令:</p><div><pre class="programlisting">
<strong>% git clone git://github.com/scikit-learn/scikit-learn/</strong>
<strong>% cd scikit-learn</strong>
</pre></div><div><div><div><div><h4 class="title"><a id="ch04lvl4sec17"/>加载数据</h4></div></div></div><p>Scikit-learn 附带了一些标准数据集，例如，<code class="literal">iris</code>和<code class="literal">digits</code>数据集可用于构建和运行机器学习算法。</p><p>以下是加载 scikit-learn 附带的标准数据集的一些步骤:</p><div><pre class="programlisting">&gt;&gt;&gt; from sklearn import datasets
&gt;&gt;&gt; iris = datasets.load_iris()
&gt;&gt;&gt; digits = datasets.load_digits()
&gt;&gt;&gt; print digits.data
[[ 0. 0. 5. ..., 0. 0. 0.]
[ 0. 0. 0. ..., 10. 0. 0.]
[ 0. 0. 0. ..., 16. 9. 0.]
...,
[ 0. 0. 1. ..., 6. 0. 0.]
[ 0. 0. 2. ..., 12. 0. 0.]
[ 0. 0. 10. ..., 12. 1. 0.]]
&gt;&gt;&gt; digits.target
array([0, 1, 2, ..., 8, 9, 8])</pre></div></div></div></div></div>





<title>Apache Spark</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title"><a id="ch04lvl1sec28"/>阿帕奇火花</h1></div></div></div><p>Apache Spark <a id="id633" class="indexterm"/>是一个用于快速、大数据或大规模处理的开源框架，支持流、SQL、机器学习和图形处理。这个框架是用 Scala 实现的，支持 Java、Scala、Python 等编程语言。性能是传统 Hadoop 堆栈的 10 到 20 倍。Spark 是一个通用框架，它允许交互式编程以及对流的支持。Spark 可以在独立模式下与支持 Hadoop 格式(如 SequenceFiles 或 InputFormats)的 Hadoop 一起工作。它包括本地文件系统、Hive、HBase、Cassandra 和亚马逊 S3 等。</p><p>我们将在本书的所有例子中使用 Spark 1.2.0。</p><p>下图描述了 Apache Spark 的<a id="id634" class="indexterm"/>核心模块:</p><div><img src="img/B03980_04_24.jpg" alt="Apache Spark"/></div><p>Spark 框架的一些基本功能包括任务调度、与存储系统的交互、容错和内存管理。Spark 遵循一种被称为<a id="id635" class="indexterm"/> <strong>的编程范式，即弹性分布式数据集</strong> ( <strong> RDD </strong>)。这主要与管理分布式数据存储和并行计算有关。</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong> Spark SQL </strong>是 Spark 的<a id="id636" class="indexterm"/>包，用于查询和处理结构化和非结构化数据。这个包的核心功能是:<div> <ul class="itemizedlist"> <li class="listitem" style="list-style-type: disc">以便于从各种结构化源(如 Hive、JSON 等)加载数据</li> <li class="listitem" style="list-style-type: disc">以便提供 SQL 和常规 Python 或 Java 或 Scala 代码之间的集成，并提供构建自定义函数的能力，这些函数可以在分布式数据上并行执行</li> <li class="listitem" style="list-style-type: disc">以支持通过标准数据库<a id="id637" class="indexterm"/>连接(JDBC/ODBC)从外部工具进行基于 SQL 的查询，包括<strong> Tableau </strong> </li> </ul> </div></li><li class="listitem" style="list-style-type: disc"><strong> Spark Streaming </strong> <a id="id638" class="indexterm"/>模块用于处理实时、大规模的数据流。这个 API 不同于 Hadoop 的流 I/O API。</li><li class="listitem" style="list-style-type: disc"><strong> MLib </strong>模块<a id="id639" class="indexterm"/>提供开箱即用的机器学习算法功能，可扩展并可在集群上运行。</li><li class="listitem" style="list-style-type: disc"><strong> GraphX </strong>模块<a id="id640" class="indexterm"/>提供图形操作功能。</li></ul></div><p>在本章中，我们将学习如何结合 Scala 编程语言使用 Spark。现在让我们快速了解一下 Scala，并学习如何用 Scala 编码。</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec68"/> Scala</h2></div></div></div><p>Scala <a id="id641" class="indexterm"/>是一种强类型编程语言，需要<a id="id642" class="indexterm"/> <strong> JVM </strong> ( <strong> Java 虚拟机</strong>)才能运行。它是一个独立的平台，可以利用 Java APIs。我们将使用解释提示来运行 Scala 和 Spark。这里的命令提示符显示了如何使用解释提示符运行 Scala 和 Spark。</p><div><img src="img/B03980_04_18.jpg" alt="Scala"/></div><p>让我们来看一些<a id="id643" class="indexterm"/> Scala 的例子。</p><p>以下代码可以直接粘贴到命令提示符中:</p><div><pre class="programlisting">//Default variables are assigned to any expressions
scala&gt;8 * 5 + 2
Res0: Int = 42
Scala&gt;0.5 * res0
Res1= Double = 21.0
//All simple data types are objects
scala&gt;"Hello, " + res0
Res2: java.lang.String = Hello, 42
scala&gt;10.toString()
Res2: String = 10
scala&gt;a.+(b)
Res1: Int = 200            //So you can consider , the operator as a method
A method b as a shorthand for a.method(b)
scala&gt;val myVal: String = "Foo"
keyword "val" this means that a variable cannot change value  (immutable variable)
scala&gt;var myVar:String = "Foo"
the keyword var means that it is a variable that can be changed (mutable variable)
scala&gt; def cube(a: Int): Int = a * a * a
cube: (a: Int)Int
scala&gt; myNumbers.map(x =&gt; cube(x))
res8: List[Int] = List(1, 8, 27, 64, 125, 64, 27)
scala&gt; myNumbers.map(x =&gt; x * x * x)
res9: List[Int] = List(1, 8, 27, 64, 125, 64, 27)
scala&gt; val myNumbers = List(1,2,3,4,5,4,3)
myNumbers: List[Int] = List(1, 2, 3, 4, 5, 4, 3)
scala&gt; def factorial(n:Int):Int = if (n==0) 1 else n * factorial(n-1)
factorial: (n: Int)Int
scala&gt; myNumbers.map(factorial)
res18: List[Int] = List(1, 2, 6, 24, 120, 24, 6)
scala&gt; myNumbers.map(factorial).sum
res19: Int = 183
scala&gt; var factor = 3
factor: Int = 3
scala&gt; val multiplier = (i:Int) =&gt; i * factor
multiplier: Int =&gt; Int = &lt;function1&gt;
scala&gt; val l1 = List(1,2,3,4,5) map multiplier
l1: List[Int] = List(3, 6, 9, 12, 15)
scala&gt; factor = 5
factor: Int = 5</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec69"/>使用弹性分布式数据集编程(RDD)</h2></div></div></div><p>rdd 是 Spark 处理数据的核心抽象。它们是不可变的分布式元素集合。Spark 中的所有功能都只能在 rdd 上运行。</p><p>Spark 自动将 rdd 中包含的数据作为分区分布在集群中的节点上，并支持在这些节点上执行并行处理。rdd 可以通过从外部数据集导入或在驱动程序中分发集合来创建。以下命令演示了此功能:</p><div><pre class="programlisting">scala&gt; val c = file.filter(line =&gt; line.contains("and"))</pre></div><p><code class="literal">collect()</code>方法将把输出写到控制台:</p><div><pre class="programlisting">scala&gt;c.collect()</pre></div><p>结果的输出通常保存到外部存储系统。<code class="literal">count()</code>函数给出输出行数。下面将打印出这些行:</p><div><pre class="programlisting">scala&gt;println("input had " + c.count() + " lines")</pre></div><p><code class="literal">take()</code>函数将从结果中获取<em> n </em>条记录:</p><div><pre class="programlisting">scala&gt;c.take(10).foreach(println)</pre></div><p>Spark 以懒惰的方式处理 RDDs，以提高处理大型数据集的效率。</p><p>要在多个动作中重用 RDD，可以使用<code class="literal">RDD.persist()</code>让 Spark 持久化它。</p><p>我们可以要求 Spark 将我们的数据保存在不同的地方。在第一次计算之后，Spark 会将 RDD 内容存储在内存中(跨集群中的机器进行分区),并在将来的操作中重用它们。</p><p>因此，以下是处理 rdd 的基本步骤:</p><div><ol class="orderedlist arabic"><li class="listitem">从外部数据创建输入 rdd。</li><li class="listitem">使用转换来转换它们以定义新的 rdd，例如<code class="literal">filter()</code>。</li><li class="listitem">使用<code class="literal">persist()</code>存储中间 rdd 以备再次使用。</li><li class="listitem">调用任何需要的函数(如<code class="literal">count()</code>)启动并行计算过程。</li></ol></div><p>下面是一个<a id="id645" class="indexterm"/>RDD 在 Scala 中使用 Pi 估算的例子:</p><div><pre class="programlisting">scala&gt;var NUM_SAMPLES=5
scala&gt; val count = sc.parallelize(1 to NUM_SAMPLES).map{i =&gt;
     | val x = Math.random()
     | val y = Math.random()
     |  if (x*x + y*y &lt; 1) 1 else 0
     | }.reduce(_ + _)
scala&gt;println("Pi is roughly " + 4.0 * count / NUM_SAMPLES)</pre></div></div></div>





<title>Spring XD</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title"><a id="ch04lvl1sec29"/>春 XD</h1></div></div></div><p>虽然这本书不包括演示机器学习算法的<a id="id646" class="indexterm"/> Spring XD 框架，但这里给出了一个小的介绍，因为这是在机器学习世界中迅速出现的。</p><p>XD 代表极端数据。这个开源框架由 Pivotal 团队(前身为 SpringSource)构建，作为开发和部署大数据应用的一站式商店。</p><p>Spring XD 是一个分布式、可扩展的框架，它统一了实时、批量的数据接收和分析功能，并支持数据导出。Spring XD 建立在 Spring Integration 和 Spring Batch 框架之上。</p><p>以下是一些<a id="id647" class="indexterm"/>关键特性:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Spring XD 是批处理和流工作负载的统一平台。它是一个开放的、可扩展的运行时。</li><li class="listitem" style="list-style-type: disc">它是一个可扩展的高性能分布式数据接收框架，可以从包括 HDFS、NOSQL 或 Splunk 在内的各种来源接收数据。</li><li class="listitem" style="list-style-type: disc">它支持在摄取时进行实时分析，例如收集指标和计算值。</li><li class="listitem" style="list-style-type: disc">它通过批处理作业进行工作流管理，包括与标准 RDBMS 和 Hadoop 系统的交互。</li><li class="listitem" style="list-style-type: disc">这是一种<a id="id648" class="indexterm"/>可扩展的高性能数据导出，例如，从 HDFS 到 RDBMS 或 NoSQL 数据库。</li></ul></div><p>众所周知，Spring XD 实现了 Lambda 架构，该架构在理论上被定义为支持批处理和实时处理。关于 Lambda 架构等进化架构的更多信息，请参见<a class="link" href="ch14.html" title="Chapter 14. New generation data architectures for Machine learning">第 14 章</a>、<em>机器学习的新一代数据架构</em>。</p><p>Spring XD 架构主要<a id="id649" class="indexterm"/>有三个架构层来帮助促进前面的特性:</p><div><ol class="orderedlist arabic"><li class="listitem"><strong>速度层</strong>:这是关于实时访问和处理数据的<a id="id650" class="indexterm"/>。这一过程使系统保持最新。<div> <img src="img/B03980_04_19.jpg" alt="Spring XD"/> </div></li><li class="listitem"><strong>批处理层</strong>:批处理层<a id="id651" class="indexterm"/>可以访问完整的主数据集，也称为数据湖，意思是<em>真实的来源</em>。<div> <img src="img/B03980_04_20.jpg" alt="Spring XD"/> </div></li><li class="listitem"><strong>服务层</strong>:服务<a id="id652" class="indexterm"/>层更像是一个查询层，负责向未订阅的消费者公开数据后处理。这一层使得批量数据可查询，并且通常以高吞吐量驱动的响应而闻名。<div> <img src="img/B03980_04_23.jpg" alt="Spring XD"/> </div></li></ol></div><p>这里显示了 Spring XD 运行时架构(source Pivotal):</p><div><img src="img/B03980_04_22.jpg" alt="Spring XD"/></div></div>





<title>Summary</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title"><a id="ch04lvl1sec30"/>总结</h1></div></div></div><p>在本章中，我们了解了实现机器学习的开源选项，并涵盖了库、工具和框架(如 Apache Mahout、Python、R、Julia 和 Apache Spark 的 MLib)的安装、实现和执行。重要的是，我们讨论了这些框架与大数据平台(Apache Hadoop)的集成。本章更多的是为后面的章节打下基础，在后面的章节中我们将学习如何使用这些框架来实现特定的机器学习算法。</p></div>
</body></html>