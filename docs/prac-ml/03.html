<html><head/><body>



<title>Chapter 3. An Introduction to Hadoop's Architecture and Ecosystem</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title"><a id="ch03"/>第三章。Hadoop 架构和生态系统简介</h1></div></div></div><p>从本章开始，我们从机器学习的实现方面开始。让我们开始了解选择的平台—一个可以扩展到高级企业数据需求(特别是机器学习的大数据需求)的平台—Hadoop。</p><p>在本章中，我们将介绍 Hadoop 平台及其在应对机器学习的大规模加载、存储和处理挑战方面的能力。除了对 Hadoop 架构、其核心框架和其他支持生态系统组件的概述之外，本文还包括详细的安装流程和示例部署方法。虽然有许多 Hadoop 的商业发行版，但我们在这一章的重点是涵盖 Hadoop 的开源 Apache 发行版(最新版本 2.x)。</p><p>本章深入讨论了以下主题:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">介绍 Apache Hadoop、其发展历史、核心概念以及构成 Hadoop 的生态系统框架</li><li class="listitem" style="list-style-type: disc">Hadoop 发行版和特定产品</li><li class="listitem" style="list-style-type: disc">Hadoop 环境的安装和设置</li><li class="listitem" style="list-style-type: disc">Hadoop 2.0—HDFS 和 MapReduce(还有<a id="id299" class="indexterm"/> <strong> YARN </strong> ( <strong>还有另一个资源谈判者</strong>))架构，带有示例实现场景，使用架构的不同组件</li><li class="listitem" style="list-style-type: disc">理解核心生态系统组件的用途，使用示例设置并学习构建和运行程序</li><li class="listitem" style="list-style-type: disc">探索机器学习特定的生态系统扩展，如 Mahout 和 R 连接器(<a class="link" href="ch04.html" title="Chapter 4. Machine Learning Tools, Libraries, and Frameworks">第 4 章</a>，<em>机器学习工具、库和框架</em>，涵盖实现细节)</li></ul></div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec19"/>Apache Hadoop 简介</h1></div></div></div><p>Apache Hadoop <a id="id300" class="indexterm"/>是 Apache Software Foundation 的一个基于 Java 的开源项目。该软件的核心目的是为大数据的分布式存储和处理提供一个可伸缩、可扩展和容错的平台。请参考<a class="link" href="ch02.html" title="Chapter 2. Machine learning and Large-scale datasets">第 2 章</a>、<em>机器学习和大规模数据集</em>了解更多关于哪些数据符合大数据的信息。下图是 Hadoop 的标准 logo:</p><div><img src="img/B03980_03_01.jpg" alt="Introduction to Apache Hadoop"/></div><p>在它的核心，它利用了可以作为商用服务器的节点集群，并促进了并行处理。Hadoop 这个名字是由它的创造者 Doug Cutting 起的，以他孩子的黄色毛绒玩具大象命名。直到今天，雅虎！一直是 Hadoop 的最大贡献者和广泛用户。关于 Hadoop 的更多细节、它的架构和下载链接可以在<a class="ulink" href="http://hadoop.apache.org/">http://hadoop.apache.org/</a>获得。</p><p>Hadoop 是大数据的行业标准平台，它对市场上所有流行的机器学习工具都提供了广泛的支持。这个平台现在被几家大公司使用，如微软、谷歌、雅虎。，还有 IBM。它还用于解决特定的机器学习需求，如情感分析、搜索引擎等。</p><p>以下部分涵盖了 Hadoop 平台的一些关键特征，这些特征使其成为提高大规模数据存储和处理能力效率的理想选择。</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec41"/>Hadoop(首选平台)的发展</h2></div></div></div><p>下面的<a id="id302" class="indexterm"/>图(来源 Cloudera Inc .)解释了 Hadoop 平台的演变。Doug Cutting 和 Mike Cafarella 从 2002 年开始构建一个高度可扩展的搜索引擎，它是开源的，因此可以扩展并运行在一堆机器上。这一发展阶段的一些重要里程碑是谷歌在 2003 年 10 月发布了<strong>谷歌文件系统</strong> ( <strong> GFS </strong> ) <a id="id303" class="indexterm"/>，随后在 2004 年 12 月发布了 MapReduce 框架，分别形成了核心框架 HDFS 和 MapReduce/YARN。</p><p>另一个重要的里程碑是雅虎在 2008 年 2 月左右的贡献和采用，当时<a id="id304" class="indexterm"/>雅虎实现了一个生产版本，在 10，000 多个 Hadoop 集群节点上实现了搜索索引。下表描述了 Hadoop 的发展历程:</p><div><img src="img/B03980_03_02.jpg" alt="Evolution of Hadoop (the platform of choice)"/></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec42"/> Hadoop 及其核心元素</h2></div></div></div><p>下面的概念图<a id="id305" class="indexterm"/>描绘了<a id="id306" class="indexterm"/>Hadoop 平台的核心元素和方面:</p><div><img src="img/B03980_03_03.jpg" alt="Hadoop and its core elements"/></div></div></div></div>





<title>Machine learning solution architecture for big data (employing Hadoop)</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title"><a id="ch03lvl1sec20"/>面向大数据的机器学习解决方案架构(采用 Hadoop)</h1></div></div></div><p>在本节中，让我们来看一下<a id="id307" class="indexterm"/>考虑到大数据需求，实施机器学习解决方案的基本架构组件。</p><p>提议的解决方案架构应该以高效且经济的方式支持各种数据源的使用。下图总结了可能成为机器学习解决方案技术堆栈一部分的核心架构组件。框架的选择既可以是开源的，也可以是打包的许可选项。在本书的上下文中，我们考虑了 Hadoop 及其生态系统组件的最新版本的开源(Apache)发行版。</p><div><div><h3 class="title"><a id="note03"/>注意</h3><p>特定于供应商的框架和扩展超出了本章的范围。</p></div></div><div><img src="img/B03980_03_04.jpg" alt="Machine learning solution architecture for big data (employing Hadoop)"/></div><p>在接下来的章节中，我们将<a id="id308" class="indexterm"/>详细讨论这些参考架构的每一层以及每一层中所需的框架。</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec43"/>数据源层</h2></div></div></div><p><a id="id309" class="indexterm"/>数据源层构成了机器学习参考架构的<a id="id310" class="indexterm"/>关键部分。有许多内部和外部的数据输入，形成了解决机器学习问题的输入。这些提要实际上可以是结构化的、非结构化的或半结构化的。此外，在实时、批处理或接近实时的模式下，它们需要针对分析引擎和可视化工具进行无缝集成和整合。</p><p>在将这些数据输入系统进行进一步处理之前，必须去除数据中的无关信息或噪声。可以应用一些独特的技术来清理和过滤数据。</p><p>这些整合的数据集在大数据和数据聚合环境中也称为数据湖。Hadoop 是数据湖的存储选择之一。</p><p>下图显示了构成主要输入源的各种数据源。</p><div><img src="img/B03980_03_05.jpg" alt="The Data Source layer"/></div><p>数据架构总是被设计成支持一些协议，比如 JMS、HTTP、XML 等等。然而，现在，大数据领域的最新进展带来了重大变化。所以现在，新时代的数据源包括来自社交网站的数据流、GPS 数据、机器生成的数据(如用户访问日志)和其他专有数据格式。</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec44"/>摄食层</h2></div></div></div><p><a id="id311" class="indexterm"/>数据摄取层负责<a id="id312" class="indexterm"/>将来自多个数据源的数据引入系统，主要职责是确保数据质量。这一层具有过滤、转换、集成和验证数据的能力。实现这一层的技术选择应该能够支持大量数据和其他数据特征，这一点很重要。以下元模型显示了摄取层功能的组成和流程。摄取层可能是架构中(<strong>提取、转换和加载</strong>)功能<a id="id313" class="indexterm"/>的简称<strong> ETL </strong>。</p><p>下面列出了摄取层的一组基本要求:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">以任何方式高速转换来自任何源系统的数据</li><li class="listitem" style="list-style-type: disc">在最短的时间内处理大量记录</li><li class="listitem" style="list-style-type: disc">以语义丰富的格式生成输出，以便任何目标系统都可以查询<a id="id314" class="indexterm"/> <strong>智能数据</strong></li></ul></div><p><a id="id316" class="indexterm"/>摄取层的<a id="id315" class="indexterm"/>架构框架需要提供以下能力:即将推出的模型描绘了各种层和组成:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">适配器框架——任何产品组或应用程序都应该能够使用适配器框架来快速、可靠地以编程方式开发不同数据源(文件、CSV 格式和 DB)的连接器</li><li class="listitem" style="list-style-type: disc">高速并行转换执行引擎</li><li class="listitem" style="list-style-type: disc">作业执行框架</li><li class="listitem" style="list-style-type: disc">语义化输出生成器框架<div> <img src="img/B03980_03_06.jpg" alt="The Ingestion layer"/> </div></li></ul></div><p><a id="id317" class="indexterm"/>摄取层将相关的<a id="id318" class="indexterm"/>数据加载到存储层，在我们当前的上下文中，存储层是 Hadoop 存储层，主要是基于文件的存储层。</p><p>下面的概念图列出了摄取核心模式(这些模式解决了机器学习架构的性能和可伸缩性需求):</p><div><img src="img/B03980_03_07.jpg" alt="The Ingestion layer"/></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>并行处理和分区模式</strong>:处理大容量<a id="id320" class="indexterm"/>摄取需求的<a id="id319" class="indexterm"/>的基本架构是并行执行。对不同的输入数据并行运行转换，并将单个大容量输入划分为较小的批处理以进行并行处理，有助于实现并行化。</li><li class="listitem" style="list-style-type: disc"><strong>管道设计模式</strong>:当<a id="id321" class="indexterm"/>为摄取作业设计工作流时，有一些特定的问题需要解决，比如避免支持并行处理的大型顺序管道。同样，从数据可靠性的角度来看，创建适当的审计和执行日志对于管理整个摄取执行非常重要。</li><li class="listitem" style="list-style-type: disc"><strong>变换模式</strong>:变换有<a id="id322" class="indexterm"/>不同的类别。转换设计的一个主要方面是处理依赖性。第一类中提到的模式(并行化)也处理依赖性需求。其他问题涉及对过去和历史数据的依赖性，这在处理额外负载时尤其重要。</li><li class="listitem" style="list-style-type: disc"><strong>存储设计</strong>:当<a id="id323" class="indexterm"/>将数据加载到目标数据存储时，会出现一些问题，例如从失败的转换中恢复或者为特定的提要重新加载数据(例如，当应该有固定的转换规则时)。</li><li class="listitem" style="list-style-type: disc"><strong>数据加载模式</strong>:数据接收中最大的性能瓶颈之一是将数据加载到目标数据集市的速度。特别是当目标是一个<a id="id325" class="indexterm"/> RDBMS 时，并行化策略会在加载数据时导致并发问题，从而限制了可能的接收吞吐量。这些模式展示了在加载数据时如何实现数据加载并解决性能和并发性问题的某些技术。</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec45"/>Hadoop 存储层</h2></div></div></div><p>Machine <a id="id326" class="indexterm"/> learning 架构有一个<a id="id327" class="indexterm"/>分布式存储层，支持对大数据运行分析或繁重计算的并行处理。使用分布式存储和并行处理大量数据是企业处理大数据方式的根本变化。</p><p>典型的分布式存储通过并行处理算法来促进高性能，这些算法在具有容错、可靠性和并行处理能力的 Pb 级数据上运行。</p><p>在当前的 Hadoop 架构背景下，<strong> Hadoop 分布式文件系统</strong> ( <strong> HDFS </strong>)是核心存储<a id="id328" class="indexterm"/>机制。在本节中，让我们简要了解一下 HDFS 和 NoSQL(不仅仅是 SQL)存储选项。下面几节将更详细地介绍 HDFS 及其建筑。</p><p>HDFS 是核心组件之一，充当 Hadoop 的数据库。它是一个分布式文件系统，跨节点集群存储大规模数据。它带有一个框架来确保数据的可靠性和容错性。应用程序可以根据文件的大小存储文件的一部分或全部，这有助于一次写入多次读取。</p><p>由于 HDFS 是一个文件系统，访问数据进行消费或操作并不简单，需要一些复杂的文件操作程序。另一种简化数据管理的方法是使用称为 NoSQL 存储的非关系存储。</p><p>以下模型代表各种 NoSQL 数据存储类别，每个类别都有示例。每个数据存储类别都满足特定的业务需求，了解 NoSQL 存储中每个类别的用途以针对给定的需求做出正确的选择非常重要。每个 NoSQL 商店都在不同程度上满足 CAP 定理(代表一致性、可用性和分区容差)属性，从而支持优化的存储系统，这些存储系统有望为这些属性的组合而工作。实际上，这些 NoSQL 存储可能必须与关系存储共存，因为它们需要一个记录系统来根据需要进行同步，或者更好的情况是我们需要使用关系和非关系数据的组合。</p><p>下图描述了<a id="id329" class="indexterm"/> NoSQL 数据库<a id="id330" class="indexterm"/>的类型以及市场上的一些产品:</p><div><img src="img/B03980_03_08.jpg" alt="The Hadoop Storage layer"/></div><p>Hadoop 最初是用于批处理的，其中数据以批处理或预定的方式加载到 HDFS。通常，存储层有批量加载的数据。有助于数据加载或摄取到 HDFS 的一些核心和生态系统组件是 Sqoop、<a id="id333" class="indexterm"/><strong/>【Hadoop-in Hadoop-out】MapReduce 函数和 ETL 函数等。</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec46"/>Hadoop(物理)基础设施层-支持设备</h2></div></div></div><p>传统架构和大数据(用于机器学习)架构之间的差异在于底层基础设施的重要性。性能、可伸缩性、可靠性、容错性、高可用性和灾难恢复是该体系结构需要支持的一些重要的质量属性。平台的底层基础设施处理这些需求。</p><p>Hadoop 基础架构是一种分布式架构或模型，其中数据不是存储在一个地方，而是分布在多个节点或一个节点群集中。数据分发策略可以是智能的(如 Greenplum 的情况)，也可以是简单的数学策略(如 Hadoop 的情况)。分布式文件系统节点通过网络链接。这被称为<a id="id336" class="indexterm"/> <strong>无共享架构</strong> ( <strong> SNA </strong>)，大数据解决方案在此参考架构上工作。随着数据跨多个节点分布，流程在数据节点本地运行。</p><p>这是第一次被引用在 http://db.cs.berkeley.edu/papers/hpts85-nothing.pdf 的迈克尔·斯通布雷克的论文中。</p><p>存储了<a id="id337" class="indexterm"/>数据的节点被称为<a id="id338" class="indexterm"/>数据节点，处理发生的节点被称为计算节点。数据和计算节点可以并置或分离。下图显示了数据和计算节点并置的 SNA 上下文:</p><div><img src="img/B03980_03_09.jpg" alt="The Hadoop (Physical) Infrastructure layer – supporting appliance"/></div><p>共享<a id="id339" class="indexterm"/> nothing 数据架构支持并行处理。冗余是默认的期望，因为它处理来自不同来源的各种数据。</p><p>Hadoop 和 HDFS 通过<a id="id340" class="indexterm"/>网格基础设施连接，通过快速千兆网络或虚拟云基础设施，形成支持大规模机器学习架构的基础设施层。</p><p>下图说明了使用商用服务器的大数据基础架构设置:</p><div><img src="img/B03980_03_10.jpg" alt="The Hadoop (Physical) Infrastructure layer – supporting appliance"/></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec47"/> Hadoop 平台/处理层</h2></div></div></div><p>Hadoop 的平台或<a id="id341" class="indexterm"/>处理层是机器学习架构工具的核心数据处理层。这一层便于查询或访问存储在 Hadoop 存储层(通常使用 HDFS 存储文件系统的 NoSQL 数据库)中的数据，位于 Hadoop 基础架构层的顶部。</p><p>正如在<a class="link" href="ch02.html" title="Chapter 2. Machine learning and Large-scale datasets">第 2 章</a>、<em>机器学习和大规模数据集</em>中了解到的，计算领域的技术进步现在有助于处理大量的分布式计算和并行处理。</p><p>Hadoop 的 MapReduce 框架有助于高效、经济地存储和分析大量数据。</p><p>接下来列出了 Hadoop 平台或处理层的关键组件；这些组件是生态系统的一部分，将在本章接下来的章节中详细讨论:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">MapReduce  : MapReduce <a id="id342" class="indexterm"/>是一种编程范式，用于在大量数据上高效地执行一个函数，通常是在批处理模式下。<em> map </em>函数负责在多个系统之间分配任务，平均分配负载，并并行管理处理。后期处理；<em> reduce </em>函数吸收并组合元素以提供结果。在 Hadoop 的原生 MapReduce 架构、MapReduce v2 和 YARN 上的逐步实现在<em> Hadoop 生态系统组件</em>一节中介绍。</li><li class="listitem" style="list-style-type: disc"><strong> Hive </strong> : Hive <a id="id343" class="indexterm"/>是 Hadoop 的数据仓库框架，负责用类似 SQL 的函数聚合大量数据。Hive 提供了一种高效的存储数据的方式，可以最大限度地利用资源。Hive 的配置和实现方面将在<em> Hadoop 生态系统组件</em>一节中介绍。</li><li class="listitem" style="list-style-type: disc"><strong> Pig </strong> : Pig <a id="id344" class="indexterm"/>是一种简单的脚本语言，便于查询和操作 HDFS 上保存的数据。它在内部以 MapReduce 范式运行函数，通常被认为是简化了 MapReduce 函数的构建。在<em> Hadoop 生态系统组件</em>一节中，详细介绍了配置、学习语法和构建基本功能的分步指南。</li><li class="listitem" style="list-style-type: disc"><strong> Sqoop </strong> : Sqoop <a id="id345" class="indexterm"/>是一个用于 Hadoop 的数据导入工具，它内置了将数据从特定的表、列或完整的数据库导入到文件系统的功能。后处理，Sqoop 支持从几个关系数据库和 NoSQL 数据存储中提取数据。</li><li class="listitem" style="list-style-type: disc">HBase  : HBase <a id="id346" class="indexterm"/>是一个符合 Hadoop 的 NoSQL 数据存储(一个柱状 NoSQL 数据存储)，它使用 HDFS 作为底层文件系统。它支持分布式存储和自动线性扩展。</li><li class="listitem" style="list-style-type: disc">ZooKeeper  : ZooKeeper <a id="id347" class="indexterm"/>是一个监控和协调服务，帮助检查 Hadoop 实例和节点。它负责保持基础设施的同步，保护分布式系统免受部分故障的影响，并确保数据的一致性。ZooKeeper 框架可以独立工作，也可以在 Hadoop 之外工作。</li></ul></div><p>这些生态系统组件的更多内容将在以下章节中深入讨论。</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec48"/>分析层</h2></div></div></div><p>更多的时候，企业<a id="id349" class="indexterm"/>拥有一些真正的<strong>商业智能</strong> ( <strong> BI </strong> ) <a id="id350" class="indexterm"/>工具，这些工具<a id="id351" class="indexterm"/>负责运行一些分析查询并生成一些 MIS 报告或仪表板。需要现代机器学习或分析工具和框架与之共存。现在需要在数据仓库或大数据存储上以传统方式运行分析，以便处理结构化、半结构化和非结构化数据。</p><p>在这种情况下，我们可以预期传统数据存储和使用 Sqoop 等工具的大数据存储之间的数据流。</p><p>NoSQL 商店以低延迟著称；它们有助于实时分析。许多开源分析框架简化了构建模型，并使用简单的现成功能运行复杂的统计和数学算法。现在所需要的是理解每种算法的相关性，以及在给定特定问题的情况下选择合适的算法或方法的能力。</p><p>让我们在接下来的章节里看看下面列出的开源分析和机器学习框架。</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">稀有</li><li class="listitem" style="list-style-type: disc">阿帕奇看象人</li><li class="listitem" style="list-style-type: disc">Python (scikit-learn 发行版)</li><li class="listitem" style="list-style-type: disc">朱莉娅</li><li class="listitem" style="list-style-type: disc">阿帕奇火花</li></ul></div><p>对即将到来的 Spring 项目之一<a id="id352" class="indexterm"/>的介绍被称为<strong> Spring XD </strong> <a id="id354" class="indexterm"/>，因为它看起来像一个可以在 Hadoop 上运行的全面的机器学习解决方案。</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec49"/>消费层</h2></div></div></div><p>从<a id="id356" class="indexterm"/>分析层生成的<a id="id355" class="indexterm"/>洞察或数据处理的结果被最终客户以多种方式消费。这些数据可用于消费的一些方式有:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">服务 API(例如，Web 服务接口(基于 SOAP 或 REST))</li><li class="listitem" style="list-style-type: disc">网络应用</li><li class="listitem" style="list-style-type: disc">报告引擎和数据集市</li><li class="listitem" style="list-style-type: disc">仪表板和可视化工具</li></ul></div><p>在所有选项中，<strong>可视化</strong> <a id="id357" class="indexterm"/>是核心，不仅是分发或交流机器学习结果的重要方式，也是以有助于决策的方式表示数据的好方法。非常明显，数据可视化正在大数据和分析领域获得牵引力。最能代表数据和<a id="id358" class="indexterm"/>潜在模式和关系的可视化是决策的关键。</p><div><img src="img/B03980_03_11.jpg" alt="The Consumption layer"/></div><p>有两种类型的<a id="id359" class="indexterm"/>可视化；一个是解释数据的，第二个是探索数据和底层模式的。可视化现在被视为一种新的交流语言。</p><div><div><div><div><h3 class="title">用可视化来解释和探索数据</h3></div></div></div><p>用于<a id="id360" class="indexterm"/>解释和探索数据的可视化是独特的，并且<a id="id361" class="indexterm"/>用于不同的目的。</p><p>解释的形象化是我们在营销和销售演示中看到的典型形象。这是手上的数据最大程度干净的情况。数据的意义很明确，沟通是由最终决策者来完成的。</p><p>另一方面，用于探索的可视化有助于纠正数据并链接数据的相关和有用属性，以便理解数据本身。探索的可视化有时可能不准确。探索通常以迭代的方式进行，在从手头的数据中获得某种意义之前，可能需要对可视化进行几轮细化。需要去除数据中的一些无关属性，甚至是数据本身(被识别为<em>噪声</em>的那个)。使用可视化进行数据探索的这一步骤有时会取代运行复杂的算法，并且通常需要统计敏锐度。</p><p>市场上一些流行的可视化工具(开源的和商业的)是 Highcharts JS、D3、Tableau 等等。尽管我们使用了其中的一些框架来演示如何描述和交流见解，但是我们并没有明确地深入讨论任何可视化选项。</p><p>另一个重要的<a id="id362" class="indexterm"/>方面是，这些可视化工具<a id="id363" class="indexterm"/>通常需要利用传统的数据仓库工具和大数据分析工具。下图描述了建议的机器学习架构如何支持现有数据仓库或 BI 工具与大数据分析工具共存。正如在<a class="link" href="ch01.html" title="Chapter 1. Introduction to Machine learning">第 1 章</a>、<em>机器学习简介</em>中所解释的，聚合数据和数据湖成为运行机器学习工具的任何大数据分析工具的核心输入。新时代的数据存储口号是语义数据结构。关于语义数据架构的更多信息，请参见第 14 章、<em>机器学习的新一代数据架构</em>中的新兴数据架构部分。下图描述了数据湖和数据仓库环境中可视化的高级视图:</p><div><img src="img/B03980_03_12.jpg" alt="Explaining and exploring data with Visualizations"/></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec34"/>安全与监控层</h3></div></div></div><p>当跨各种来源处理和整合大量数据时，安全性变得至关重要，对于敏感数据，保护数据隐私的需求至关重要，有时也是关键的合规性要求。所需的认证和授权检查需要作为执行机器学习算法的一部分来实现。在机器学习架构中，这更多的是一个先决条件，而不是事后的想法。</p><p>鉴于控制数据访问的重要性，数据接收和处理功能是需要严格安全实现的主要领域。</p><p>由于分布式架构的优势，大数据应用天生容易出现安全漏洞；有必要注意安全实现，并且它不会影响性能、可伸缩性或这些应用程序易于执行和维护的功能。</p><p>机器<a id="id365" class="indexterm"/>学习架构本身应支持以下基本安全需求:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">支持 Kerberos 等标准协议，对群集中的每个节点进行身份验证</li><li class="listitem" style="list-style-type: disc">因为它是一个文件系统，所以需要最低限度的加密支持</li><li class="listitem" style="list-style-type: disc">与节点的通信应该总是使用<a id="id366" class="indexterm"/> <strong> SSL </strong> ( <strong>安全套接字层</strong>)、TLS 或其他包含 NameNode 的协议</li><li class="listitem" style="list-style-type: disc">安全密钥和令牌以及标准密钥管理系统的使用</li><li class="listitem" style="list-style-type: disc">实现分布式日志跟踪，以便轻松跟踪跨层的任何问题</li></ul></div><p>下一个重要需求是监控。分布式数据体系结构带有强大的监控和支持工具，可以处理以联合模型连接的大型节点集群。</p><p>应用程序的停机时间总是有 SLA，恢复机制在确保应用程序可用性的同时遵守这些 SLA 是很重要的。</p><p>这些节点和集群以独立于机器的方式与监控系统通信是很重要的，使用类似 XML 的格式是关键。监控系统的数据存储需求不应影响应用程序的整体性能。</p><p>通常，每个大数据堆栈都带有内置的监控框架或工具。此外，还有 Ganglia 和 Nagios 等开源工具，可以集成并用于监控大数据应用程序。</p></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec35"/> Hadoop 核心组件框架</h3></div></div></div><p>Apache Hadoop <a id="id367" class="indexterm"/>有<a id="id368" class="indexterm"/>两个核心组件:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Hadoop 分布式文件系统也称为 HDFS</li><li class="listitem" style="list-style-type: disc">MapReduce(在 Hadoop 的 2.x 版本中，这被称为 YARN)</li></ul></div><p>Hadoop 的其余组件在机器学习解决方案架构中有所体现。使用 Hadoop，我们围绕这两个核心组件开展工作，并形成 Hadoop 的生态系统组件。</p><p>本章的重点是 Apache Hadoop 2.x 发行版。在这个版本中，HDFS 和 MapReduce 的架构有一些变化。我们首先介绍核心架构，然后介绍作为 2.x 架构一部分的变化。</p><div><div><div><div><h4 class="title"><a id="ch03lvl4sec04"/> Hadoop 分布式文件系统(HDFS)</h4></div></div></div><p><strong> HDFS </strong>是<a id="id369" class="indexterm"/>受<strong> GFS </strong> ( <strong>谷歌文件系统</strong>)启发而打造。它是一个可弹性伸缩的分布式文件系统，支持负载平衡和容错以确保高可用性。它内置了数据冗余，以证明数据的可靠性和一致性。</p><div><img src="img/B03980_03_13.jpg" alt="Hadoop Distributed File System (HDFS)"/></div><p>HDFS 实现了主从架构。这里，主节点称为 NameNode，从节点称为 DataNodes。NameNode 是所有客户端应用程序的入口点，数据通过 NameNode 在 DataNodes 之间分发。实际数据不通过 NameNode 服务器传递，以确保 NameNode 不会成为任何数据分发的瓶颈。只有元数据与客户端通信，实际的数据移动直接在客户端和 DataNodes 之间进行。</p><p>在 Hadoop 架构中，NameNode 和 DataNode 都被称为守护进程。NameNode 需要一台高端计算机，并且应该只运行 NameNode 守护进程。以下几点证明了 NameNode 需要高端机器的理由:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">整个集群的元数据保存在内存中以便更快地访问，并且需要更多的内存</li><li class="listitem" style="list-style-type: disc">NameNode 是 Hadoop 集群的单一入口点和故障点</li><li class="listitem" style="list-style-type: disc">NameNode 与数百或数千个 DataNodes 协调，并管理批处理作业</li></ul></div><p>HDFS 是<a id="id371" class="indexterm"/>建立在传统的层次文件系统之上的，其中创建新目录、添加新文件、删除目录或子目录、删除文件、重命名以及移动或更新文件是常见的任务。每个 DataNodes 中创建和存储的目录、文件、数据节点和数据块的详细信息作为元数据存储在 NameNode 中。</p><p>在这个体系结构中，Namenode 与之通信的还有另一个节点，称为辅助 NameNode。辅助 NameNode 不是 Namenode 的备份，因此不会故障切换到辅助 Namenode。相反，它用于存储来自 NameNode 的元数据和日志文件的副本。NameNode 将数据块的元数据和相关的分布细节保存在一个名为<code class="literal">fsimage</code>的文件中。该映像文件不是针对文件系统中的每个数据操作而更新的，而是通过将它们记录在单独的日志文件中来定期跟踪。这确保了更快的 I/O，从而提高了数据导入或导出操作的效率。</p><p>二级 Namenode 在这方面有特定的功能。它定期下载映像和日志文件，并通过将日志文件中的当前操作附加到 fsimage 来创建新映像，然后将新映像文件上载回 NameNode。这消除了 NameNode 上的任何开销。NameNode 上的任何重启都非常快，并且系统的效率得到了保证。下图描述了客户端应用程序和 HDFS 之间的通信工作流:</p><div><img src="img/B03980_03_14.jpg" alt="Hadoop Distributed File System (HDFS)"/></div><p>HDFS 是为在数据节点之间读写大量数据而构建的。这些大文件被分割成较小文件的块，通常具有固定的大小，如 64 MB 或 128 MB，这些块分布在多个数据节点上。对于这些块中的每一个，总共存储三个副本，以确保冗余并支持容错。可以改变份数，这是系统的配置。关于 HDFS 架构和具体功能的更多信息将在下一节介绍。</p><div><div><div><div><h5 class="title"><a id="ch03lvl5sec01"/>辅助 Namenode 和检查点流程</h5></div></div></div><p>在<a id="id373" class="indexterm"/>定义辅助 NameNode 的目的和<a id="id374" class="indexterm"/>功能时，我们已经了解了一个重要的功能，它负责更新或准备存储在名为<code class="literal">fsimage</code>的文件中的 Namenode 的元数据。这个通过合并现有的 fsimage 和日志文件生成新的 fsimage 的过程称为<a id="id375" class="indexterm"/> <strong>检查点</strong>。下图描述了检查点流程:</p><div><img src="img/B03980_03_15.jpg" alt="Secondary Namenode and Checkpoint process"/></div><p>一些<a id="id376" class="indexterm"/>配置<a id="id377" class="indexterm"/>更改将在与检查点流程相关的<code class="literal">cross-site.XML</code>文件中完成。</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>财产</p>
</th><th style="text-align: left" valign="bottom">
<p>目的</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">dfs.namenode.checkpoint.dir </code></p>
</td><td style="text-align: left" valign="top">
<p>这是保存临时 fsimage 文件以运行合并过程的目录路径。</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">dfs.namenode.checkpoint.edits.dir </code></p>
</td><td style="text-align: left" valign="top">
<p>这是保存临时编辑以运行合并过程的目录路径。该参数的默认值与<code class="literal">dfs.namenode.checkpoint.dir</code>相同</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">dfs.namenode.checkpoint.period</code></p>
</td><td style="text-align: left" valign="top">
<p>两次检查点运行之间的时间间隔(秒)。</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">dfs.namenode.checkpoint.txns</code></p>
</td><td style="text-align: left" valign="top">
<p>不管时间间隔配置如何，该属性定义了在多少个事务之后需要触发检查点进程。</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">dfs.namenode.checkpoint.check.period</code></p>
</td><td style="text-align: left" valign="top">
<p>此属性定义轮询 NameNode 以检查未设置检查点的事务的频率(秒)。</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">dfs.namenode.checkpoint.max-retries</code></p>
</td><td style="text-align: left" valign="top">
<p>在失败的情况下，辅助 Namenode 重试是检查点操作。此属性定义了辅助 Namenode 在放弃之前重试检查点操作的次数。</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">dfs.namenode.num.checkpoints.retained</code></p>
</td><td style="text-align: left" valign="top">
<p>此属性表示由 Namenode 和辅助 NameNode 保留的检查点文件的数量。</p>
</td></tr></tbody></table></div><p>检查点<a id="id378" class="indexterm"/>流程可以由 Namenode 和二级 NameNode 触发<a id="id379" class="indexterm"/>。辅助 Namenode 还负责定期备份<code class="literal">fsimage</code>文件，这将进一步帮助恢复。</p></div><div><div><div><div><h5 class="title"><a id="ch03lvl5sec02"/>拆分大型数据文件</h5></div></div></div><p>HDFS 在分布于集群中的数据节点上存储大文件的较小块。在存储文件之前，HDFS 在内部将整个文件内容拆分为多个固定大小(默认为 64 MB)的数据块。这个大小是可配置的。没有遵循特定的业务逻辑来拆分文件和构建数据块；这完全是由文件大小决定的。然后，这些数据块存储在 DataNodes 上，以便并行进行数据读取和写入。每个数据块本身也是本地文件系统中的一个文件。</p><p>下图描述了如何将一个大文件拆分成较小的块或固定大小的块:</p><div><img src="img/B03980_03_16.jpg" alt="Splitting large data files"/></div><p>每个<a id="id381" class="indexterm"/>块的大小可以通过<code class="literal">hdfs-site.xml</code>中的以下配置参数来控制。集群范围的块大小由<code class="literal">hdfs-site.XML</code>中的<code class="literal">dfs.blocksize configuration</code>属性控制，在 Hadoop 1.0 中的默认值是 64 MB，在 Hadoop 2.x 中是 128 MB。数据块大小由基础架构的效率决定，随着传输速度的提高和新一代驱动器的使用，数据块大小会变得更大:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>财产</p>
</th><th style="text-align: left" valign="bottom">
<p>目的</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">dfs.blocksize </code></p>
</td><td style="text-align: left" valign="top">
<p>值是 134217728。</p>
<p>以字节为单位的前一个值表示 128 MB，或者可以定义以 measure 为后缀的任何值。比如 512m，1g，128k 等等。</p>
</td></tr></tbody></table></div><p>对块大小中的<a id="id382" class="indexterm"/>值的任何更新都不会应用于现有块；只有新块是合格的。</p></div><div><div><div><div><h5 class="title"><a id="ch03lvl5sec03"/>块加载到集群和复制</h5></div></div></div><p>文件拆分后，数据块由固定的数据块大小组成，并针对环境进行配置。</p><p>由于分布式体系结构，非常需要存储数据块的副本来处理数据可靠性。默认情况下，每个数据块存储三份副本。副本配置属性的数量称为复制因子。下表列出了与数据加载和复制相关的所有配置:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>财产</p>
</th><th style="text-align: left" valign="bottom">
<p>目的</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">dfs.replication </code></p>
</td><td style="text-align: left" valign="top">
<p>该值为 3。</p>
<p>这定义了需要存储在每个块中的副本数量。</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">dfs.replication.max</code></p>
</td><td style="text-align: left" valign="top">
<p>最大块复制。</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">dfs.namenode.replication.min</code></p>
</td><td style="text-align: left" valign="top">
<p>最小块复制。</p>
</td></tr></tbody></table></div><p>NameNode 负责确保按照配置完成数据块放置和复制。将这些数据块放到 DataNode 上后，集群中的每个 DataNode 都会定期向 NameNode 发送数据块状态。NameNode 接收到来自 DataNode 的信号这一事实意味着 DataNode 是活动的并且运行正常。</p><p>HDFS 使用<strong>默认块放置策略</strong> <a id="id384" class="indexterm"/>，旨在实现可用节点间的负载平衡。以下是本政策的范围:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">首先，拷贝或副本被写入正在创建文件的 DataNode 这有助于更高的写入性能</li><li class="listitem" style="list-style-type: disc">第二，拷贝或副本从同一机架写入另一个 DataNode 这最大限度地减少了网络流量</li><li class="listitem" style="list-style-type: disc">第三，将副本写入不同机架中的 DataNode 这样，即使交换机出现故障，仍有一份数据块拷贝可用</li></ul></div><p>应用默认的块<a id="id385" class="indexterm"/>放置策略，该策略使用机架上的所有节点，而不会影响性能、数据可靠性和可用性。下图描述了如何使用两个额外副本的复制策略将三个数据块放置在四个节点上。其中一些节点位于机架中，以实现最佳容错。</p><div><img src="img/B03980_03_17.jpg" alt="Block loading to the cluster and replication"/></div><p>总的来说，<a id="id386" class="indexterm"/>加载数据到 HDFS 的流程如下图所示:</p><div><img src="img/B03980_03_18.jpg" alt="Block loading to the cluster and replication"/></div></div></div></div><div><div><div><div><h3 class="title">给 HDFS 写信和从他那里阅读</h3></div></div></div><p>在将文件写入 HDFS 时，客户端首先联系 NameNode，然后<a id="id388" class="indexterm"/>将需要写入 HDFS 的文件的详细信息传递给。NameNode 提供了有关复制配置的详细信息，以及指定数据块放置位置的其他元数据详细信息。下图解释了这个流程:</p><div><img src="img/B03980_03_19.jpg" alt="Writing to and reading from HDFS"/></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec37"/>处理故障</h3></div></div></div><p>当 Hadoop 集群启动时，NameNode 进入安全模式状态，并从所有数据节点接收心跳信号。NameNode 收到来自 DataNodes 的阻塞报告这一事实表明 DataNodes 已启动并正常工作。</p><p>现在假设<strong>数据节点 4 </strong>下降；这意味着<strong>名称节点</strong>没有从<strong>数据节点 4 </strong>接收到任何心跳信号。<strong>名称节点</strong>登记<strong>名称节点</strong>的不可用性，因此，无论<strong>数据节点 4 </strong>做什么，都被负载平衡到具有副本的其他节点。然后由<strong>名称节点</strong>在元数据寄存器中更新该数据。下图说明了同样的情况:</p><div><img src="img/B03980_03_20.jpg" alt="Handling failures"/></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec38"/> HDFS 命令行</h3></div></div></div><p>HDFS 有一个<a id="id389" class="indexterm"/>命令行接口叫做<a id="id390" class="indexterm"/> <strong> FS Shell </strong>。这有助于使用 shell 命令来管理 HDFS。以下截图显示了<code class="literal">Hadoop fs</code>命令及其用法/语法:</p><div><img src="img/B03980_03_21.jpg" alt="HDFS command line"/></div></div><div><div><div><div><h3 class="title">宁静的 HDFS</h3></div></div></div><p>让外部的<a id="id391" class="indexterm"/>应用程序，尤其是 web 应用程序或类似的应用程序，能够通过 HTTP 轻松访问 HDFS 中的数据。HDFS 支持一个名为 WebHDFS 的附加协议，该协议基于 RESTful 标准，便于通过 HTTP 访问 HDFS 数据，不需要任何 Java 绑定或完整的 Hadoop 环境。客户端可以使用 curl/wget 等常用工具来访问 HDFS。在提供对存储在 HDFS 的数据的基于 web 服务的访问的同时，WebHDFS(该平台的内置安全性和并行处理能力)得到了很好的保留。</p><p>要启用 WebHDFS，请在<code class="literal">hdfs-site.xml</code>中进行以下配置更改:</p><div><pre class="programlisting">&lt;property&gt;
          &lt;name&gt;dfs.webhdfs.enabled&lt;/name&gt;
          &lt;value&gt;true&lt;/value&gt;
&lt;/property&gt;</pre></div><p>关于 WebHDFS REST API <a id="id392" class="indexterm"/>的更多细节可以在<a class="ulink" href="http://hadoop.apache.org/docs/current/hadoop-project-dist/hadoop-hdfs/WebHDFS.html">http://Hadoop . Apache . org/docs/current/Hadoop-project-dist/Hadoop-HDFS/web HDFS . html</a>找到。</p></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec50"/> MapReduce</h2></div></div></div><p>MapReduce <a id="id393" class="indexterm"/>类似于 HDFS。Hadoop MapReduce 框架是受 Google 的 MapReduce 框架启发而构建的。它是一个分布式计算框架，有助于跨集群并行处理大量数据，并具有内置的容错机制。它致力于操作和处理本地数据范例，其中处理逻辑被移动到数据，而不是数据被移动到处理逻辑。</p><div><img src="img/B03980_03_22.jpg" alt="MapReduce"/></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec40"/> MapReduce 架构</h3></div></div></div><p>MapReduce 框架<a id="id394" class="indexterm"/>也是基于主从架构的。主作业称为 JobTracker，从作业称为 TaskTrackers。与 NameNode 和 datanode 不同，它们不是物理节点，而是负责跨 datanode 运行处理逻辑的守护进程处理器:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>job tracker</strong>:job tracker<a id="id395" class="indexterm"/>调度由多个任务组成的作业的执行。它负责运行任务跟踪器上的任务或作业，同时监控处理状态。在任何失败的情况下，它负责在任务跟踪器上重新运行失败的任务。</li><li class="listitem" style="list-style-type: disc"><strong>TaskTracker</strong>:TaskTracker<a id="id396" class="indexterm"/>执行 JobTracker 安排的任务，并不断与 JobTracker 通信，协同工作。</li></ul></div><p>现在，让我们将 HDFS 和 MapReduce 上的主从架构进行类比。NameNode 运行<a id="id397" class="indexterm"/> JobTracker，DataNodes 运行 TaskTrackers。</p><p>在典型的多节点群集中，NameNode 和 DataNode 是独立的物理节点，但是在单节点群集中，NameNode 和 DataNode 在基础结构方面是相同的，JobTracker 和 TaskTracker 功能在同一个节点上运行。开发环境中使用单节点集群。</p><div><img src="img/B03980_03_23.jpg" alt="MapReduce architecture"/></div><p>在一个<a id="id398" class="indexterm"/> MapReduce 进程中有两个函数——<code class="literal">Map</code>和<code class="literal">Reduce</code>。</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong> Mapper </strong> : Mapper <a id="id399" class="indexterm"/>作业将文件并行拆分成多个块<a id="id400" class="indexterm"/>，并运行一些基本功能，如排序、过滤，以及其他任何需要的特定业务或分析功能。映射器函数的输出被输入到缩减器函数。</li><li class="listitem" style="list-style-type: disc"><strong> Reducer </strong> : Reducer <a id="id401" class="indexterm"/>作业用于合并跨映射器的结果<a id="id402" class="indexterm"/>，另外还用于根据需要执行任何业务或分析功能。映射器和缩减器作业的中间输出作为键值对存储在文件系统中。map 和 reduce 作业的输入和输出都存储在 HDFS。总的来说，MapReduce 框架负责调度任务、监控状态和处理故障(如果有的话)。下图描述了<code class="literal">Map</code>和<code class="literal">Reduce</code>函数如何对保存在 HDFS 的数据进行操作:<div> <img src="img/B03980_03_24.jpg" alt="MapReduce architecture"/> </div></li></ul></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec41"/>是什么让 MapReduce 迎合了大数据集的需求？</h3></div></div></div><p>MapReduce 编程框架<a id="id403" class="indexterm"/>的一些优点列举如下:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>并行执行</strong>:默认情况下，MapReduce <a id="id404" class="indexterm"/>程序可以在一个集群节点上并行执行。开发团队不需要关注分布式计算的内部，可以直接使用<a id="id405" class="indexterm"/>框架。</li><li class="listitem" style="list-style-type: disc"><strong>容错</strong> : MapReduce <a id="id406" class="indexterm"/>框架工作在主从架构上，在任何节点出现故障的情况下，框架都会自动采取纠正措施。</li><li class="listitem" style="list-style-type: disc"><strong>可伸缩性</strong> : MapReduce <a id="id407" class="indexterm"/>框架，具有分布式工作的能力和向外扩展的能力(水平可伸缩性)，随着容量的增加，新节点可以在任何需要的时候添加到集群中。</li><li class="listitem" style="list-style-type: disc"><strong>数据局部性</strong>:MapReduce 框架的核心前提之一<a id="id408" class="indexterm"/>是将程序带到数据中<a id="id409" class="indexterm"/>，这与将数据带到代码中的传统方式相反。所以准确地说，MapReduce 总是有本地数据，这是性能的最重要的原因之一。</li></ul></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec42"/> MapReduce 执行流程和组件</h3></div></div></div><p>在这一节中，我们<a id="id410" class="indexterm"/>将深入探究<a id="id411" class="indexterm"/> MapReduce 的执行流程以及每个组件是如何工作的:</p><div><ol class="orderedlist arabic"><li class="listitem">客户机向 JobTracker(一个 MapReduce 作业)提交一个新作业，同时提交的还有输入和输出文件路径以及所需的配置。作业排队等待执行，并由作业调度程序挑选。</li><li class="listitem">JobTracker 在上下文中所需数据所在的位置获取数据，并创建一个执行计划来触发 TaskTrackers 执行。</li><li class="listitem">JobTracker 将作业提交给已识别的 TaskTrackers。</li><li class="listitem">TaskTrackers 使用本地数据执行任务。如果数据在本地数据节点上不可用，它将与其他数据节点通信。</li><li class="listitem">TaskTrackers 通过心跳信号向 JobTracker 报告状态。JobTracker 能够固有地处理任何故障情况。</li><li class="listitem">最后，JobTracker 在作业完成时向作业客户机报告输出。</li></ol></div><p>下图描述了刚才描述的步骤。该流程有两个部分:分别带有节点和跟踪器的 HDFS 和 MapReduce。</p><div><img src="img/B03980_03_25.jpg" alt="MapReduce execution flow and components"/></div><p>让我们关注 MapReduce 程序的一些核心组件，并学习如何编写代码。下面的流程图详细说明了流程如何从输入数据开始到输出数据，以及 MapReduce 框架的每个组件或功能如何开始执行。红色虚线框中的块是组件，蓝色方框表示正在流程中转换的数据。</p><div><img src="img/B03980_03_26.jpg" alt="MapReduce execution flow and components"/></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec43"/>开发 MapReduce 组件</h3></div></div></div><p>Hadoop 的 MapReduce 框架<a id="id414" class="indexterm"/>由一组 Java APIs 组成，需要扩展或实现这些 API，以整合旨在通过 Hadoop 集群并行执行的特定功能。下面是一些需要完成的 API 实现:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">输入和输出数据格式接口</li><li class="listitem" style="list-style-type: disc">映射器实现</li><li class="listitem" style="list-style-type: disc">减速器实施</li><li class="listitem" style="list-style-type: disc">瓜分者ˌ分割者</li><li class="listitem" style="list-style-type: disc">组合器</li><li class="listitem" style="list-style-type: disc">驾驶员</li><li class="listitem" style="list-style-type: disc">语境</li></ul></div><div><div><div><div><h4 class="title"><a id="ch03lvl4sec05"/>输入格式</h4></div></div></div><p><code class="literal">InputFormat</code>类<a id="id415" class="indexterm"/>负责<a id="id416" class="indexterm"/>从文件中读取数据，并将其作为<code class="literal">map</code>函数的输入。这个过程执行两个核心功能:一个是将输入数据拆分成称为 InputSplits 的逻辑片段，第二个是将这些拆分作为键值对读取，以提供给<code class="literal">map</code>函数。有两种不同的界面来执行这两种功能:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">输入拆分</li><li class="listitem" style="list-style-type: disc">记录阅读器</li></ul></div><p>输入文件的分割不是一个必要的功能。如果我们需要考虑一个完整的文件进行处理，我们将需要覆盖<code class="literal">isSplittable()</code>函数并将标志设置为<code class="literal">false</code>。</p></div><div><div><div><div><h4 class="title"><a id="ch03lvl4sec06"/>输出格式</h4></div></div></div><p><code class="literal">OutputFormat</code> API <a id="id417" class="indexterm"/>负责验证<a id="id418" class="indexterm"/> Hadoop 具有符合作业输出规范的输出数据格式。RecordWriter 实现负责将最终的输出键值对写入文件系统。每个 InputFormat API 都有一个对应的 OutputFormat API。下表列出了 MapReduce 框架的一些输入和输出格式 API:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>输入格式 API</p>
</th><th style="text-align: left" valign="bottom">
<p>相应的输出格式 API</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">TextInputFormat</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">TextOutputFormat</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">SequenceFileInputFormat</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">SequenceFileOutputFormat</code></p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">DBInputFormat</code></p>
</td><td style="text-align: left" valign="top">
<p><code class="literal">DBOutputFormat</code></p>
</td></tr></tbody></table></div></div><div><div><div><div><h4 class="title"><a id="ch03lvl4sec07"/>映射器实现</h4></div></div></div><p>所有的映射器<a id="id419" class="indexterm"/>实现都需要扩展<code class="literal">Mapper&lt;KeyIn, ValueIn, KeyOut, ValueOut&gt;</code>基类，重要的是覆盖<code class="literal">map()</code>方法来实现特定的业务功能。Mapper 实现类将键值对作为输入，并返回一组键值对作为输出。任何其他中间输出随后由混洗和排序功能获取。</p><p>对于给定的 MapReduce 作业，由 InputFormat 生成的每个 InputSplit 都有一个 Mapper 实例。</p><p>总的来说，映射器实现类需要从基类扩展四个方法。下面简要介绍了这些方法，以及每种方法的用途:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>方法名称和语法</p>
</th><th style="text-align: left" valign="bottom">
<p>目的</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">setup(Context)</code></p>
</td><td style="text-align: left" valign="top">
<p>这是启动映射器执行时回调的第一个方法。除非需要完成任何特定的初始化或者需要完成任何特定的配置设置，否则不强制重写此方法。</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">map(Object, Object, Context)</code></p>
</td><td style="text-align: left" valign="top">
<p>覆盖此方法是映射器实现的关键，因为此方法将作为执行映射器逻辑的一部分被调用。它接受键值对作为输入，响应可以是键值对的集合</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">clean (Context)</code></p>
</td><td style="text-align: left" valign="top">
<p>此方法在生命周期中映射器函数执行结束时调用，有助于清除映射器使用的任何资源。</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">run (Context)</code></p>
</td><td style="text-align: left" valign="top">
<p>重写此方法提供了运行多线程映射器的附加功能。</p>
</td></tr></tbody></table></div><p>让我们从一个给定的文件中取一个例子；我们想知道一个单词重复了多少次。在这种情况下，使用<code class="literal">TextInputFormat</code>。事实上，这是默认的 InputFormat。下图显示了 InputSplit 函数的作用。它拆分每一行并构建一个键值对。</p><p>该图显示了文本如何存储在 DataNode 上的多个块中。<code class="literal">TextInputFormat</code>然后读取这些块和多个 input split(我们可以看到有两个 input split，因此有两个 mappers)。每个映射器选择一个 InputSplit，然后<a id="id420" class="indexterm"/>为后面跟数字 1 的单词的每次出现生成一个键值对。</p><div><img src="img/B03980_03_27.jpg" alt="Mapper implementation"/></div><p>mapper 函数的输出在处理结束时被写入磁盘，并且没有任何中间结果被写入文件系统。它们被保存在记忆中。这有助于优化性能。这是可能的，因为键空间是分区的，每个映射器只获得整个数据集的一部分。现在，就应该为此目的分配多少内存而言，默认情况下分配 100 MB，对于该值的任何更改，都必须设置<code class="literal">io.sort.mb</code>属性。通常会设置一个阈值来限制这个值，如果超过这个值，就会有一个后台进程开始向磁盘写入数据。下面的程序片段演示了如何实现一个<a id="id421" class="indexterm"/>映射器类。</p><div><pre class="programlisting">public static class VowelMapper extends Mapper&lt;Object, Text, Text, IntWritable&gt;
{
private final static IntWritable one = new IntWritable(1);
private Text word = new Text();
public void map(Object key, Text value, Context context) throws IOException, InterruptedException
{
StringTokenizer itr = new StringTokenizer(value.toString());
while (itr.hasMoreTokens())
{
word.set(itr.nextToken());
context.write(word, one);
}
}
}</pre></div></div></div></div></div>





<title>Hadoop 2.x</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title"><a id="ch03lvl1sec21"/> Hadoop 2.x</h1></div></div></div><p>在 Hadoop 2.x 之前，所有的<a id="id422" class="indexterm"/>发行版都专注于解决 Hadoop 1.x 中的限制，但没有偏离核心架构。Hadoop 2.x 真正改变了底层架构假设，结果是真正的突破；最重要的是，纱线的引入。YARN 是一个用于管理 Hadoop 集群的新框架，除了批处理之外，它还引入了处理实时处理需求的能力。讨论的一些重要问题如下:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">单名称节点问题</li><li class="listitem" style="list-style-type: disc">集群中的节点数量急剧增加</li><li class="listitem" style="list-style-type: disc">Hadoop 可以成功解决的任务数量的扩展</li></ul></div><p>下图描述了 Hadoop 1.x 和 2.x 架构之间的差异，以及 YARN 如何连接 MapReduce 和 HDFS:</p><div><img src="img/B03980_03_28.jpg" alt="Hadoop 2.x"/></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec51"/> Hadoop 生态系统组件</h2></div></div></div><p>Hadoop <a id="id423" class="indexterm"/>已经<a id="id424" class="indexterm"/>衍生了一堆辅助和支持框架。下图描述了开源开发团队提供的所有支持框架:</p><div><img src="img/B03980_03_29.jpg" alt="Hadoop ecosystem components"/></div><p>下表<a id="id425" class="indexterm"/>列出了所有的框架以及每个<a id="id426" class="indexterm"/>框架的用途。这些框架与 Hadoop 的 Apache 发行版一起工作。供应商构建了许多框架，这些框架都是商业定位的，不在本书的讨论范围之内:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>结构</p>
</th><th style="text-align: left" valign="bottom">
<p>统一资源定位器</p>
</th><th style="text-align: left" valign="bottom">
<p>目的(简述)</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><strong> HDFS </strong> ( <strong> Hadoop 分布式文件系统</strong>)</p>
</td><td style="text-align: left" valign="top">
<p><a class="ulink" href="http://hadoop.apache.org/docs/current/hadoop-project-dist/hadoop-hdfs/HdfsUserGuide.html">http://Hadoop . Apache . org/docs/current/Hadoop-project-dist/Hadoop-HDFS/HDFS user guide . html</a></p>
</td><td style="text-align: left" valign="top">
<p>Hadoop <a id="id427" class="indexterm"/>文件存储系统是 Hadoop 的核心组件，它具有内置的容错功能(有关架构和实施细节的更多详细信息，请参考 HDFS 部分)。</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>MapReduce</p>
</td><td style="text-align: left" valign="top">
<p><a class="ulink" href="http://hadoop.apache.org/docs/current/hadoop-mapreduce-client/hadoop-mapreduce-client-core/MapReduceTutorial.html">http://Hadoop . Apache . org/docs/current/Hadoop-MapReduce-client/Hadoop-MapReduce-client-core/MapReduce tutorial . html</a></p>
</td><td style="text-align: left" valign="top">
<p>MapReduce <a id="id428" class="indexterm"/>是一种编程模型和框架，用于在分布式平台(如 Hadoop)上处理大量数据。最新版本的 Apache MapReduce 扩展了另一个框架 Apache YARN。</p>
<p><strong>纱</strong> : MapReduce <a id="id429" class="indexterm"/>在 Hadoop 2.0 中经历了一次彻底的检修，现在被称为 MapReduce 2。但是 MapReduce 编程模型并没有改变。YARN 提供了一个新的资源管理和作业调度模型，以及执行 MapReduce 作业的实现。在大多数情况下，您现有的 MapReduce 作业无需任何更改即可运行。在某些情况下，可能需要少量的更新和重新编译。</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>猪</p>
</td><td style="text-align: left" valign="top">
<p><a class="ulink" href="https://pig.apache.org/">https://pig.apache.org/</a></p>
</td><td style="text-align: left" valign="top">
<p>Pig 是一个以<a id="id431" class="indexterm"/>并行方式执行数据流的<a id="id430" class="indexterm"/>框架。它带有一种脚本语言，Pig Latin，有助于开发数据流。Pig Latin 附带了一堆数据内部操作，比如<a id="id433" class="indexterm"/>连接、拆分、排序等等。Pig 在 Hadoop 上运行，同时利用 HDFS 和 MapReduce。编译后的 Pig Latin 脚本在内部并行运行它们的功能。</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>储备</p>
</td><td style="text-align: left" valign="top">
<p><a class="ulink" href="https://hive.apache.org/">https://hive.apache.org/</a></p>
</td><td style="text-align: left" valign="top">
<p>Hive <a id="id434" class="indexterm"/>是一个用于 Hadoop 的数据仓库框架。它支持<a id="id435" class="indexterm"/>查询和处理分布式存储中的大数据集。可以使用一种称为 HiveQL 的类似 SQL 的查询语言，它允许插入映射器和缩减器程序。</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>水道</p>
</td><td style="text-align: left" valign="top">
<p><a class="ulink" href="http://flume.apache.org/">http://flume.apache.org/</a></p>
</td><td style="text-align: left" valign="top">
<p><a id="id436" class="indexterm"/> Flume <a id="id437" class="indexterm"/>框架更像是一个高效的传输框架，有助于<a id="id438" class="indexterm"/>聚集、分析、处理和移动大量的日志数据。它带有一个可扩展的数据模型，并支持在线分析。</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>丘克瓦</p>
</td><td style="text-align: left" valign="top">
<p><a class="ulink" href="https://chukwa.apache.org/">https://chukwa.apache.org/</a></p>
</td><td style="text-align: left" valign="top">
<p>Chukwa 框架<a id="id440" class="indexterm"/>带有一个 API，可以帮助轻松地收集、分析和监控重要的数据集合。Chukwa 运行在 HDFS 和 MapReduce 框架的顶端，因此继承了 Hadoop 的伸缩能力。</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>HBase</p>
</td><td style="text-align: left" valign="top">
<p>http://hbase.apache.org/<a class="ulink" href="http://hbase.apache.org/"/></p>
</td><td style="text-align: left" valign="top">
<p>h base<a id="id441" class="indexterm"/>的灵感来自谷歌 BigTable。它是一个<a id="id442" class="indexterm"/> NoSQL，柱状数据存储，旨在补充 Hadoop <a id="id443" class="indexterm"/>平台，并支持对数据的实时操作。HBase 是一个 Hadoop 数据库，负责支持 MapReduce 作业输出。</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>HCatalog</p>
</td><td style="text-align: left" valign="top">
<p><a class="ulink" href="https://cwiki.apache.org/confluence/display/Hive/HCatalog">https://cwiki.apache.org/confluence/display/Hive/HCatalog</a></p>
</td><td style="text-align: left" valign="top">
<p>HCatalog <a id="id444" class="indexterm"/>类似于 HDFS 数据的关系视图<a id="id445" class="indexterm"/>。底层数据存储在哪里、以何种方式或何种格式存储都无关紧要。它目前是 Hive 的一部分，目前的发行版没有单独的发行版。</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Avro</p>
</td><td style="text-align: left" valign="top">
<p><a class="ulink" href="http://avro.apache.org/">http://avro.apache.org/</a></p>
</td><td style="text-align: left" valign="top">
<p>Apache Avro 框架更多的是一个数据接口。它支持建模、序列化、进行<a id="id448" class="indexterm"/> <strong>远程过程调用</strong> ( <strong> RPC </strong>)。Avro 中的每个模式表示(也称为元数据定义)都位于数据附近的同一个文件中，因此文件是自描述的。</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>HIHO</p>
</td><td style="text-align: left" valign="top">
<p><a class="ulink" href="https://github.com/sonalgoyal/hiho/wiki/About-HIHO">https://github.com/sonalgoyal/hiho/wiki/About-HIHO</a></p>
</td><td style="text-align: left" valign="top">
<p>HIHO <a id="id449" class="indexterm"/>代表 Hadoop-in Hadoop-out。这个框架有助于将多个数据存储与 Hadoop 系统连接起来，并促进互操作性。HIHO 支持多种 RDBMS 和文件系统，提供了在 RDBMS 和 HDFS 之间并行加载和卸载数据的内部功能。</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Sqoop</p>
</td><td style="text-align: left" valign="top">
<p><a class="ulink" href="http://sqoop.apache.org/">http://sqoop.apache.org/</a></p>
</td><td style="text-align: left" valign="top">
<p>Sqoop <a id="id451" class="indexterm"/>是一个被广泛采用的<a id="id452" class="indexterm"/>框架，用于 HDFS 和 RDBMS 之间的批量数据传输。它与 Flume 非常相似，但使用 RDBMS 操作。Sqoop 是 Hadoop 的<a id="id453" class="indexterm"/> <strong> ETL </strong> ( <strong>提取-转换-加载</strong>)工具之一。</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>塔霍河</p>
</td><td style="text-align: left" valign="top">
<p><a class="ulink" href="http://tajo.apache.org/">http://tajo.apache.org/</a></p>
</td><td style="text-align: left" valign="top">
<p>Tajo <a id="id454" class="indexterm"/>是 Apache <a id="id455" class="indexterm"/> Hadoop 的分布式数据仓库系统，本质上是关系型的。Tajo <a id="id456" class="indexterm"/>支持特定的<a id="id457" class="indexterm"/>查询和在线集成，以及对存储在 HDFS 或其他数据存储中的大型数据集的提取-转换-加载功能。</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>驭象者</p>
</td><td style="text-align: left" valign="top">
<p>【http://oozie.apache.org/ T4】</p>
</td><td style="text-align: left" valign="top">
<p>Oozie <a id="id458" class="indexterm"/>是一个<a id="id459" class="indexterm"/>促进工作流管理的框架。它使用<a id="id460" class="indexterm"/> <strong> DAG </strong> ( <strong>直接无环图</strong>)作为 MapReduce 作业的调度系统。Oozie 在调度和执行作业时既可以是数据感知的，也可以是时间感知的。</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>动物园管理员</p>
</td><td style="text-align: left" valign="top">
<p><a class="ulink" href="http://zookeeper.apache.org/">http://zookeeper.apache.org/</a></p>
</td><td style="text-align: left" valign="top">
<p>顾名思义，Zookeeper 更像是为 Hadoop 提供的编排和协调服务。它为分布式应用程序提供了构建、管理和高可用性的工具。</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>安巴里</p>
</td><td style="text-align: left" valign="top">
<p><a class="ulink" href="http://ambari.apache.org/">http://ambari.apache.org/</a></p>
</td><td style="text-align: left" valign="top">
<p>Ambari <a id="id464" class="indexterm"/>是一个直观的 web UI，用于使用 RESTful APIs 的 Hadoop 管理。阿帕奇<a id="id465" class="indexterm"/>安巴里是 Hortonworks 的一个贡献。它充当生态系统中许多其他 Hadoop 框架的接口。</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>象夫</p>
</td><td style="text-align: left" valign="top">
<p><a class="ulink" href="http://mahout.apache.org/">http://mahout.apache.org/</a></p>
</td><td style="text-align: left" valign="top">
<p>Apache Mahout 是一个开放的机器学习算法的源代码库。Mahout 的设计重点是为分布在多个系统上的大型数据集提供一个可伸缩的库。Apache Mahout 是一个从原始数据中获取有用信息的工具。</p>
</td></tr></tbody></table></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec52"/> Hadoop 的安装和设置</h2></div></div></div><p>有三种不同的方式来设置 Hadoop:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>独立操作</strong>:在这个<a id="id470" class="indexterm"/>操作中，Hadoop 以非分布式模式运行。所有的守护进程都在一个 Java 进程中运行，有助于简化调试。这种设置也称为单节点安装。</li><li class="listitem" style="list-style-type: disc"><strong>伪分布式操作</strong>:在这个<a id="id471" class="indexterm"/>操作中，Hadoop 被配置为在单个节点上运行，但是以伪分布式模式运行，可以在不同的 JVM 上运行不同的守护进程。</li><li class="listitem" style="list-style-type: disc"><strong>全分布式操作</strong>:在这个<a id="id472" class="indexterm"/>操作中，Hadoop 被配置为全分布式运行在多个节点上，主节点上的 NameNode、Secondary Namenode、JobTracker 等所有 Hadoop 守护进程；以及从节点中的 DataNode 和 TaskTracker(简而言之，运行在节点集群上)。</li></ul></div><p>基于 Ubuntu 的 Hadoop 安装先决条件如下:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Java v1.7 版<a id="id473" class="indexterm"/></li><li class="listitem" style="list-style-type: disc">创建专用 Hadoop 用户</li><li class="listitem" style="list-style-type: disc">配置 SSH 访问</li><li class="listitem" style="list-style-type: disc">禁用 IPv6</li></ul></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec44"/>安装 Jdk 1.7</h3></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">使用此命令下载<a id="id474" class="indexterm"/>Java:<div><pre class="programlisting"> <strong>wget https://edelivery.oracle.com/otn-pub/java/jdk/7u45-b18/jdk-7u45-linux-x64.tar.gz</strong> </pre></div><div><img src="img/B03980_03_30.jpg" alt="Installing Jdk 1.7"/></div></li><li class="listitem">使用以下代码解压二进制文件:<div> <pre class="programlisting"> <strong>sudo tar xvzf jdk-7u45-linux-x64.tar.gz</strong> </pre> </div></li><li class="listitem">借助下面的命令创建一个安装 Java 的目录:<div> <pre class="programlisting"> <strong>mkdir -P /usr/local/Java</strong> <strong>cd /usr/local/Java</strong> </pre> </div></li><li class="listitem">将二进制文件复制到新创建的目录:<div> <pre class="programlisting"> <strong>sudo cp -r jdk-1.7.0_45 /usr/local/java</strong> </pre> </div></li><li class="listitem">Configure the PATH parameters:<div><pre class="programlisting">
<strong>sudo nano /etc/profile</strong>
</pre></div><p>否则，使用以下命令:</p><div><pre class="programlisting">
<strong>sudo gedit /etc/profile</strong>
</pre></div></li><li class="listitem">在文件的最后包含以下内容:<div> <pre class="programlisting"> <strong>JAVA_HOME=/usr/local/Java/jdk1.7.0_45</strong> <strong>PATH=$PATH:$HOME/bin:$JAVA_HOME/bin</strong> <strong>export JAVA_HOME</strong> <strong>export PATH</strong> </pre> </div></li><li class="listitem">在 Ubuntu 中，为 Java 配置路径:<div> <pre class="programlisting"> <strong>sudo update-alternatives --install "/usr/bin/javac" "javac" "/usr/local/java/jdk1.7.0_45/bin/javac" 1</strong> <strong>sudo update-alternatives --set javac /usr/local/Java/jdk1.7.0_45/bin/javac</strong> </pre> </div></li><li class="listitem">检查安装完成:<div> <pre class="programlisting"> <strong>java -version</strong> </pre> </div> <div> <img src="img/B03980_03_31.jpg" alt="Installing Jdk 1.7"/> </div></li></ol></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec45"/>为 Hadoop 创建系统用户(专用)</h3></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">创建/添加一个<a id="id475" class="indexterm"/>新组:<div> <pre class="programlisting"> <strong>sudo addgroup hadoop</strong> </pre> </div></li><li class="listitem">创建/添加一个新用户并将其附加到该组:<div> <pre class="programlisting"> <strong>sudo adduser –ingroup hadoop hduser</strong> </pre> </div> <div> <img src="img/B03980_03_32.jpg" alt="Creating a system user for Hadoop (dedicated)"/> </div></li><li class="listitem">创建/配置<a id="id476" class="indexterm"/>SSH 密钥访问:<div> <pre class="programlisting"> <strong>ssh-keygen -t rsa -P ""</strong> <strong>cat $HOME/.ssh/id_rsa.pub &gt;&gt; $HOME/.ssh/authorized_keys</strong> </pre> </div></li><li class="listitem">验证 SSH 设置:<div> <pre class="programlisting"> <strong>ssh hduser@localhost</strong> </pre> </div></li></ol></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec46"/>禁用 IPv6</h3></div></div></div><p>使用以下命令<a id="id477" class="indexterm"/>打开<code class="literal">sysctl.conf</code>:</p><div><pre class="programlisting">
<strong>sudo gedit /etc/sysctl.conf</strong>
</pre></div><div><div><h3 class="title"><a id="tip04"/>提示</h3><p><strong>下载示例代码</strong></p><p>您可以从您在<a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a>的账户下载您购买的所有 Packt 书籍的示例代码文件。如果你在别处购买了这本书，你可以访问 http://www.packtpub.com/support 并注册，文件会直接通过电子邮件发送给你。</p></div></div><p>在文件末尾添加以下行。重新启动机器以正确更新配置:</p><div><pre class="programlisting">
<strong>#disable ipv6</strong>
<strong>net.ipv6.conf.all.disable_ipv6 = 1</strong>
<strong>net.ipv6.conf.default.disable_ipv6 = 1</strong>
<strong>net.ipv6.conf.lo.disable_ipv6 = 1</strong>
</pre></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec47"/>安装 Hadoop 2.6.0 的步骤</h3></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">用这个下载<a id="id478" class="indexterm"/>Hadoop 2 . 6 . 0:<div><pre class="programlisting"> <strong>wget  http://apache.claz.org/hadoop/common/hadoop-2.6.0/hadoop-2.6.0.tar.gz</strong> </pre></div></li><li class="listitem">使用以下命令解压压缩的 Hadoop 文件:<div> <pre class="programlisting"> <strong>tar –xvzf hadoop-2.6.0.tar.gz</strong> </pre> </div></li><li class="listitem">移动 hadoop-2.6.0 目录(新目录):<div> <pre class="programlisting"> <strong>mv hadoop-2.6.0 hadoop</strong> </pre> </div></li><li class="listitem">使用以下命令将 Hadoop 移动到本地文件夹(为了方便):<div> <pre class="programlisting"> <strong>sudo mv hadoop /usr/local/</strong> </pre> </div></li><li class="listitem">改变文件夹的所有者:<div> <pre class="programlisting"> <strong>sudo chown -R hduser:hadoop Hadoop</strong> </pre> </div></li><li class="listitem">Next, update the configuration files.<p>有三个特定于站点的配置文件和一个环境设置配置文件用于与主节点(NameNode)和从节点(DataNodes)通信:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">core-site.xml</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">hdfs-site.xml</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">mapred-site.xml</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">yarn-site.xml</code></li></ul></div><p>导航到包含配置文件的路径:</p><div><pre class="programlisting">
<strong>cd /usr/local/Hadoop/etc/Hadoop</strong>
</pre></div><div><img src="img/B03980_03_33.jpg" alt="Steps for installing Hadoop 2.6.0"/><div><p>yarn-site.xml</p></div></div></li></ol></div><p>第<code class="literal">core-site.XML</code>个文件<a id="id480" class="indexterm"/>包含主节点 IP 或主机名、Hadoop 临时目录路径等详细信息。</p><div><img src="img/B03980_03_34.jpg" alt="Steps for installing Hadoop 2.6.0"/><div><p>核心网站. xml</p></div></div><p><code class="literal">hdfs-site.xml</code>文件包含以下详细信息:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">NameNode 存储命名空间和事务日志的本地文件系统路径</li><li class="listitem" style="list-style-type: disc">存储块的本地文件系统路径列表</li><li class="listitem" style="list-style-type: disc">块大小</li><li class="listitem" style="list-style-type: disc">复制次数</li></ul></div><div><img src="img/B03980_03_35.jpg" alt="Steps for installing Hadoop 2.6.0"/><div><p>hdfs-site.xml</p></div></div><p><code class="literal">mapred-site.xml</code>文件中有<a id="id481" class="indexterm"/>以下的详细信息:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">JobTracker 运行的主机或 IP 和端口</li><li class="listitem" style="list-style-type: disc">Map/Reduce 存储文件的 HDFS 路径</li><li class="listitem" style="list-style-type: disc">本地文件系统上存储中间 MapReduce 数据的路径列表</li><li class="listitem" style="list-style-type: disc">每个任务跟踪器的映射/减少任务的最大限制</li><li class="listitem" style="list-style-type: disc">需要包含或排除的 DataNodes 列表</li><li class="listitem" style="list-style-type: disc">需要包含或排除的 TaskTrackers 列表<div><img src="img/B03980_03_38.jpg" alt="Steps for installing Hadoop 2.6.0"/><div><p>mapred-site . XML</p></div></div></li></ul></div><p>编辑<code class="literal">.bashrc</code>文件<a id="id482" class="indexterm"/>，如下图所示:</p><div><img src="img/B03980_03_36.jpg" alt="Steps for installing Hadoop 2.6.0"/></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec48"/>启动 Hadoop</h3></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">要<a id="id483" class="indexterm"/>启动 NameNode: <div> <pre class="programlisting"> <strong>$ Hadoop-daemon.sh start namenode</strong> <strong>$ jps</strong> </pre> </div></li><li class="listitem" style="list-style-type: disc">启动 DataNode: <div> <pre class="programlisting"> <strong>$ Hadoop-daemon.sh start datanode</strong> <strong>$ jps</strong> </pre> </div></li><li class="listitem" style="list-style-type: disc">要启动 ResourceManager，使用以下命令:<div> <pre class="programlisting"> <strong>$ yarn-daemon.sh start resourcemanager</strong> <strong>$ jps</strong> </pre> </div> <div> <img src="img/B03980_03_37.jpg" alt="Starting Hadoop"/> </div></li><li class="listitem" style="list-style-type: disc">启动节点管理器:<div> <pre class="programlisting"> <strong>$ yarn-daemon.sh start nodemanager</strong> </pre> </div></li><li class="listitem" style="list-style-type: disc">Check Hadoop Web interfaces:<p>命名节点:<code class="literal">http://localhost:50070</code></p><p>辅助 Namenode: <code class="literal">http://localhost:50090</code></p></li><li class="listitem" style="list-style-type: disc">要停止<a id="id484" class="indexterm"/> Hadoop，使用这个:<div> <pre class="programlisting"> <strong>stop-dfs.sh</strong> <strong>stop-yarn.sh</strong> </pre> </div></li></ul></div></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec53"/> Hadoop 发行版和供应商</h2></div></div></div><p>随着面向<a id="id485" class="indexterm"/> Hadoop 的 Apache 发行版成为<a id="id486" class="indexterm"/>大数据社区正在采用的开源核心版本，一些供应商也推出了他们的 Apache Hadoop 开源发行版。其中一些纯粹是添加支持，而另一些则包装和扩展了 Apache Hadoop 及其生态系统组件的功能。在许多情况下，他们在核心框架上构建了自己的框架或库，以向底层核心组件添加新的功能或特性。</p><p>在这一节中，让我们介绍一些 Apache Hadoop 的发行版和一些不同的数据事实，这些数据事实有助于开发团队或组织决定最适合他们需求的发行版。</p><p>现在让我们考虑以下供应商:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Cloudera</li><li class="listitem" style="list-style-type: disc">霍顿工厂</li><li class="listitem" style="list-style-type: disc">MapR</li><li class="listitem" style="list-style-type: disc">Pivotal / EMC</li><li class="listitem" style="list-style-type: disc">IBM<div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom"> <p>Category</p> </th><th style="text-align: left" valign="bottom"> <p>Function/Framework</p> </th><th style="text-align: left" valign="bottom"> <p>Cloudera</p> </th><th style="text-align: left" valign="bottom"> <p>Hortonworks</p> </th><th style="text-align: left" valign="bottom"> <p>MapR</p> </th><th style="text-align: left" valign="bottom"> <p>Pivotal</p> </th><th style="text-align: left" valign="bottom"> <p>IBM</p> </th></tr></thead><tbody><tr><td style="text-align: left" valign="top"> <p>Performance and Scalability</p> </td><td style="text-align: left" valign="top"> <p>Data Ingestion</p> </td><td style="text-align: left" valign="top"> <p>Batch</p> </td><td style="text-align: left" valign="top"> <p>Batch</p> </td><td style="text-align: left" valign="top"> <p>Batch and Streaming</p> </td><td style="text-align: left" valign="top"> <p>Batch and Streaming</p> </td><td style="text-align: left" valign="top"> <p>Batch and Streaming</p> </td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> <p>Metadata architecture</p> </td><td style="text-align: left" valign="top"> <p>Centralized</p> </td><td style="text-align: left" valign="top"> <p>Centralized</p> </td><td style="text-align: left" valign="top"> <p>Distributed</p> </td><td style="text-align: left" valign="top"> <p>Centralized</p> </td><td style="text-align: left" valign="top"> <p>Centralized</p> </td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> <p>HBase performance</p> </td><td style="text-align: left" valign="top"> <p>Spikes in latency</p> </td><td style="text-align: left" valign="top"> <p>Spikes in latency</p> </td><td style="text-align: left" valign="top"> <p>Low latency</p> </td><td style="text-align: left" valign="top"> <p>Low latency</p> </td><td style="text-align: left" valign="top"> <p>Spikes in latency</p> </td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> <p>NoSQL Support</p> </td><td style="text-align: left" valign="top"> <p>Mainly batch applications</p> </td><td style="text-align: left" valign="top"> <p>Mainly batch applications</p> </td><td style="text-align: left" valign="top"> <p>Batch and online systems</p> </td><td style="text-align: left" valign="top"> <p>Batch and online systems</p> </td><td style="text-align: left" valign="top"> <p>Batch and online systems</p> </td></tr><tr><td style="text-align: left" valign="top"> <p>Reliability</p> </td><td style="text-align: left" valign="top"> <p>High <a id="id487" class="indexterm"/>Availability</p> </td><td style="text-align: left" valign="top"> <p>Single failure recovery</p> </td><td style="text-align: left" valign="top"> <p>Single <a id="id488" class="indexterm"/>failure recovery</p> </td><td style="text-align: left" valign="top"> <p>Self-healing across multiple failures</p> </td><td style="text-align: left" valign="top"> <p>Self-healing across multiple failures</p> </td><td style="text-align: left" valign="top"> <p>Single failure recovery</p> </td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> <p>Disaster Recovery</p> </td><td style="text-align: left" valign="top"> <p>File copy</p> </td><td style="text-align: left" valign="top"> <p>N/A</p> </td><td style="text-align: left" valign="top"> <p>Mirroring</p> </td><td style="text-align: left" valign="top"> <p>Mirroring</p> </td><td style="text-align: left" valign="top"> <p>File copy</p> </td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> <p>Replication</p> </td><td style="text-align: left" valign="top"> <p>Data</p> </td><td style="text-align: left" valign="top"> <p>Data</p> </td><td style="text-align: left" valign="top"> <p>Data and metadata</p> </td><td style="text-align: left" valign="top"> <p>Data and metadata</p> </td><td style="text-align: left" valign="top"> <p>Data</p> </td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> <p>Snapshots</p> </td><td style="text-align: left" valign="top"> <p>Consistent with closed files</p> </td><td style="text-align: left" valign="top"> <p>Consistent with closed files</p> </td><td style="text-align: left" valign="top"> <p>Point in time consistency</p> </td><td style="text-align: left" valign="top"> <p>Consistent with closed files</p> </td><td style="text-align: left" valign="top"> <p>Consistent with closed files</p> </td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> <p>Upgrading</p> </td><td style="text-align: left" valign="top"> <p>Rolling upgrades</p> </td><td style="text-align: left" valign="top"> <p>Planned</p> </td><td style="text-align: left" valign="top"> <p>Rolling upgrades</p> </td><td style="text-align: left" valign="top"> <p>Planned</p> </td><td style="text-align: left" valign="top"> <p>Planned</p> </td></tr><tr><td style="text-align: left" valign="bottom"> <p><strong>Manageability</strong></p> </td><td style="text-align: left" valign="top"> <p>Volume Support</p> </td><td style="text-align: left" valign="top"> <p>No</p> </td><td style="text-align: left" valign="top"> <p>No</p> </td><td style="text-align: left" valign="top"> <p>Yes</p> </td><td style="text-align: left" valign="top"> <p>Yes</p> </td><td style="text-align: left" valign="top"> <p>Yes</p> </td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> <p>Management Tools</p> </td><td style="text-align: left" valign="top"> <p>Cloudera Manager</p> </td><td style="text-align: left" valign="top"> <p>Ambari</p> </td><td style="text-align: left" valign="top"> <p>MapR Control system</p> </td><td style="text-align: left" valign="top"> <p>Proprietary console</p> </td><td style="text-align: left" valign="top"> <p>Proprietary console</p> </td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> <p>Integration with REST API</p> </td><td style="text-align: left" valign="top"> <p>Yes</p> </td><td style="text-align: left" valign="top"> <p>Yes</p> </td><td style="text-align: left" valign="top"> <p>Yes</p> </td><td style="text-align: left" valign="top"> <p>Yes</p> </td><td style="text-align: left" valign="top"> <p>Yes</p> </td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> <p>Job replacement control</p> </td><td style="text-align: left" valign="top"> <p>No </p> </td><td style="text-align: left" valign="top"> <p>No</p> </td><td style="text-align: left" valign="top"> <p>Yes</p> </td><td style="text-align: left" valign="top"> <p>Yes</p> </td><td style="text-align: left" valign="top"> <p>No</p> </td></tr><tr><td style="text-align: left" valign="bottom"> <p><strong>Data Access &amp; Processing</strong></p> </td><td style="text-align: left" valign="top"> <p>File System</p> </td><td style="text-align: left" valign="top"> <p>HDFS, <a id="id489" class="indexterm"/>Read-only NFS</p> </td><td style="text-align: left" valign="top"> <p>HDFS, <a id="id490" class="indexterm"/>read-only NFS</p> </td><td style="text-align: left" valign="top"> <p>HDFS, read/write NFS and POSIX</p> </td><td style="text-align: left" valign="top"> <p>HDFS, read/write NFS</p> </td><td style="text-align: left" valign="top"> <p>HDFS, read-only NFS</p> </td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> <p>File I/O</p> </td><td style="text-align: left" valign="top"> <p>Append-only</p> </td><td style="text-align: left" valign="top"> <p>Append-only</p> </td><td style="text-align: left" valign="top"> <p>Read/write</p> </td><td style="text-align: left" valign="top"> <p>Append-only</p> </td><td style="text-align: left" valign="top"> <p>Append-only</p> </td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> <p>Security ACLs</p> </td><td style="text-align: left" valign="top"> <p>Yes</p> </td><td style="text-align: left" valign="top"> <p>Yes</p> </td><td style="text-align: left" valign="top"> <p>Yes</p> </td><td style="text-align: left" valign="top"> <p>Yes</p> </td><td style="text-align: left" valign="top"> <p>Yes</p> </td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> <p>Authentication</p> </td><td style="text-align: left" valign="top"> <p>Kerberos</p> </td><td style="text-align: left" valign="top"> <p>Kerberos</p> </td><td style="text-align: left" valign="top"> <p>Kerberos and Native</p> </td><td style="text-align: left" valign="top"> <p>Kerberos and Native</p> </td><td style="text-align: left" valign="top"> <p>Kerberos and Native</p> </td></tr></tbody></table></div></li></ul></div></div></div>





<title>Summary</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title"><a id="ch03lvl1sec22"/>总结</h1></div></div></div><p>在这一章中，我们讨论了 Hadoop 的所有内容，从核心框架到生态系统组件。在本章结束时，读者应该能够设置 Hadoop 并运行一些 MapReduce 函数。用户应该能够运行和管理 Hadoop 环境，并理解使用一个或多个生态系统组件的命令行用法。</p><p>下一章，我们的重点是 Mahout、Python、R、Spark、Julia 等关键的机器学习框架；这些要么在 Hadoop 平台上具有固有的支持，要么需要与 Hadoop 平台直接集成以支持大型数据集。</p></div>
</body></html>