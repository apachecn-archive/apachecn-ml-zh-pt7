<html><head/><body>



<title>Chapter 9. Structured Prediction</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title"><a id="ch09"/>第九章。结构化预测</h1></div></div></div><p>在本章中，我们将介绍以下配方:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">隐马尔可夫模型——欧元和美元</li><li class="listitem" style="list-style-type: disc">用于状态检测的隐马尔可夫模型</li></ul></div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec46"/>简介</h1></div></div></div><p><strong>隐马尔可夫模型</strong> ( <strong> HMM </strong>)是一种非常强大的表征离散时间序列的观测数据样本的统计方法。它不仅可以提供一种有效的方法来建立简约的参数模型，还可以将动态规划原理纳入其核心，用于时变数据序列的统一模式分割和模式分类。时间序列中的数据样本可以离散或连续分布；它们可以是标量或向量。隐马尔可夫模型的基本假设是数据样本可以被很好地表征为参数随机过程，并且随机过程的参数可以在精确和良好定义的框架中被估计。</p></div></div>





<title>Hidden Markov models - EUR and USD</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title"><a id="ch09lvl1sec47"/>隐马尔可夫模型——欧元和美元</h1></div></div></div><p>欧元/美元是外汇市场上最常见的交易货币对。它们之所以受欢迎，是因为每种货币都代表着世界上最大的两个经济和贸易集团，以及许多在大西洋彼岸开展业务的跨国公司。</p><p>这种货币对的价格变动通常与影响欧元或美元价值的因素有关。作为世界上最具流动性的货币对，欧元/美元为那些希望立即买入或卖出的交易者提供了紧密的利差和持续的流动性。稳定性和波动性的结合使欧元/美元成为新手和高级交易者的绝佳组合。欧元/美元对为交易者提供了高流动性，并具有非常紧密和有竞争力的利差。美国经济和欧洲经济的相对实力(可以通过每日新闻跟踪)通常会影响这一对。</p><div><div><div><div><h2 class="title">准备就绪</h2></div></div></div><p>为了应用隐马尔可夫模型来发现不同的市场机制，从而优化交易策略，我们将使用在欧元数据集上收集的数据集。</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec148"/>步骤1 -收集和描述数据</h3></div></div></div><p>应使用名为<code class="literal">EURUSD1d.csv</code>的数据集。该数据集以CSV格式提供，称为<code class="literal">EURUSD1d.csv</code>。数据集采用标准格式。有1008行数据和五个变量。数字变量如下:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Open</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">High</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Low</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Close</code></li></ul></div><p>非数字变量是:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Open Timestamp</code></li></ul></div></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec59"/>怎么做...</h2></div></div></div><p>让我们进入细节。</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec149"/>步骤2 -探索数据</h3></div></div></div><p>第一步需要加载以下软件包:</p><pre class="programlisting">
<strong>    &gt; install.packages("depmixS4")</strong>
<strong>    &gt; install.packages("quantmod")</strong>
<strong>    &gt; install.packages("ggplot2")</strong>
<strong>    &gt; library(depmixS4)</strong>
<strong>    &gt; library(quantmod)</strong>
<strong>    &gt; library(ggplot2)</strong>
</pre><div><div><h3 class="title"><a id="note27"/>注意</h3><p>版本信息:此页面的代码已在R版本3.2.2中测试过(2015-08-14)</p></div></div><p>让我们研究数据，了解变量之间的关系:</p><p>我们将从导入名为<code class="literal">EURUSD1d.csv</code>的CSV数据文件开始。我们将数据保存到<code class="literal">EuroUSD</code>数据框，如下所示:</p><pre class="programlisting">
<strong>&gt; EuroUSD &lt;- read.csv("d:/EURUSD1d.csv", header = TRUE)</strong>
</pre><p>打印<code class="literal">EuroUSD</code>帧:<code class="literal">head()</code>函数返回<code class="literal">EuroUSD</code>帧的第一部分。<code class="literal">EuroUSD</code>帧作为输入参数传递:</p><pre class="programlisting">
<strong>&gt; head(EuroUSD)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_09_001.jpg" alt="Step 2 - exploring data"/></div><p>
</p><p>打印<code class="literal">EuroUSD</code>数据帧的摘要:<code class="literal">summary()</code>功能是一个多用途功能。<code class="literal">summary()</code>是一个通用函数，提供与单个对象或数据框相关的数据汇总。<code class="literal">EuroUSD</code>数据帧作为R对象传递给<code class="literal">summary()</code>函数:</p><pre class="programlisting">
<strong>&gt; summary(EuroUSD)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_09_002.jpg" alt="Step 2 - exploring data"/></div><p>
</p><p>探索<code class="literal">EuroUSD</code>数据帧的内部结构:<code class="literal">str()</code>函数显示数据帧的内部结构。<code class="literal">EuroUSD</code>作为R对象传递给<code class="literal">str()</code>函数:</p><pre class="programlisting">
<strong>&gt; str(EuroUSD)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_09_003.jpg" alt="Step 2 - exploring data"/></div><p>
</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec150"/>第3步-将数据转化为时间序列</h3></div></div></div><p>创建字符类型的对象:<code class="literal">as.character()</code>函数表示15位有效数字的实数和复数。除了第1 <sup>列和第1</sup>列之外，整个<code class="literal">EuroUSD</code>数据帧被传递:</p><pre class="programlisting">
<strong>&gt; Date &lt;- as.character(EuroUSD[,1])</strong>
</pre><p>操作<code class="literal">Date</code>数据框来表示日历日期。然后将结果存储在数据帧<code class="literal">DateTimeSeries</code>中:</p><pre class="programlisting">
<strong>&gt; DateTimeSeries &lt;- as.POSIXlt(Date, format = "%Y.%m.%d %H:%M:%S")</strong>
</pre><p>创建紧密耦合的数据帧。<code class="literal">data.frame()</code>为<code class="literal">EuroUSD[,2:5]</code>创建数据帧。<code class="literal">row.names = DateTimeSeries</code>给出创建的数据框的行名:</p><pre class="programlisting">
<strong>&gt; TimeSeriesData &lt;- data.frame(EuroUSD[,2:5], row.names = DateTimeSeries)</strong>
</pre><p>打印<code class="literal">TimeSeriesData</code>框架。<code class="literal">head()</code>函数返回<code class="literal">TimeSeriesData</code>帧的第一部分。<code class="literal">TimeSeriesData</code>帧作为输入参数传递:</p><pre class="programlisting">
<strong>&gt; head(TimeSeriesData)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_09_004.jpg" alt="Step 3 - turning data into a time series"/></div><p>
</p><p><code class="literal">as.xts()</code>函数将<code class="literal">TimeSeriesData</code>数据对象转换为<code class="literal">xts</code>类，不会丢失<code class="literal">TimeSeriesData</code>数据帧的任何属性，如下所示:</p><pre class="programlisting">
<strong>&gt; TimeSeriesData &lt;- as.xts(TimeSeriesData)</strong>
</pre><p>衡量高低收盘序列的波动性。<code class="literal">ATR()</code>函数测量<code class="literal">TimeSeriesData</code>的高低收盘系列的平均波动率。<code class="literal">TimeSeriesData[,2:4]</code>表示<code class="literal">TimeSeriesData</code>的高低收盘。结果存储在<code class="literal">ATRindicator</code>数据框中:</p><pre class="programlisting">
<strong>&gt; ATRindicator &lt;- ATR(TimeSeriesData[,2:4],n=14)</strong>
</pre><p>打印<code class="literal">ATRindicator</code>帧。<code class="literal">head()</code>函数返回<code class="literal">ATRindicator</code>帧的第一部分。<code class="literal">ATRindicator</code>帧作为输入参数传递:</p><pre class="programlisting">
<strong>&gt; head(ATRindicator)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_09_005.jpg" alt="Step 3 - turning data into a time series"/></div><p>
</p><p>测量高系列的波动性。<code class="literal">ATRindicator [,2]</code>表示<code class="literal">TimeSeriesData</code>的高位。然后将结果存储在<code class="literal">TrueRange</code>数据帧中:</p><pre class="programlisting">
<strong>&gt; TrueRange &lt;- ATRindicator[,2]</strong>
</pre><p>打印<code class="literal">TrueRange</code>数据帧:</p><pre class="programlisting">
<strong>&gt; head(TrueRange)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_09_006.jpg" alt="Step 3 - turning data into a time series"/></div><p>
</p><p>计算关闭和打开值<code class="literal">LogReturns</code>之间的差值。然后将结果存储在<code class="literal">LogReturns</code>数据帧中:</p><pre class="programlisting">
<strong>&gt; LogReturns &lt;- log(EuroUSD$Close) - log(EuroUSD$Open)</strong>
</pre><p>打印<code class="literal">LogReturns</code>数据帧的摘要。<code class="literal">summary()</code>功能用于提供与单个对象或数据框相关的数据汇总。<code class="literal">LogReturns</code>数据帧作为R对象传递给<code class="literal">summary()</code>函数:</p><pre class="programlisting">
<strong>&gt; summary(LogReturns)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_09_007.jpg" alt="Step 3 - turning data into a time series"/></div><p>
</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec151"/>第4步-建立模型</h3></div></div></div><p>为HMM模型创建数据框。<code class="literal">data.frame()</code>函数创建紧密耦合的变量数据框架，这些变量共享矩阵的许多属性:</p><pre class="programlisting">
<strong>&gt; HMMModel &lt;- data.frame(LogReturns, TrueRange)</strong>
</pre><p>删除正在为<code class="literal">HMMModel</code>计算指标的数据:</p><pre class="programlisting">
<strong>&gt; HMMModel &lt;- HMMModel[-c(1:14),]</strong>
</pre><p>打印<code class="literal">HMMModel</code>画面:</p><pre class="programlisting">
<strong>&gt; head(HMMModel)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_09_008.jpg" alt="Step 4 - building the model"/></div><p>
</p><p>命名列。<code class="literal">c()</code>函数将参数组合成一个向量。传递给函数的所有参数被组合成一个公共类型，即返回值的类型:</p><pre class="programlisting">
<strong>&gt; colnames(HMMModel) &lt;- c("LogReturns","TrueRange")</strong>
</pre><p>打印列名:</p><pre class="programlisting">
<strong>&gt; colnames(HMMModel)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_09_009.jpg" alt="Step 4 - building the model"/></div><p>
</p><pre class="programlisting">
<strong>&gt; set.seed(1)</strong>
</pre><p>建立三态机制，并将响应分布设置为高斯态。<code class="literal">depmix()</code>函数创建隐马尔可夫模型。<code class="literal">LogReturns~1</code>、<code class="literal">TrueRange~1</code>表示要建模的响应。<code class="literal">data = HMMModel</code>代表解释变量响应的数据帧，而<code class="literal">nstates=3</code>是状态数:</p><pre class="programlisting">
<strong>&gt; HMM &lt;- depmix(list(LogReturns~1, TrueRange~1), data = HMMModel, nstates=3, family=list(gaussian(), gaussian()))</strong>
</pre><p>将HMM模型拟合到定义的数据集。<code class="literal">fit()</code>函数优化HMM模型的参数，服从线性不等式。HMM是HMM类的对象，而<code class="literal">verbose = FALSE</code>表示信息不应该显示在屏幕上。优化的参数存储在类<code class="literal">depmix</code>的对象<code class="literal">HMMfit</code>中:</p><pre class="programlisting">
<strong>&gt; HMMfit &lt;- fit(HMM, verbose = FALSE)</strong>
</pre><p>
</p><div><img src="img/image_09_010.jpg" alt="Step 4 - building the model"/></div><p>
</p><p>比较对数似然与AIC和BIC值。<code class="literal">print()</code>函数打印<code class="literal">HMMfit</code>的参数:</p><pre class="programlisting">
<strong>&gt; print(HMMfit)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_09_011.jpg" alt="Step 4 - building the model"/></div><p>
</p><pre class="programlisting">
<strong>&gt; summary(HMMfit)</strong>
</pre><p>打印<code class="literal">LogReturns</code>数据帧的摘要。<code class="literal">summary()</code>功能用于提供与单个对象或数据框相关的数据汇总。<code class="literal">LogReturns</code>数据帧作为R对象传递给<code class="literal">summary()</code>函数:</p><p>结果如下:</p><p>
</p><div><img src="img/image_09_012.jpg" alt="Step 4 - building the model"/></div><p>
</p><p>为数据集的每个状态寻找后验概率。结果存储在<code class="literal">HMMstate</code>中:</p><pre class="programlisting">
<strong>&gt; HMMstate &lt;- posterior(HMMfit)</strong>
</pre><p>打印<code class="literal">HMMstate</code>数据帧。显示每天每个状态的概率和最高概率等级:</p><pre class="programlisting">
<strong>&gt; head(HMMstate)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_09_013.jpg" alt="Step 4 - building the model"/></div><p>
</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec152"/>第5步-显示结果</h3></div></div></div><p>计算出的<code class="literal">HMMstate</code>数据框将按照以下步骤显示:</p><p>为HMM模型创建数据帧。<code class="literal">data.frame()</code>函数创建紧密耦合的变量数据框架，这些变量共享矩阵的许多属性。<code class="literal">DateTimeSeries</code>、<code class="literal">LogReturns</code>、<code class="literal">TrueRange</code>数据帧传递紧密耦合。然后将结果存储在<code class="literal">DFIndicators</code>中:</p><pre class="programlisting">
<strong>    &gt; DFIndicators &lt;- data.frame(DateTimeSeries, LogReturns, TrueRange)</strong>
<strong>    &gt; DFIndicatorsClean &lt;- DFIndicators[-c(1:14), ]</strong>
</pre><p>创建数据框，如下所示:</p><pre class="programlisting">
<strong>&gt; Plot1Data &lt;- data.frame(DFIndicatorsClean, HMMstate$state)</strong>
</pre><p>使用<code class="literal">ggplot()</code>绘制结果:</p><pre class="programlisting">
<strong>    &gt; LogReturnsPlot &lt;- ggplot(Plot1Data,aes(x=Plot1Data[,1],y=Plot1Data[,2]))+geom_line(color="darkred")+labs(,y="Log Return Values",x="Date")</strong>
<strong>    &gt; LogReturnsPlot</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_09_014.jpg" alt="Step 5 - displaying the results"/></div><p>
</p></div></div></div>





<title>Hidden Markov models - regime detection</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title"><a id="ch09lvl1sec48"/>隐马尔可夫模型-状态检测</h1></div></div></div><p>标准普尔500指数(标准普尔500)是由500只股票组成的美国股票市场指数。它是美国股市的领先指标，反映了经济学家挑选的大型公司的表现。专家在确定500只股票时，会考虑指数中包含的因素，包括市场规模、流动性和行业分组。这是一个市值加权指数，也是美国股市的常见基准之一。基于标准普尔500的投资产品包括指数基金和交易所交易基金，可供投资者选择。投资者很难复制标准普尔500，因为投资组合需要500家公司的股票与整个投资组合的比例，才能复制该指数的市值方法。对于投资者来说，购买标准普尔500投资产品会更容易，如先锋标准普尔500 ETF、SPDR 标准普尔500 ETF或股票标准普尔500指数ETF。</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec60"/>准备就绪</h2></div></div></div><p>为了执行隐马尔可夫模型，我们将使用在<code class="literal">S&amp;P500</code>返回集合上收集的数据集。</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec153"/>步骤1 -收集和描述数据</h3></div></div></div><p>要使用的数据集是从2004年1月1日<sup>到现在的<code class="literal">S&amp;P500</code>日回报值。这个数据集可以在https://yahoo.com/<a class="ulink" href="https://yahoo.com/">上免费获得，我们将从那里下载数据。</a></sup></p></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec61"/>怎么做...</h2></div></div></div><p>让我们进入细节。</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec154"/>第2步-探索数据</h3></div></div></div><p>加载以下包:</p><pre class="programlisting">
<strong>    &gt; install.packages("depmixS4")</strong>
<strong>    &gt; install.packages("quantmod")</strong>
</pre><div><div><h3 class="title"><a id="note28"/>注意</h3><p>版本信息:此页面的代码在R版本3.3.0中进行了测试(2016-05-03)</p></div></div><p>需要安装上述每个库。</p><pre class="programlisting">
<strong>    &gt; library("depmixS4 ")</strong>
<strong>    &gt; library("quantmod")</strong>
<strong>    &gt; set.seed(1)</strong>
</pre><p>让我们下载数据。我们将从标记需要数据的时间段的开始日期和结束日期开始。</p><p>使用<code class="literal">getSymbols()</code>功能加载数据，如下所示。该函数从多个源(本地或远程源)加载数据。GSPC是指定要加载的符号名称的字符向量:</p><pre class="programlisting">
<strong>&gt; getSymbols( "^GSPC", from="2004-01-01" )</strong>
</pre><p>
</p><div><img src="img/image_09_015.jpg" alt="Step 2 - exploring data"/></div><p>
</p><p>计算每个收盘价之间的对数差。然后将结果保存在<code class="literal">GSPCDiff</code>数据框中:</p><pre class="programlisting">
<strong>&gt; GSPCDiff = diff( log( Cl( GSPC ) ) )</strong>
</pre><p>探索<code class="literal">GSPCDiff</code>框架的内部结构。<code class="literal">str()</code>功能显示数据帧的内部结构。<code class="literal">GSPCDiff</code>作为R对象传递给<code class="literal">str()</code>函数:</p><pre class="programlisting">
<strong>&gt; str(GSPCDiff)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_09_016.jpg" alt="Step 2 - exploring data"/></div><p>
</p><p>打印<code class="literal">GSPCDiff</code>数据帧，如下所示:</p><pre class="programlisting">
<strong>&gt; head(GSPCDiff)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_09_017.jpg" alt="Step 2 - exploring data"/></div><p>
</p><p>创建<code class="literal">GSPCDiff</code>数据框的数值:</p><pre class="programlisting">
<strong>&gt; returns = as.numeric(GSPCDiff)</strong>
</pre><p>绘制<code class="literal">GSPCDiff</code>数据框:</p><pre class="programlisting">
<strong>&gt; plot(GSPCDiff)</strong>
</pre><p>
</p><div><img src="img/image_09_018.jpg" alt="Step 2 - exploring data"/></div><p>
</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec155"/>步骤3 -准备模型</h3></div></div></div><p>用两种状态的隐马尔可夫模型拟合S&amp;P收益。创建两种状态的隐马尔可夫模型。</p><p><code class="literal">depmix()</code>函数创建隐马尔可夫模型。<code class="literal">returns ~ 1</code>表示要建模的响应。<code class="literal">data=data.frame(returns=returns)</code>代表解释变量响应的数据帧，而<code class="literal">nstates = 2</code>是状态数:</p><pre class="programlisting">
<strong>    &gt; hmm2states &lt;- depmix(returns ~ 1, family = gaussian(), nstates = 2, data=data.frame(returns=returns))</strong>
<strong>    &gt; hmm2states</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_09_019.jpg" alt="Step 3 - preparing the model"/></div><p>
</p><p>将HMM模型拟合到定义的数据集。<code class="literal">fit()</code>函数优化HMM模型的参数，服从线性不等式。<code class="literal">hmm2states</code>是HMM类的对象，而<code class="literal">verbose = FALSE</code>指示信息不应显示在屏幕上。优化的参数存储在<code class="literal">depmix</code>类的对象<code class="literal">hmmfit2states</code>中:</p><pre class="programlisting">
<strong>&gt; hmmfit2states &lt;- fit(hmm2states, verbose = FALSE)</strong>
</pre><p>
</p><div><img src="img/image_09_020.jpg" alt="Step 3 - preparing the model"/></div><p>
</p><p>比较对数似然与AIC和BIC值:</p><pre class="programlisting">
<strong>&gt; hmmfit2states</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_09_021.jpg" alt="Step 3 - preparing the model"/></div><p>
</p><p>为数据集的每个状态寻找后验概率。结果存储在<code class="literal">PosteriorProbs</code>中:</p><pre class="programlisting">
<strong>&gt; PosteriorProbs &lt;- posterior(hmmfit2states)</strong>
</pre><p>打印<code class="literal">PosteriorProbs</code>帧。<code class="literal">head()</code>函数返回<code class="literal">PosteriorProbs</code>帧的第一部分。<code class="literal">PosteriorProbs</code>帧作为输入参数传递:</p><pre class="programlisting">
<strong>&gt; head (PosteriorProbs)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_09_022.jpg" alt="Step 3 - preparing the model"/></div><p>
</p><p>绘制两种状态的结果。<code class="literal">type='l'</code>表示线形图:</p><pre class="programlisting">
<strong>&gt; plot(returns, type='l', main='Regime Detection', xlab='No of Observations', ylab='Returns')</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_09_023.jpg" alt="Step 3 - preparing the model"/></div><p>
</p><p>绘制<code class="literal">PosteriorProbs</code>数据框的列:</p><pre class="programlisting">
<strong>&gt; matplot(PosteriorProbs[,-1], type='l', main='Regime Posterior Probabilities', xlab='No of Observations', ylab='Probability')</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_09_024.jpg" alt="Step 3 - preparing the model"/></div><p>
</p><p>为三种状态创建隐马尔可夫模型:</p><pre class="programlisting">
<strong>    &gt; hmm3states &lt;- depmix(returns ~ 1, family = gaussian(), nstates = 3, data=data.frame(returns=returns))</strong>
<strong>    &gt; hmm3states</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_09_025.jpg" alt="Step 3 - preparing the model"/></div><p>
</p><p>将HMM模型拟合到定义的数据集:</p><pre class="programlisting">
<strong>&gt; hmmfit3states &lt;- fit(hmm3states, verbose = FALSE)</strong>
</pre><p>
</p><div><img src="img/image_09_026.jpg" alt="Step 3 - preparing the model"/></div><p>
</p><p>寻找每个数据集状态的后验概率:</p><pre class="programlisting">
<strong>&gt; PosteriorProbs &lt;- posterior(hmmfit3states)</strong>
</pre><p>打印<code class="literal">PosteriorProbs</code>画面:</p><pre class="programlisting">
<strong>&gt; head(PosteriorProbs)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_09_027.jpg" alt="Step 3 - preparing the model"/></div><p>
</p><pre class="programlisting">
<strong>&gt; plot(returns, type='l', main='Regime Detection', xlab='No of Observations', ylab='Returns')</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_09_028.jpg" alt="Step 3 - preparing the model"/></div><p>
</p><pre class="programlisting">
<strong>&gt; matplot(PosteriorProbs[,-1], type='l', main='Regime Posterior Probabilities', xlab='No of Observations', ylab='Probability')</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_09_029.jpg" alt="Step 3 - preparing the model"/></div><p>
</p><p>为四种状态创建隐马尔可夫模型:</p><pre class="programlisting">
<strong>    &gt; hmm4states &lt;- depmix(returns ~ 1, family = gaussian(), nstates = 4, data=data.frame(returns=returns))</strong>
<strong>    &gt; hmm4states</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_09_030.jpg" alt="Step 3 - preparing the model"/></div><p>
</p><p>将HMM模型拟合到定义的数据集:</p><pre class="programlisting">
<strong>&gt; hmmfit4states &lt;- fit(hmm4states, verbose = FALSE)</strong>
</pre><p>
</p><div><img src="img/image_09_031.jpg" alt="Step 3 - preparing the model"/></div><p>
</p><p>寻找每个数据集的后验概率状态:</p><pre class="programlisting">    <strong>&gt; PosteriorProbs &lt;- posterior(hmmfit4states)</strong>    <strong>&gt; plot(returns, type='l', main='Regime Detection', xlab='No of Observations', ylab='Returns')</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_09_032.jpg" alt="Step 3 - preparing the model"/></div><p>
</p><pre class="programlisting">
<strong>&gt; matplot(PosteriorProbs[,-1], type='l', main='Regime Posterior Probabilities', xlab='No of Observations', ylab='Probability')</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_09_033.jpg" alt="Step 3 - preparing the model"/></div><p>
</p></div></div></div>
</body></html>