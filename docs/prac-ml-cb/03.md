

# 三、聚类

在本章中，我们将介绍以下配方:

*   等级聚类-世界银行
*   等级聚类——亚马逊雨林在 1999-2010 年间被烧毁
*   层次聚类-基因聚类
*   二元聚类-数学测试
*   k-均值聚类-欧洲国家蛋白质消费
*   k-均值聚类-食品

# 简介

**层次聚类**:无监督学习中最重要的方法之一就是层次聚类。在给定的一组数据点的层次聚类中，输出以二叉树(树状图)的形式产生。在二叉树中，树叶代表数据点，而内部节点代表不同大小的嵌套簇。每个对象被分配一个单独的簇。基于成对距离矩阵对所有聚类进行评估。将使用距离值构建距离矩阵。必须考虑具有最短距离的聚类对。然后，应该从矩阵中移除所识别的对，并将其合并在一起。合并的聚类的距离必须与其他聚类一起评估，并且距离矩阵应该被更新。重复该过程，直到距离矩阵减少到单个元素。

通过分层聚类产生对象的排序。这有助于显示信息丰富的数据。较小的集群有助于信息的发现。分层聚类的主要缺点是，如果对象在早期被错误地分组，那么就不能提供对象的重新定位。使用不同的距离度量来测量聚类之间的距离可能导致产生不同的结果。

**K-means 聚类**:K-means 聚类算法是一种估计一组 K-组的均值(向量)的方法。K-Means 聚类方法本质上是无监督的、不确定的和迭代的。该方法产生特定数量的不连续的、扁平的(非分层的)聚类。k 表示集群的数量。这些聚类基于手头的数据。每个聚类至少有一个数据点。这些集群本质上是不重叠和不分层的。数据集被划分成 K 个聚类。数据点被随机分配给每个聚类。这导致在早期阶段数据点在聚类中几乎相等的分布。如果一个数据点最接近它自己的聚类，它就不会改变。如果一个数据点不靠近它自己的聚类，它将被移动到离它最近的聚类。对所有数据点重复这些步骤，直到没有数据点从一个聚类移动到另一个聚类。此时，聚类稳定，聚类过程结束。就簇间和簇内距离和内聚性而言，初始 an 分区的选择可以极大地影响最终得到的簇。

K-means 聚类的主要优点是，与层次聚类相比，它在计算上相对更少，在时间上更便宜。主要的挑战是很难确定集群的数量。



# 层次聚类-世界银行样本数据集

建立世界银行的主要目标之一是战胜和消除贫困。在不断变化的世界中不断发展和微调其政策有助于该机构实现消除贫穷的目标。成功消除贫困的晴雨表是通过改善健康、教育、卫生、基础设施和改善穷人生活所需的其他服务的每一个参数来衡量的。必须以环境、社会和经济可持续的方式追求确保千年发展目标的发展收益。

## 准备就绪

为了执行层次聚类，我们将使用从世界银行数据集收集的数据集。

### 步骤 1 -收集和描述数据

应使用名为`WBClust2013`的数据集。这是一个名为`WBClust2013.csv`的 CSV 格式。数据集采用标准格式。有 80 行数据和 14 个变量。数字变量包括:

*   `new.forest`
*   `Rural`
*   `log.CO2`
*   `log.GNI`
*   `log.Energy.2011`
*   `LifeExp`
*   `Fertility`
*   `InfMort`
*   `log.Exports`
*   `log.Imports`
*   `CellPhone`
*   `RuralWater`
*   `Pop`

非数字变量是:

*   `Country`

## 怎么做...

让我们进入细节。

### 第 2 步-探索数据

### 注

版本信息:此页面的代码在 R 版本 3.2.3 中进行了测试(2015-12-10)

让我们探索数据，了解变量之间的关系。我们将从导入名为`WBClust2013.csv`的 CSV 文件开始。我们将把数据保存到`wbclust`数据框:

```
> wbclust=read.csv("d:/WBClust2013.csv",header=T)

```

接下来，我们将打印`wbclust`数据帧。`head()`函数返回`wbclust`数据帧。`wbclust`数据帧作为输入参数传递:

```
> head(wbclust)

```

结果如下:

![Step 2 - exploring data](img/image_03_001.jpg)

### 步骤 3 -转换数据

将变量居中和创建 z 值是标准化数据的两种常见数据分析活动。上面提到的数字变量需要创建 z 分数。`scale()`函数是一个通用函数，其默认方法是居中和/或缩放数字矩阵的列。数据帧`wbclust`被传递给缩放功能。仅考虑数值字段。然后将结果存储在另一个数据帧`wbnorm`中。

```
 > wbnorm <- scale(wbclust[,2:13])
 > wbnorm

```

结果如下:

![Step 3 - transforming data](img/image_03_002.jpg)

所有数据帧都有一个`rownames`属性。为了检索或设置矩阵状对象的行或列名，使用`rownames()`功能。具有第一列的数据帧`wbclust`被传递给`rownames()`函数。

```
 > rownames(wbnorm)=wbclust[,1]
 > rownames(wbnorm)

```

对函数`rownames(wbnorm)`的调用导致显示第一列的值。结果如下:

![Step 3 - transforming data](img/image_03_003.jpg)

### 步骤 4 -训练和评估模型性能

下一步是训练模型。第一步是计算距离矩阵。使用`dist()`功能。使用指定的距离度量，计算数据矩阵的行之间的距离。使用的距离度量可以是欧几里德、最大值、曼哈顿、堪培拉、二进制或闵可夫斯基。使用的距离度量是欧几里德距离。欧几里德距离将两个向量之间的距离计算为 *sqrt(sum((x_i - y_i)^2))* 。然后将结果存储在新的数据帧`dist1`中。

```
> dist1 <- dist(wbnorm, method="euclidean")

```

下一步是使用 Ward 的方法进行聚类。使用`hclust()`功能。为了对一组不同的 *n* 对象进行聚类分析，使用了`hclust()`函数。在第一阶段，每个对象都被分配到它自己的簇中。此后，在每个阶段，该算法迭代并加入两个最相似的聚类。这个过程一直持续到只剩下一个集群。`hclust()`函数要求我们以距离矩阵的形式提供数据。`dist1`数据帧通过。默认情况下，使用完全链接方法。有多种烧结方法可以使用，其中一些可以是`ward.D`、`ward.D2`、`single`、`complete`和`average`。

```
 > clust1 <- hclust(dist1,method="ward.D")
 > clust1

```

对函数`clust1`的调用导致显示所使用的聚集方法、计算距离的方式以及对象的数量。结果如下:

![Step 4 - training and evaluating the model performance](img/image_03_004.jpg)

### 步骤 5 -绘制模型

`plot()`函数是用于绘制 R 对象的通用函数。这里使用`plot()`函数绘制树状图:

```
> plot(clust1,labels= wbclust$Country, cex=0.7, xlab="",ylab="Distance",main="Clustering for 80 Most Populous Countries")

```

结果如下:

![Step 5 - plotting the model](img/image_03_005.jpg)

`rect.hclust()`函数突出显示聚类，并在树状图的分支周围绘制矩形。首先在某一层切割树状图，然后在选择的分支周围画一个矩形。

对象`clust1`作为对象与要形成的集群数量一起传递给函数:

```
> rect.hclust(clust1,k=5)

```

结果如下:

![Step 5 - plotting the model](img/image_03_006.jpg)

`cuts()`功能应根据所需的组数或切割高度将树切割成多组。这里，`clust1`作为一个对象与所需组的编号一起传递给函数:

```
 > cuts=cutree(clust1,k=5)
 > cuts

```

结果如下:

![Step 5 - plotting the model](img/image_03_007.jpg)

获取每组中的国家列表:

```
for (i in 1:5){
 print(paste("Countries in Cluster ",i))
 print(wbclust$Country[cuts==i])
 print (" ")
}

```

结果如下:

![Step 5 - plotting the model](img/image_03_008.jpg)<title>Hierarchical clustering - Amazon rainforest burned between 1999-2010</title>

# 等级聚类——亚马逊雨林在 1999-2010 年间被烧毁

1999 年至 2010 年间，33，000 平方英里(85，500 平方公里)，即亚马逊雨林的 2.8%被烧毁。这是由美国宇航局领导的研究发现的。这项研究的主要目的是测量森林树冠下的阴燃程度。研究发现，与森林土地被清除用于农业和牧牛场相比，燃烧森林破坏的面积要大得多。然而，无法确定火灾和森林砍伐之间的关联。

对火灾和森林砍伐之间没有关联的质疑的答案在于美国宇航局 Aqua 卫星上的大气红外探测器的湿度数据。火灾频率与夜间低湿度相一致，这使得低强度的地表火灾能够继续燃烧。

## 做好准备

为了执行层次聚类，我们将使用从 1999-2010 年烧毁的亚马逊雨林收集的数据集。

### 步骤 1 -收集和描述数据

应使用`NASAUnderstory`数据集。这是 CSV 格式的`NASAUnderstory.csv`。数据集采用标准格式。有 64 行数据和 32 个变量。数字变量包括:

*   `PlotID`
*   `SPHA`
*   `BLIT`
*   `ASMA`
*   `MOSS`
*   `LEGR`
*   `CHCA`
*   `GRAS`
*   `SEDG`
*   `SMTR`
*   `PTAQ`
*   `COCA`
*   `VAAN`
*   `GAHI`
*   `ARNU`
*   `LYOB`
*   `PIMA`
*   `RUBU`
*   `VAOX`
*   `ACSP`
*   `COCO`
*   `ACRU`
*   `TRBO`
*   `MACA`
*   `CLOB`
*   `STRO`
*   `FUNG`
*   `DILO`
*   `ERIO`
*   `GATR`

非数字变量包括:

*   `Overstory Species`
*   `Labels`

## 怎么做...

让我们进入细节。

### 第 2 步-探索数据

### 注意

版本信息:此页面的代码在 R 版本 3.2.3 中进行了测试(2015-12-10)

让我们探索数据，了解变量之间的关系。我们将从导入名为`NASAUnderstory.csv`的文件开始。我们将把数据保存到`NASA`数据框:

```
> NASA = read.csv("d:/NASAU   nderstory.csv",header=T)

```

接下来，我们将获得每个物种列标签的长版本:

```
 *>* NASA.lab=NASA$Labels

```

接下来，我们将打印`NASA.lab`数据帧。这包括获得的每个物种的完整名称。

结果如下:

![Step 2 - exploring data](img/image_03_009.jpg)

接下来，我们将把整个数据内容传递给`NASA`数据帧:

```
> NASA=NASA[,-32]

```

打印`NASA`数据帧应显示全部数据内容。

```
> NASA

```

结果如下:

![Step 2 - exploring data](img/image_03_010.jpg)

### 步骤 3 -转换数据

接下来，进行数据标准化。如前所述，`scale()`函数应对所有数值变量的列进行居中和缩放:

```
> NASAscale <- scale(NASA[,3:31])

```

这将缩放`NASA`数据帧的`3`至`31`列之间的所有数值。

打印`NASAscale`数据框会显示`NASAscale.`的所有缩放和居中值

```
> NASAscale

```

结果如下:

![Step 3 - transforming data](img/image_03_011.jpg)

为了将向量编码为因子，使用了函数因子。如果参数 ordered 是`TRUE`，则假定因子级别是有序的。这里，我们将`OverstorySpecies`列作为一个值传递给因子函数:

```
> rownames(NASAscale)=as.factor(NASA$Overstory.Species) 

```

`as.factor()`返回带有行名的数据帧。

打印数据帧`rownames(NASAscale)`会显示`OverstorySpecies`列的所有值:

```
> rownames(NASAscale)

```

结果如下:

![Step 3 - transforming data](img/image_03_012.jpg)

### 第 4 步-训练和评估模型性能

下一步是训练模型。第一步是计算距离矩阵。使用`dist()`功能。该函数计算并返回距离矩阵，使用指定的距离度量来计算数据矩阵各行之间的距离。使用的距离度量可以是欧几里德、最大值、曼哈顿、堪培拉、二进制或闵可夫斯基。使用的距离度量是欧几里德距离。欧几里德距离将两个向量之间的距离计算为 *sqrt(sum((x_i - y_i)^2))* 。然后将结果存储在新的数据帧`dist1`中。

```
> dist1 <- dist(NASAscale, method="euclidean")

```

下一步是使用 Ward 的方法进行聚类。使用`hclust()`功能。为了对一组不同的 *n* 对象进行聚类分析，使用了`hclust()`函数。在第一阶段，每个对象都被分配到它自己的簇中。然后，该算法在每个阶段迭代进行，加入两个最相似的聚类。这个过程一直持续到只剩下一个集群。`hclust()`功能要求我们以距离矩阵的形式提供数据。`dist1`数据帧通过。默认情况下，使用完全链接方法。可以使用多种聚集方法，其中一些可以是`ward.D`、`ward.D2`、`single`、`complete`和`average`。

```
 > clust1 <- hclust(dist1,method="ward.D")
 > clust1

```

调用函数`clust1`会显示所使用的聚集方法、计算距离的方式以及对象的数量。结果如下:

![Step 4 - training and evaluating model performance](img/image_03_013.jpg)

### 步骤 5 -绘制模型

`plot()`函数是绘图 R 对象的通用函数。这里，`plot()`函数用于绘制树状图:

```
> plot(clust1,labels= NASA[,2], cex=0.5, xlab="",ylab="Distance",main="Clustering for NASA Understory Data")

```

结果如下:

![Step 5 - plotting the model](img/image_03_014.jpg)

`rect.hclust()`函数突出显示聚类，并在树状图的分支周围绘制矩形。首先在某一层切割树状图，然后在选定的分支周围画一个矩形。

对象`clust1`作为对象与要形成的聚类数一起传递给函数:

```
> rect.hclust(clust1,k=2)

```

结果如下:

![Step 5 - plotting the model](img/image_03_015.jpg)

`cuts()`功能应根据所需的组数或切割高度将树切割成多组。这里，`clust1`作为一个对象与所需组的数量一起传递给函数:

```
 > cuts=cutree(clust1,k=2)
 > cuts

```

结果如下:

![Step 5 - plotting the model](img/image_03_016.jpg)

### 第 6 步-提高模型性能

首先需要加载以下软件包:

```
> library(vegan)

```

图书馆主要由社区和植被生态学家使用。它包含排序方法、多样性分析和其他功能。一些流行的工具有**多样性分析、物种丰富度模型、物种丰富度分析、相异度分析等等。**

下一步是通过使用距离方法`jaccard`进行训练来改进模型。第一步是计算距离矩阵。使用`vegdist()`功能。该函数计算成对距离。然后将结果存储在新的数据帧`dist1`中。`jaccard`系数衡量有限样本集之间的相似性。这是通过将交集的大小除以样本集的并集的大小来计算的:

```
> dist1 <- vegdist(NASA[,3:31], method="jaccard", upper=T)

```

下一步是使用 Ward 的方法进行聚类。使用`hclust()`功能:

```
 > clust1 <- hclust(dist1,method="ward.D")
 > clust1

```

调用函数`clust1`会显示所使用的聚集方法、计算距离的方式以及对象的数量。结果如下:

![Step 6 - improving model performance](img/image_03_017.jpg)

`plot()`函数是绘图 R 对象的通用函数:

```
> plot(clust1,labels= NASA[,2], cex=0.5, xlab="",ylab="Distance",main="Clustering for NASA Understory Data")

```

`clust1`数据帧作为对象传递给函数。`cex`给出相对于默认值，绘图文本和符号可以放大的数值。

结果如下:

对象`clust1`作为对象与要形成的集群数量一起传递给函数:

![Step 6 - improving model performance](img/image_03_018.jpg)

结果如下:

The object `clust1` is passed as an object to the function along with the number of clusters to be formed:

```
> rect.hclust(clust1,k=2)

```

The result is as follows:

`cuts()`功能应根据所需的组数或切割高度将树切割成多组:

![Step 6 - improving model performance](img/B04714_03_19.jpg)

结果如下:

The `cuts()` function shall cut the tree into multiple groups on the basis of the desired number of groups or the cut height:

```
 > cuts=cutree(clust1,k=2)
 > cuts

```

The result is as follows:

使用主成分让我们绘制两个集群解决方案。

![Step 6 - improving model performance](img/image_03_020.jpg)

`clusplot()`函数将绘制一个二维聚类图。这里，`NASA`数据帧作为一个对象被传递。

结果如下:

The `clusplot()` function shall draw a two-dimensional clustering plot. Here, the `NASA` data frame is passed as an object.

The result is as follows:

使用判别函数让我们绘制两个集群解决方案。

![Step 6 - improving model performance](img/image_03_021.jpg)

`plotcluster()`函数使用投影方法绘图，以区分给定的类别。各种投影方法包括经典的判别坐标、投影均值和协方差结构差异的方法、不对称方法(从异类中分离同类)、基于局部邻域的方法和基于稳健协方差矩阵的方法。

`clusplot()`函数应绘制二维聚类图。这里，`NASA`数据帧作为一个对象传递:

结果如下:

The `clusplot()` function shall draw a two-dimensional clustering plot. Here, the `NASA` data frame is passed as an object:

```
> clusplot(NASA, cuts, color=TRUE, shade=TRUE, labels=2, lines=0,  main="NASA Two Cluster  Plot, Ward's Method, First two PC")

```

The result is as follows:

接下来，使用`t()`函数转置`NASAscale`数据帧:

![Step 6 - improving model performance](img/B04714_03_22.jpg)

下一步是通过使用闵可夫斯基距离方法进行训练来改进模型。第一步是计算距离矩阵。使用`dist()` 功能。

闵可夫斯基距离通常用于在绝对零值的比率尺度上测量变量的情况。

```
 > library(fpc)
 > NASAtrans=t(NASAscale)

```

下一步是使用 Ward 的方法进行聚类。使用`hclust()`功能。

调用`clust1`函数会显示所使用的聚集方法、计算距离的方式以及对象的数量。结果如下:

```
 > dist1 <- dist(NASAtrans, method="minkowski", p=3) 

```

The next step is to perform clustering using Ward's method. The `hclust()` function is used.

```
 > clust1 <- hclust(dist1,method="ward.D")
 > clust1

```

The call to the `clust1` function results in display of the agglomeration method used, the manner in which the distance is calculated, and the number of objects. The results are as follows:

`plot()`函数是绘图 R 对象的通用函数。这里使用`plot()`函数绘制树状图:

![Step 6 - improving model performance](img/image_03_023.jpg)

结果如下:

The `plot()` function is a generic function for the plotting R objects. Here, the `plot()` function is used to draw the dendrogram:

```
> plot(clust1,labels= NASA.lab[1:29], cex=1, xlab="",ylab="Distance",main="Clustering for NASA Understory Data")

```

The result is as follows:

`rect.hclust()`函数应在树状图的分支周围绘制矩形，突出显示相应的聚类。首先，在一定层次上切割树状图，然后在选定的分支周围绘制一个矩形。

![Step 6 - improving model performance](img/image_03_024.jpg)

`clust1`对象作为一个对象与要形成的集群数量一起传递给函数:

结果如下:

The `clust1` object is passed as an object to the function along with the number of clusters to be formed:

```
> rect.hclust(clust1,k=3)

```

The result is as follows:

`cuts()`功能应根据所需的组数或切割高度将树切割成多组。这里，`clust1`作为一个对象与所需组的编号一起传递给函数:

![Step 6 - improving model performance](img/image_03_025.jpg)

结果如下:

The `cuts()` function shall cut the tree into multiple groups on the basis of the desired number of groups or the cut height. Here, `clust1` is passed as an object to the function along with the number of the desired group:

```
 > cuts=cutree(clust1,k=3)
 > cuts

```

The result is as follows:

层次聚类-基因聚类

![Step 6 - improving model performance](img/image_03_026.jpg)

收集全基因组表达数据的能力是一项计算复杂的任务。人脑有其局限性，无法解决这个问题。然而，通过将基因细分为更小数量的类别，然后对其进行分析，可以将数据细化到易于理解的水平。



# 聚类的目标是细分一组基因，使得相似的项目属于同一类，而不相似的项目属于不同的类。要考虑的重要问题是关于已经被聚类的项目的相似性和用途的决策。在这里，我们将探索聚类基因和样本使用光感受器时间序列的两种基因型。

做好准备

为了执行层次聚类，我们将使用在小鼠身上收集的数据集。

## 步骤 1 -收集和描述数据

应使用名为`GSE4051_data`和`GSE4051_design`的数据集。这些文件以 CSV 格式提供，标题为`GSE4051_data.csv`和`GSE4051_design.csv`。数据集采用标准格式。

### 在`GSE4051_data`中有 29949 行数据和 39 个变量。数字变量包括:

`Sample_21`

`Sample_22`

*   `Sample_23`
*   `Sample_16`
*   `Sample_17`
*   `Sample_6`
*   `Sample_24`
*   `Sample_25`
*   `Sample_26`
*   `Sample_27`
*   `Sample_14`
*   `Sample_3`
*   `Sample_5`
*   `Sample_8`
*   `Sample_28`
*   `Sample_29`
*   `Sample_30`
*   `Sample_31`
*   `Sample_1`
*   `Sample_10`
*   `Sample_4`
*   `Sample_7`
*   `Sample_32`
*   `Sample_33`
*   `Sample_34`
*   `Sample_35`
*   `Sample_13`
*   `Sample_15`
*   `Sample_18`
*   `Sample_19`
*   `Sample_36`
*   `Sample_37`
*   `Sample_38`
*   `Sample_39`
*   `Sample_11`
*   `Sample_12`
*   `Sample_2`
*   `Sample_9`
*   在`GSE4051_design`数据集中有 39 行数据和 4 个变量。数值变量是:
*   `sidNum`

非数字变量包括:

*   `sidChar`

`devStage`

*   `gType`
*   如何做到这一点...
*   让我们进入细节。

## 第二步——探索数据

注

### 版本信息:此页面的代码在 R 版本 3.2.3 中进行了测试(2015-12-10)

### `RColorBrewer`包是来自[http://colorbrewer2.org](http://colorbrewer2.org)的 R 包，为地图和其他图形提供配色方案。

`pvclust`软件包用于评估层次聚类分析中的不确定性。在等级聚类中，每个聚类通过多尺度引导重采样计算 p 值。聚类的 p 值介于 0 和 1 之间。可用的 p 值有两种:**近似** **无偏** ( **AU** )和 **bootstrap 概率** ( **BP** )值。使用多尺度自助重采样方法计算 AU p 值，而使用普通自助重采样方法计算 BP p 值。与 BP p 值相比，AU p 值具有优势偏差。

LaTeX 格式的表格由`xtable`包生成。使用`xtable`，特定于包的 R 对象可以变成`xtables`。这些`xtables`可以以 LaTeX 或 HTML 格式输出。

`plyr`包用作执行**分割-应用-组合** ( **SAC** )程序的工具。它将一个大问题分解成可管理的部分，对每一部分进行操作，然后将所有部分重新组合在一起。

必须加载以下软件包:

让我们探索数据，了解变量之间的关系。我们将从导入名为`GSE4051_data.csv`的 CSV 文件开始。我们将把数据保存到`GSE4051_data`数据框中:

接下来，我们将打印关于`GSE4051_data`数据帧的信息。`str()`函数返回所提供的关于`GSE4051_data`数据帧结构的信息。它简洁地显示了`GSE4051_data`数据框的内部结构。`max.level`表示应用于显示嵌套结构的最大嵌套级别:

```
 > library(RColorBrewer)
 > library(cluster)
 > library(pvclust)
 > library(xtable)
 > library(plyr)

```

结果如下:

```
> GSE4051_data =read.csv("d:/ GSE4051_data.csv",header=T)

```

Next, we shall print information about the `GSE4051_data` data frame. The `str()` function returns the provided information about the structure of the `GSE4051_data` data frame. It compactly displays the internal structure of the `GSE4051_data` data frame. `max.level` indicates the maximal level of nesting applied to display nested structures:

```
> str(GSE4051_data, max.level = 0) 

```

The result is as follows:

接下来，我们将导入名为`GSE4051_design.csv`的 CSV 文件。我们将把数据保存到`GSE4051_design`数据框:

![Step 2 - exploring data](img/image_03_027.jpg)

前面一行打印了`GSE4051_design`数据帧的内部结构。

结果如下:

```
> GSE4051_design =read.csv("d:/ GSE4051_design.csv",header=T)

```

The preceding line prints the internal structure of the `GSE4051_design` data frame.

The result is as follows:

步骤 3 -转换数据

![Step 2 - exploring data](img/image_03_028.jpg)

为了便于以后的可视化，对行进行了重新缩放。由于基因之间的表达存在绝对差异，因此需要对行进行重新标度。

### 将变量居中和创建 z 值是两种常见的数据分析活动。`scale`函数将数值矩阵的列居中和/或缩放。

转置矩阵。`GSE4051_data`数据帧被传递用于数据帧的转置:

接下来，我们将打印关于`GSE4051_data`数据框的信息。使用`give.attr = FALSE`，不显示作为子结构的属性。

结果如下:

```
> trans_GSE4051_data <- t(scale(t(GSE4051_data)))

```

Next, we shall print information about the `GSE4051_data` data frame. With `give.attr = FALSE`, attributes as sub structures are not displayed.

```
> str(trans_GSE4051_data, max.level = 0, give.attr = FALSE)

```

The result is as follows:

`head()`函数返回向量、矩阵、表格、数据框或函数的第一部分。`GSE4051_data`和`trans_GSE4051_data`数据帧作为对象传递。`rowMeans()`函数计算行的平均值。`data.frame()`函数创建的数据框是紧密耦合的变量集合，并共享矩阵的许多属性:

![Step 3 - transforming data](img/image_03_029.jpg)

结果如下:

The `head()` function returns the first part of a vector, matrix, table, data frame, or function. The `GSE4051_data` and `trans_GSE4051_data` data frames are passed as objects. The `rowMeans()` function calculates the means of rows. The `data.frame()` function creates data frames that are tightly coupled collections of variables and share many of the properties of matrices:

```
 > round(data.frame(avgBefore = rowMeans(head(GSE4051_data)), 
avgAfter = rowMeans(head(trans_GSE4051_data)), 
varBefore = apply(head(GSE4051_data), 1, var), 
                      varAfter = apply(head(trans_GSE4051_data),                      1, var)), 2)

```

The result is as follows:

第四步——训练模型

![Step 3 - transforming data](img/image_03_030.jpg)

下一步是训练模型。第一步是计算距离矩阵。使用`dist()`功能。该函数计算并返回距离矩阵，使用指定的距离度量来计算数据矩阵各行之间的距离。使用的距离度量可以是欧几里德、最大值、曼哈顿、堪培拉、二进制或闵可夫斯基。使用的距离度量是欧几里德距离。欧几里德距离将两个向量之间的距离计算为 *sqrt(sum((x_i - y_i)^2))* 。转置的`trans_GSE4051_data`数据帧用于计算距离。然后将结果存储在`pair_dist_GSE4051_data`数据帧中。

### 接下来，使用`interaction()`函数，它通过`gType`、`devStage`变量的交互来计算并返回一个无序因子。无序因素的结果与数据帧`GSE4051_design`一起传递给`with()`函数。这产生了一个新的因素，代表`gType`、`devStage`变量的相互作用:

`summary()`功能用于产生数据帧`GSE4051_design$group`的结果汇总:

```
> pair_dist_GSE4051_data <- dist(t(trans_GSE4051_data), method = 'euclidean')

```

结果如下:

```
> GSE4051_design$group <- with(GSE4051_design, interaction(gType, devStage))

```

The `summary()` function is used to produce result summaries of the data frame, `GSE4051_design$group`:

```
> summary(GSE4051_design$group)

```

The result is as follows:

接下来，使用各种链接类型进行分级聚类的计算。

![Step 4 - training the model](img/image_03_031.jpg)

使用`hclust()`功能。为了对一组不相似的 *n 个*对象进行聚类分析，使用了`hclust()`函数。在第一阶段，每个对象都被分配到它自己的簇中。然后，该算法在每个阶段迭代进行，加入两个最相似的聚类。这个过程一直持续到只剩下一个集群。`hclust()`功能要求我们以距离矩阵的形式提供数据。`pair_dist_GSE4051_data`数据帧通过。

聚合法`single`被用作第一种情况:

调用`pr.hc.single`会显示所使用的聚集方法、计算距离的方式以及对象的数量:

结果如下:

```
> pr.hc.single <- hclust(pair_dist_GSE4051_data, method = 'single')

```

The call to `pr.hc.single` results in display of the agglomeration method used, the manner in which the distance is calculated and the number of objects:

```
> pr.hc.single

```

The result is as follows:

凝聚法，`complete`用于第二种情况:

![Step 4 - training the model](img/image_03_032.jpg)

调用`pr.hc.complete`会显示所使用的聚集方法、计算距离的方式以及对象的数量:

结果如下:

```
> pr.hc.complete <- hclust(pair_dist_GSE4051_data, method = 'complete')

```

The call to `pr.hc.complete` results in display of the agglomeration method used, the manner in which the distance is calculated and the number of objects:

```
> pr.hc.complete

```

The result is as follows:

结块方法`average`用作第三种情况:

![Step 4 - training the model](img/image_03_033.jpg)

调用`pr.hc.average`会显示所使用的聚集方法、计算距离的方式以及对象的数量:

结果如下:

```
> pr.hc.average <- hclust(pair_dist_GSE4051_data, method = 'average')

```

The call to `pr.hc.average` results in display of the agglomeration method used, the manner in which the distance is calculated, and the number of objects:

```
> pr.hc.average

```

The result is as follows:

凝聚法沃德被用作第四种情况:

![Step 4 - training the model](img/image_03_034.jpg)

对`pr.hc.ward`的调用导致显示所使用的聚集方法、计算距离的方式以及对象的数量:

结果如下:

```
> pr.hc.ward <- hclust(pair_dist_GSE4051_data, method = 'ward.D2')

```

The call to `pr.hc.ward` results in display of the agglomeration method used, the manner in which the distance is calculated, and the number of objects:

```
> pr.hc.ward

```

The result is as follows:

`plot()`功能是用于绘制 R 对象的通用功能。

![Step 4 - training the model](img/image_03_035.jpg)

对`plot()`函数的第一次调用将`pr.hc.single`数据帧作为对象传递:

```
> op <- par(mar = c(0,4,4,2), mfrow = c(2,2))

```

结果如下:

The first call to the `plot()` function passes the `pr.hc.single` data frame as an object:

```
> plot(pr.hc.single, labels = FALSE, main = "Single Linkage Representation", xlab = "")

```

The result is as follows:

对`plot()`函数的第二次调用将`pr.hc.complete`数据帧作为对象传递:

![Step 4 - training the model](img/image_03_036.jpg)

结果如下:

The second call to the `plot()` function passes the `pr.hc.complete` data frame as an object:

```
> plot(pr.hc.complete, labels = FALSE, main = "Complete Linkage Representation", xlab = "")

```

The result is as follows:

对`plot()`函数的第三次调用将`pr.hc.average`数据帧作为对象传递:

![Step 4 - training the model](img/image_03_037.jpg)

结果如下:

The third call to the `plot()` function passes the `pr.hc.average` data frame as an object:

```
> plot(pr.hc.average, labels = FALSE, main = "Average Linkage Representation", xlab = "")

```

The result is as follows:

对`plot()`函数的第四次调用将`pr.hc.ward`数据帧作为对象传递:

![Step 4 - training the model](img/image_03_038.jpg)

结果如下:

The fourth call to the `plot()` function passes the `pr.hc.ward` data frame as an object:

```
> plot(pr.hc.ward, labels = FALSE, main = "Ward Linkage Representation", xlab = "")

```

The result is as follows:

步骤 5 -绘制模型

![Step 4 - training the model](img/image_03_039.jpg)

`plot()`功能是标绘 R 对象的通用功能。这里，`plot()`函数用于绘制树状图。

```
 > par(op)
 > op <- par(mar = c(1,4,4,1))

```

### `rect.hclust()` 函数应在树状图的分支周围绘制矩形，突出显示相应的聚类。首先在某一层切割树状图，然后在选定的分支周围画一个矩形。

`RColorBrewer`使用来自[http://colorbrewer2.org/](http://colorbrewer2.org/)的作品为 r 中的人物选择合理的配色方案

颜色分为三组:

顺序:低数据光颜色；高数据-深色

发散:中档数据-浅色；低量程和高量程数据-对比深色

*   定性:颜色被设计用来突出不同类别之间最大的视觉差异
*   `RColorBrewer`的重要功能之一就是`brewer.pal()`。该函数允许用户通过传递颜色数量和调色板名称从`display.brewer.all()`函数中进行选择。
*   作为第一种情况，`pr.hc.single`作为对象被传递给`plot()`函数:

结果如下:

As a first case, `pr.hc.single` is passed as an object to the `plot()` function:

```
 > plot(pr.hc.single, labels = GSE4051_design$group, cex = 0.6, main = "Single Hierarchical Cluster - 10 clusters")
 > rect.hclust(clust1,k=5)

```

The result is as follows:

接下来，我们使用`single`聚集方法创建热图。默认情况下，`heatmap()`功能使用聚集方法`euclidean`:

![Step 5 - plotting the model](img/image_03_040.jpg)

结果如下:

Next, we create the heat maps using the `single` agglomeration method. By default, the `heatmap()` function uses the agglomeration method `euclidean`:

```
     > par(op)
     > jGraysFun <- colorRampPalette(brewer.pal(n = 9, "Blues"))
     > gTypeCols <- brewer.pal(9, "Spectral")[c(4,7)]
     > heatmap(as.matrix(trans_GSE4051_data), Rowv = NA, col = jGraysFun(256), hclustfun = function(x) hclust(x, method = 'single'),
scale = "none", labCol = GSE4051_design$group, labRow = NA, margins = c(8,1), 
 ColSideColor = gTypeCols[unclass(GSE4051_design$gType)])
     > legend("topright", legend = levels(GSE4051_design$gType), col = gTypeCols, lty = 1, lwd = 5, cex = 0.5)

```

The result is as follows:

作为第二种情况，`pr.hc.complete`作为对象传递给`plot()`函数:

![Step 5 - plotting the model](img/image_03_041.jpg)

结果如下:

As a second case, `pr.hc.complete` is passed as an object to the `plot()` function:

```
 > plot(pr.hc.complete, labels = GSE4051_design$group, cex = 0.6, main = "Complete Hierarchical Cluster - 10 clusters")
 > rect.hclust(pr.hc.complete, k = 10)

```

The result is as follows:

接下来，我们使用`complete`聚集方法创建热图。

![Step 5 - plotting the model](img/image_03_042.jpg)

结果如下:

Next we create heat maps using the `complete` agglomeration method.

```
    > par(op)
    > jGraysFun <- colorRampPalette(brewer.pal(n = 9, "Greens"))
    > gTypeCols <- brewer.pal(11, "PRGn")[c(4,7)]
> heatmap(as.matrix(trans_GSE4051_data), Rowv = NA, col = jGraysFun(256), hclustfun = function(x) hclust(x, method = 'complete'), 
 scale = "none", labCol = GSE4051_design$group, labRow = NA, margins = c(8,1),
 ColSideColor = gTypeCols[unclass(GSE4051_design$gType)])
    > legend("topright", legend = levels(GSE4051_design$gType), col = gTypeCols, lty = 1, lwd = 5, cex = 0.5)

```

The result is as follows:

作为第三种情况，`pr.hc.average`作为对象传递给`plot()` 函数:

![Step 5 - plotting the model](img/image_03_043.jpg)

结果如下:

As a third case, `pr.hc.average` is passed as an object to the `plot()` function:

```
 > plot(pr.hc.average, labels = GSE4051_design$group, cex = 0.6, main = "Average Hierarchical Cluster - 10 clusters")
 > rect.hclust(pr.hc.average, k = 10)

```

The result is as follows:

接下来，我们使用`average`聚集方法创建热图:

![Step 5 - plotting the model](img/image_03_044.jpg)

结果如下:

Next, we create heat maps using the `average` agglomeration method:

```
    > jGraysFun <- colorRampPalette(brewer.pal(n = 9, "Oranges"))
    > gTypeCols <- brewer.pal(9, "Oranges")[c(4,7)]
> heatmap(as.matrix(trans_GSE4051_data), Rowv = NA, col = jGraysFun(256), hclustfun = function(x) hclust(x, method = 'average'), 
scale = "none", labCol = GSE4051_design$group, labRow = NA, margins = c(8,1), 
 ColSideColor = gTypeCols[unclass(GSE4051_design$gType)])
    > legend("topright", legend = levels(GSE4051_design$gType), col = gTypeCols, lty = 1, lwd = 5, cex = 0.5)

```

The result is as follows:

作为第四种情况，`pr.hc.ward`作为对象传递给`plot()`函数:

![Step 5 - plotting the model](img/image_03_045.jpg)

结果如下:

As a fourth case, `pr.hc.ward` is passed as an object to the `plot()` function:

```
 > plot(pr.hc.ward, labels = GSE4051_design$group, cex = 0.6, main = "Ward Hierarchical Cluster - 10 clusters")
 > rect.hclust(pr.hc.ward, k = 10)

```

The result is as follows:

接下来，我们使用`ward`聚集方法创建热图:

![Step 5 - plotting the model](img/image_03_046.jpg)

结果如下:

Next, we create heat maps using the `ward` agglomeration method:

```
 > jGraysFun <- colorRampPalette(brewer.pal(n = 9, "Reds")) 
 > gTypeCols <- brewer.pal(9, "Reds")[c(4,7)] 
 > heatmap(as.matrix(trans_GSE4051_data), Rowv = NA, col = jGraysFun(256), hclustfun = function(x) hclust(x, method = 'ward.D2'), 
 scale = "none", labCol = GSE4051_design$group, labRow = NA, margins = c(8,1), 
 ColSideColor = gTypeCols[unclass(GSE4051_design$gType)]) 
 > legend("topright", legend = levels(GSE4051_design$gType), col = gTypeCols, lty = 1, lwd = 5, cex = 0.5)

```

The result is as follows:

二元聚类-数学测试

![Step 5 - plotting the model](img/image_03_047.jpg)

在教育系统中，测验和考试是主要特征。考试制度的好处是，它可以成为区分表现好与差的方法之一。考试制度让学生有责任升级到下一个标准，他们应该出现并通过考试。学生有责任定期学习。考试制度为学生迎接未来的挑战做准备。它帮助他们分析原因，并在固定的时间段内有效地交流他们的想法。另一方面，很少有人注意到这种倒退，比如学习速度慢的学生不能在考试中表现良好，这在学生中造成了较差的复杂性。



# 准备就绪

为了执行二元聚类，我们将使用在数学测试中收集的数据集。

## 步骤 1 -收集和描述数据

应使用名为`math test`的数据集。这在标题为`math test.txt`的 TXT 格式中可用。数据集采用标准格式。有 60 行数据。有 60 列。这些列是 55 名男学生的分数。

### 怎么做...

让我们进入细节。

## 第 2 步-探索数据

注意

### 版本信息:此页面的代码在 R 版本 3.2.3 中进行了测试(2015-12-10)

### 让我们探索数据，了解变量之间的关系。我们将从导入名为`ACT math test.txt`的 TXT 文件开始。我们将把数据保存到`Mathtest`数据框中:

步骤 3 -训练和评估模型性能

接下来，我们将执行项目的聚类。基于学生分数的项目组将被聚集在一起。

```
> Mathtest = read.table("d:/math test.txt",header=T)

```

### 首先，我们将根据平方欧几里德距离计算总的不匹配。

调用了`dist()`函数。`Mathtest`数据帧作为输入被传递给`dist()`功能。基于平方欧几里得距离计算总不匹配，结果应存储在`dist.items`数据帧中:

接下来，我们将打印`dist.items`数据帧。

结果如下:

```
> dist.items <- dist(Mathtest[,-1], method='euclidean')^2

```

Next, we shall print the `dist.items` data frame.

```
> dist.items

```

The result is as follows:

接下来，距离度量完全忽略`0-0`匹配。在`dist()`函数中应使用二进制方法。在二进制方法中，非零元素打开，零元素关闭，因为向量被认为是二进制位。

![Step 3 - training and evaluating model performance](img/image_03_048.jpg)

接下来，我们将打印数据帧`dist.items.2`，以观察结果。

结果如下:

```
> dist.items.2 <- dist(Mathtest[,-1], method='binary')

```

接下来，距离度量完全忽略`1-1`匹配。在`dist()`函数中应使用二进制方法。在二进制方法中，非零元素打开，零元素关闭，因为向量被认为是二进制位。

接下来，我们将打印数据帧`dist.items.3`，以观察结果。

结果如下:

![Step 3 - training and evaluating model performance](img/image_03_049.jpg)

Next, the distance measure ignores `1-1` matches altogether. The binary method shall be used in the `dist()` function. In the binary method, the non-zero elements are on and zero-elements are off since the vectors are considered binary bits.

```
> dist.items.3 <- dist(1 - Mathtest[,-1], method='binary')

```

下一步是使用`complete`方法执行聚类。使用了`hclust()`功能。为了对 *n* 个对象的一组相异点进行聚类分析，使用了`hclust()`函数。在第一阶段，每个对象都被分配到它自己的簇中。然后，该算法在每个阶段迭代进行，加入两个最相似的聚类。这个过程一直持续到只剩下一个集群。`hclust()`功能要求我们以距离矩阵的形式提供数据。`dist1`数据帧通过。默认情况下，使用完全链接方法。可以使用多种凝聚方法，其中一些可以是`ward.D`、`ward.D2`、`single`、`complete`或`average`。

使用的方法是完整的。使用 complete 方法时，所形成的群集在群集中的任何对象与其他对象之间具有最大距离:

调用`items.complete.link`函数会显示所使用的聚集方法、计算距离的方式以及对象的数量。结果如下:

![Step 3 - training and evaluating model performance](img/image_03_050.jpg)

The next step is to perform clustering using the `complete` method. The `hclust()` function is used. In order to perform cluster analysis on a set of dissimilarities for *n* objects, the `hclust()` function is used. At the first stage, each of the objects is assigned to its own cluster. The algorithm then proceeds iteratively at each stage joining the two most similar clusters. This process continues till there is just a single cluster left. The `hclust()` function requires us to provide the data in the form of a distance matrix. The `dist1` data frame is passed. By default, the complete linkage method is used. There can be multiple agglomeration methods which can be used, some of them could be `ward.D`, `ward.D2`, `single`, `complete`, or `average`.

步骤 4 -绘制模型

```
 > items.complete.link <- hclust(dist.items, method='complete')
 > items.complete.link

```

`plot()`函数是绘图 R 对象的通用函数。这里使用`plot()`功能绘制完整的连锁树状图。

完全链接用于层次聚类，并确保两个聚类之间的距离是最大距离。当使用完全链接时，在算法的每一步，两个最近的聚类被合并在一起。重复该过程，直到整个数据集合并到单个聚类中:

![Step 3 - training and evaluating model performance](img/image_03_051.jpg)

结果如下:

### Step 4 - plotting the model

The `plot()` function is a generic function for the plotting R objects. Here, the `plot()` function is used to plot the complete linkage dendrogram.

接下来，我们将在树状图上执行单个链接。在单链接层次聚类中，根据到其他对象的最小距离或聚类之间的最小成对距离，将每个步骤合并为两个聚类:

```
> plot(items.complete.link, labels=Mathtest[,1], ylab="Distance")

```

调用`items.sing.link`函数会显示所使用的聚集方法、计算距离的方式以及对象的数量。结果如下:

这里，`plot()`函数用于绘制完整的连锁树状图。`items.sing.link`作为数据帧传递:

![Step 4 - plotting the model](img/image_03_052.jpg)

结果如下:

Next, we shall be performing single linkage on the dendrogram. In single linkage hierarchical clustering, each step is merged into two clusters based on the smallest distance to other objects, or the smallest minimum pairwise distance between the clusters:

```
 > items.sing.link <- hclust(dist.items, method='single')
 > items.sing.link

```

The call to the `items.sing.link` function results in display of the agglomeration method used, the manner in which the distance is calculated, and the number of objects. The results are as follows:

步骤 5 - K-medoids 聚类

![Step 4 - plotting the model](img/image_03_053.jpg)

正在加载`cluster()`库:

为了计算平均轮廓宽度，我们编写了一个函数。

```
> plot(items.sing.link, labels=Mathtest[,1], ylab="Distance")

```

剪影指的是一种用于解释和验证数据簇内一致性的方法。为了提供对象在集群中的位置，该技术使用图形表示。的轮廓范围介于-1 和 1 之间，1 表示最高匹配度，而-1 表示对象与其自身聚类的最低匹配度。在一个集群中，如果大多数对象具有较高的值，例如接近 1，则集群配置是合适的。

`rep()`是一个通用函数，用于复制`my.k.choices`的值。结果存储在数据帧`avg.sil.width`中:

![Step 4 - plotting the model](img/image_03_054.jpg)

**PAM** 代表**围绕 Medoids** 分区。PAM 要求知道所需聚类的数量(如 k-means 聚类)，但它比 k-means 做更多的计算，以确保它找到的 medoids 真正代表给定聚类内的观察值。

### 打印计算出轮廓值的选择值。

结果如下:

```
> library(cluster)

```

In order to calculate the average silhouette width, we write a function.

Silhouette refers to a method for interpreting and validating consistency within clusters of data. In order to provide the position of the object in the cluster, the technique uses graphical representation. The silhouette range of is between -1 and 1, with 1 indicating the highest match and -1 indicating the poorest match of the object to its own cluster. In a cluster, if most of the objects have a high value, for instance closer to 1, the clustering configuration is appropriate.

```
> my.k.choices <- 2:8

```

基于两个聚类执行聚类:

```
> avg.sil.width <- rep(0, times=length(my.k.choices))

```

结果如下:

```
 > for (ii in (1:length(my.k.choices)) ){
 + avg.sil.width[ii] <- pam(dist.items, k=my.k.choices[ii])$silinfo$avg.width
 + }

```

Printing the value of choices with silhouette values calculated.

```
> print( cbind(my.k.choices, avg.sil.width) )

```

The result is as follows:

`lapply()`函数返回一个长度与 X 相同的列表，其中的每个元素都是将`FUN`应用于 X 的相应元素的结果:

![Step 5 - K-medoids clustering](img/image_03_055.jpg)

结果如下:

Performing clustering on the basis of 2 clusters:

```
 > items.kmed.2 <- pam(dist.items, k=2, diss=T)
 > items.kmed.2

```

The result is as follows:

在 3 个聚类的基础上执行聚类。

![Step 5 - K-medoids clustering](img/image_03_056.jpg)

结果如下:

The `lapply()` function returns a list of the same length as X, each element of which is the result of applying `FUN` to the corresponding element of X:

```
 > items.2.clust <- lapply(1:2, function(nc) Mathtest[,1][items.kmed.2$clustering==nc]) 
 > items.2.clust

```

The result is as follows:

结果如下:

![Step 5 - K-medoids clustering](img/image_03_057.jpg)

Performing clustering on the basis of 3 clusters.

```
 > items.kmed.3 <- pam(dist.items, k=3, diss=T)
 > items.kmed.3

```

K-均值聚类-欧洲国家蛋白质消费

在医学和营养学领域，食物消费模式引起了极大的兴趣。食物消费与个人的整体健康状况、食物的营养价值、购买食物的经济因素以及食物消费的环境相关。这项分析涉及 25 个欧洲国家的肉类和其他食品之间的关系。观察肉类和其他食物之间的相关性是很有趣的。这些数据包括红肉、白肉、鸡蛋、牛奶、鱼、谷类、淀粉类食物、坚果(包括豆类和油籽)、水果和蔬菜。

![Step 5 - K-medoids clustering](img/image_03_058.jpg)

准备就绪

```
 > items.3.clust <- lapply(1:3, function(nc) Mathtest[,1][items.kmed.3$clustering==nc])
 > items.3.clust

```

为了执行 K-means 聚类，我们将使用 25 个欧洲国家的蛋白质消费数据集。

步骤 1 -收集和描述数据

![Step 5 - K-medoids clustering](img/image_03_059.jpg)

应使用 CSV 格式的名为`protein`的数据集。数据集采用标准格式。有 25 行数据和 10 个变量。



# 数字变量包括:

`RedMeat`

## `WhiteMeat`

`Eggs`

### `Milk`

`Fish`

`Cereals`

*   `Starch`
*   `Nuts`
*   `Fr&Veg`
*   非数字变量是:
*   `Country`
*   怎么做...
*   让我们进入细节。
*   第 2 步-探索数据
*   注意

版本信息:此页面的代码在 R 版本 3.2.3 中进行了测试(2015-12-10)

*   让我们探索数据，了解变量之间的关系。我们将从导入名为`protein.csv`的 CSV 文件开始。我们将把数据保存到`protein`数据框:

## `head()`返回向量、矩阵、表格、数据框或函数的第一部分或最后一部分。`protein`数据帧被传递给`head()` 功能。

结果如下:

### Step 2 - exploring data

### Note

第三步-聚类

在三个集群的基础上开始集群。

```
> protein = read.csv("d:/Europenaprotein.csv",header=T)

```

为了在初始阶段找到随机数量的簇，调用`set.seed()`函数。`set.seed()`功能产生随机数:

```
> head(protein)

```

`kmeans()`函数应对数据矩阵进行 K 均值聚类。`protein`数据矩阵作为一个对象传递，该对象可以被强制转换为数据的数字矩阵。`centers=3`表示初始(不同)聚类中心的数量。由于聚类的数量由一个数字表示，`nstart=10`定义了要选择的随机集的数量:

结果如下:

![Step 2 - exploring data](img/image_03_060.jpg)

### Step 3 - clustering

接下来，列出集群分配。`order()`函数返回一个排列，它按照升序或降序重新排列第一个参数。数据帧`groupMeat`作为数据帧对象传递:

调用`data.frame()`函数会显示国家及其所在的集群:

```
> set.seed(123456789)

```

结果如下:

```
 > groupMeat <- kmeans(protein[,c("WhiteMeat","RedMeat")], centers=3, nstart=10)
 > groupMeat

```

The result is as follows:

![Step 3 - clustering](img/image_03_061.jpg)

`plot()`功能是标绘 R 对象的通用功能。参数类型表示要绘制的绘图类型。`xlim` 参数意味着参数应该给出范围的极值，而不是一个范围。`xlab`和`ylab`分别为 *x-* 轴和 *y-* 轴提供标题；

结果如下:

```
> o=order(groupMeat$cluster)

```

The call to the `data.frame()` function results in displaying the countries and the clusters in which they are placed:

```
> data.frame(protein$Country[o],groupMeat$cluster[o])

```

The result is as follows:

第 4 步-改进模型

![Step 3 - clustering](img/image_03_062.jpg)

接下来，对所有九个蛋白质组进行聚类，并创建七个聚类。白肉和红肉的彩色散点图有密切的关系。地理位置相近的国家往往聚集在同一组。

`set.seed()`函数产生随机数:

```
 > plot(protein$Red, protein$White, type="n", xlim=c(3,19), xlab="Red Meat", ylab="White Meat")
 > text(x=protein$Red, y=protein$White, labels=protein$Country,col=groupMeat$cluster+1)

```

`centers=7`表示初始(不同)聚类中心的数量:

形成了七个不同的集群。这 25 个国家中的每一个都被归入其中一组。

![Step 3 - clustering](img/image_03_063.jpg)

结果如下:

### Step 4 - improving the model

Next, clustering on all the nine protein groups takes place and seven clusters are created. There is a close significance between the colored scatter-plot for white meat against red meat. Countries in close geographic proximity tend to be clustered into the same group.

`clustplot()`函数创建了一个二元图，可以可视化为数据的一个分区(聚类)。所有的观察值都用主成分图中的点来表示。围绕每个聚类，绘制一个椭圆。数据帧，蛋白质作为对象传递:

```
> set.seed(123456789)

```

结果如下:

```
 > groupProtein <- kmeans(protein[,-1], centers=7, nstart=10)
 > o=order(groupProtein$cluster)
 > data.frame(protein$Country[o],groupProtein$cluster[o])

```

Seven different clusters are formed. Each of the 25 countries is placed in one of the clusters.

The result is as follows:

另一种方法是以分层的形式来查看它。使用`agnes()`功能。通过输入`diss=FALSE`，相异矩阵用于从原始数据计算。`metric="euclidean`"表示使用欧几里德距离度量:

![Step 4 - improving the model](img/image_03_064.jpg)

结果如下:

```
 > library(cluster)

```

The `clustplot()` function creates a bivariate plot that can be visualized as a partition (clustering) of the data. All observations are represented by points in the plot, using principal components. Around each cluster, an ellipse is drawn. The data frame, protein is passed as an object:

```
> clusplot(protein[,-1], groupProtein$cluster, main='2D representation of the Cluster solution', color=TRUE, shade=TRUE, labels=2, lines=0)

```

The result is as follows:

结果如下:

![Step 4 - improving the model](img/image_03_065.jpg)

Another approach is to view it in hierarchical form. The `agnes()` function is used. By putting `diss=FALSE`, the dissimilarity matrix is used for calculating from raw data. `metric="euclidean`" indicates the use of the Euclidean distance measure:

```
 > foodagg=agnes(protein,diss=FALSE,metric="euclidean")
 > foodagg

```

`cutree()`功能通过指定所需的组数或切割高度，将一棵树切割成若干组:

![Step 4 - improving the model](img/image_03_066.jpg)

```
> plot(foodagg, main='Dendrogram')

```

结果如下:

![Step 4 - improving the model](img/image_03_067.jpg)

K-均值聚类-食品

```
> groups <- cutree(foodagg, k=4)

```

我们摄入的食物中的营养成分可以根据它们在增加身体质量中的作用来分类。这些营养素可以分为常量营养素或必需微量营养素。大量营养素的一些例子是碳水化合物、蛋白质和脂肪，而必需微量营养素的一些例子是维生素、矿物质和水。

![Step 4 - improving the model](img/image_03_068.jpg)

做好准备

```
> rect.hclust(foodagg, k=4, border="red")

```

让我们从食谱开始吧。

步骤 1 -收集和描述数据

![Step 4 - improving the model](img/image_03_069.jpg)

为了执行 K-means 聚类，我们将使用在各种食物项目及其各自的`Energy`、`Protein`、`Fat`、`Calcium`和`Iron`内容上收集的数据集。数字变量包括:



# `Energy`

`Protein`

## `Fat`

`Calcium`

### `Iron`

非数字变量是:

*   `Food`
*   怎么做...
*   让我们进入细节。
*   第 2 步-探索数据
*   注

版本信息:此页面的代码在 R 版本 3.2.3 (2015-12-10)中进行了测试。

*   加载`cluster()`库。

## 让我们探索数据，了解变量之间的关系。我们将从导入名为`foodstuffs.txt`的文本文件开始。我们将把数据保存到`food.energycontent`数据框中:

`head()` 返回向量、矩阵、表格、数据框或函数的第一部分或最后一部分。`food.energycontent`数据帧被传递给`head()`函数:

### 结果如下:

### Note

Version info: Code for this page was tested in R version 3.2.3 (2015-12-10).

`str()`函数返回所提供的关于`food.energycontent`数据帧结构的信息。它紧凑地显示了内部结构:

```
> library(cluster)

```

结果如下:

```
> food.energycontent <- read.table("d:/foodstuffs.txt", header=T)

```

The `head()` returns the first or last parts of a vector, matrix, table, data frame, or function. The `food.energycontent` data frame is passed to the `head()` function:

```
> head(food.energycontent) 

```

The result is as follows:

步骤 3 -转换数据

![Step 2 - exploring data](img/image_03_070.jpg)

`apply()`函数对数据帧和矩阵进行逐项修改。它返回通过对数组或矩阵的边距应用函数而获得的向量、数组或值列表。2 表示将应用该函数的列下标。`sd`为标准差函数，应用于数据帧:

结果如下:

```
> str(food.energycontent)

```

The result is as follows:

![Step 2 - exploring data](img/image_03_071.jpg)

`sweep()`函数通过清除汇总统计数据返回从输入数组获得的数组。`food.energycontent[,-1]`作为数组传递。2 表示将应用该函数的列下标。`standard.deviation`是要被扫出的汇总统计:

### 结果如下:

The `apply()` function carries out entry-by-entry changes to data frames and matrices. It returns a vector, array, or list of values obtained by applying a function to margins of an array or matrix. 2 indicates column subscripts the function will be applied over. `sd` is for standard deviation function, which is to be applied on the data frame:

```
 > standard.deviation <- apply(food.energycontent[,-1], 2, sd)
 > standard.deviation

```

The result is as follows:

第四步——聚类

![Step 3 - transforming data](img/image_03_072.jpg)

`kmeans()`函数应对数据矩阵进行 K-means 聚类。数据矩阵`foodergycnt.stddev`作为一个对象被传递，该对象可以被强制为数据的数字矩阵。`centers=5`表示初始(不同)聚类中心的数量。`iter.max=100`表示允许的最大迭代次数。由于聚类的数量由一个数字表示，`nstart=25`定义了要选择的随机集的数量:

结果如下:

```
 > foodergycnt.stddev <- sweep(food.energycontent[,-1],2,standard.deviation,FUN="/") 
 > foodergycnt.stddev

```

The result is as follows:

![Step 3 - transforming data](img/image_03_073.jpg)

结果如下:

### Step 4 - clustering

The `kmeans()` function shall carry out K-means clustering on the data matrix. The data matrix `foodergycnt.stddev` is passed as an object that can be coerced to the numeric matrix of data. `centers=5` signifies the number of initial (distinct) cluster centers. `iter.max=100` means the maximum number of iterations allowed. Since the number of clusters is denoted by a number, `nstart=25` defines the number of random sets to be chosen:

```
 > food.5cluster <- kmeans(foodergycnt.stddev, centers=5, iter.max=100, nstart=25)
 > food.5cluster

```

打印 4 集群解决方案的集群向量:

结果如下:

![Step 4 - clustering](img/image_03_074.jpg)

```
 > food.4cluster <- kmeans(foodergycnt.stddev, centers=4, iter.max=100, nstart=25)
 > food.4cluster

```

The result is as follows:

接下来，我们将打印食品标签方面的 4 簇解决方案的簇。

![Step 4 - clustering](img/image_03_075.jpg)

`lapply()`函数返回一个长度与 X 相同的列表:

结果如下:

```
> food.4cluster$cluster

```

The result is as follows:

![Step 4 - clustering](img/image_03_076.jpg)

步骤 5——可视化集群

使用`pairs()`功能，生成一个散点图矩阵。`food.energycontent[,-1]`提供以矩阵或数据框的数字列给出的点的坐标。

结果如下:

```
 > food.4cluster.clust <- lapply(1:4, function(nc) protein[food.4cluster$cluster==nc])
 > food.4cluster.clust

```

`princomp()`函数对给定的数字数据矩阵进行主成分分析。该函数产生非旋转主成分分析。`cor=T`表示逻辑值，表示计算应使用相关矩阵:

`par()`功能将多个图形组合成一个整体图形。`s`生成一个正方形绘图区域:

![Step 4 - clustering](img/image_03_077.jpg)

绘制集群:

### 结果如下:

Using the `pairs()` function, a matrix of scatterplots is produced. `food.energycontent[,-1]` provides the coordinates of points given as numeric columns of a matrix or data frame.

```
> pairs(food.energycontent[,-1], panel=function(x,y) text(x,y,food.4cluster$cluster))

```

The result is as follows:

![Step 5 - visualizing the clusters](img/image_03_078.jpg)

The `princomp()`function performs a principal components analysis on the given numeric data matrix. The function produces an unrotated principal component analysis. `cor=T` signifies a logical value indicating that the calculation should use the correlation matrix:

```
 > food.pc <- princomp(food.energycontent[,-1],cor=T)
 > my.color.vector <- rep("green", times=nrow(food.energycontent))
 > my.color.vector[food.4cluster$cluster==2] <- "blue"
 > my.color.vector[food.4cluster$cluster==3] <- "red"
 > my.color.vector[food.4cluster$cluster==4] <- "orange"

```

The `par()` function combines multiple plots into one overall graph. `s` generates a square plotting region:

```
> par(pty="s")

```

Plotting the cluster:

```
 > plot(food.pc$scores[,1], food.pc$scores[,2], ylim=range(food.pc$scores[,1]), 
 + xlab="PC 1", ylab="PC 2", type ='n', lwd=2)
 > text(food.pc$scores[,1], food.pc$scores[,2], labels=Food, cex=0.7, lwd=2,
 + col=my.color.vector)

```

The result is as follows:

![Step 5 - visualizing the clusters](img/image_03_079.jpg)