<html><head/><body>



<title>Chapter 8. Reinforcement Learning</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title"><a id="ch08"/>第八章。强化学习</h1></div></div></div><p>在本章中，我们将介绍以下配方:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">马尔可夫链——股票状态转换模型</li><li class="listitem" style="list-style-type: disc">马尔可夫链——多渠道归因模型</li><li class="listitem" style="list-style-type: disc">马尔可夫链-汽车租赁代理服务</li><li class="listitem" style="list-style-type: disc">连续马氏链-加油站的车辆服务</li><li class="listitem" style="list-style-type: disc">蒙特卡洛模拟-校准船体和白色短速率</li></ul></div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec40"/>简介</h1></div></div></div><p><strong>马尔可夫链</strong>:如果每个实验的结果是一组离散状态中的一个，并且该实验的结果仅依赖于当前状态而不依赖于任何过去的状态，则该实验的试验序列是马尔可夫链。从一种状态变化到另一种状态的概率表示为<img src="img/image_08_001.jpg" alt="Introduction"/>。它被称为转移概率。转移概率矩阵是一个 n × n 矩阵，使得矩阵的每个元素都是非负的，并且矩阵的每一行总和为 1。</p><p><strong>连续时间马尔可夫链</strong>:连续时间马尔可夫链可以被标记为增加了具有离散状态的比率的转移系统。状态具有连续的时间步长，延迟是指数分布的。连续时间马尔可夫链适合于对可靠性模型、控制系统、生物途径、化学反应等进行建模。</p><p><strong>蒙特卡洛模拟</strong>:蒙特卡洛模拟是对系统行为的随机模拟。模拟使用在模型上执行的采样实验，然后使用计算机进行数值实验，以获得对系统行为的统计理解。蒙特卡罗模拟用于构建复杂系统的观察行为的理论，预测系统的未来行为，并基于系统内的输入和参数变化研究对最终结果的影响。随机模拟是一种对系统进行实验的方法，以找到改进或更好地理解系统行为的方法。它使用均匀分布在区间[0，1]上的随机数。这些均匀分布的随机数用于从各种概率分布中产生随机变量。然后生成与系统行为建模相关联的采样实验。</p></div></div>





<title>Markov chains - the stocks regime switching model</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title"><a id="ch08lvl1sec41"/>马尔可夫链-股票状态转换模型</h1></div></div></div><p>在过去的几十年里，人们对波动性的分析和预测进行了大量的研究。波动性是交易价格序列随时间变化的程度，用收益的标准差来衡量。股票收益模型假设收益遵循几何布朗运动。这意味着在任何离散的时间间隔内，股票的收益都是对数正态分布的，并且在非重叠的时间间隔内的收益是独立的。研究发现，该模型未能捕捉到极端的价格变动和波动率参数的随机可变性。随机波动率取离散值，在这些值之间随机切换。这是<strong>状态切换对数正态过程</strong> ( <strong> RSLN </strong>)的基础。</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec49"/>做好准备</h2></div></div></div><p>为了执行马尔可夫链状态转换模型，我们将使用从股票数据集中收集的数据。</p><div><div><div><div><h3 class="title"><a id="ch08lvl3sec125"/>步骤 1 -收集和描述数据</h3></div></div></div><p>应使用名为<code class="literal">StocksRegimeSwitching.csv</code>的数据集。该数据集以 csv 格式提供，称为<code class="literal">StocksRegimeSwitching.csv</code>。数据集采用标准格式。有 66 行数据。有七个变量。数字变量如下:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">LRY</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">LRV</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">INT</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">LRC</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">LVS</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">LGS</code></li></ul></div><p>非数字变量如下:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">DATE</code></li></ul></div></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec50"/>怎么做...</h2></div></div></div><p>让我们进入细节。</p><div><div><div><div><h3 class="title"><a id="ch08lvl3sec126"/>第二步-探索数据</h3></div></div></div><p>第一步是加载以下包:</p><pre class="programlisting">
<strong>    &gt;install.packages("MSwM")</strong>
<strong>    &gt;library(MSwM)</strong>
</pre><div><div><h3 class="title"><a id="note22"/>注</h3><p>版本信息:此页面的代码已在 R 版本 3.2.2 中测试过(2015-08-14)。</p></div></div><p>让我们探索数据，了解变量之间的关系。我们将从导入名为<code class="literal">StocksRegimeSwitching.csv</code>的 CSV 数据文件开始。我们将把数据保存到<code class="literal">MarkovSwitchData</code>数据框中:</p><pre class="programlisting">
<strong>&gt; MarkovSwitchData &lt;- read.csv("d:/StocksRegimeSwitching.csv", header = TRUE)</strong>
</pre><p>附加数据集。<code class="literal">attach()</code>函数将数据集附加到搜索路径。评估变量时会搜索数据集。<code class="literal">MarkovSwitchData</code>作为参数传递:</p><pre class="programlisting">
<strong>&gt; attach(MarkovSwitchData)</strong>
</pre><p>打印<code class="literal">MarkovSwitchData</code>数据帧。<code class="literal">head()</code>函数返回<code class="literal">MarkovSwitchData</code>数据帧的第一部分。<code class="literal">MarkovSwitchData</code>数据帧作为输入参数传递:</p><pre class="programlisting">
<strong>&gt; head(MarkovSwitchData)</strong>
</pre><p>结果如下:</p><p>探索<code class="literal">MarkovSwitchData</code>数据框的维度。<code class="literal">dim()</code>函数返回<code class="literal">MarkovSwitchData</code>框架的尺寸。<code class="literal">MarkovSwitchData</code>数据帧作为输入参数传递。结果清楚地表明有 66 行数据和 7 个单列:</p><div><img src="img/image_08_002.jpg" alt="Step 2 - exploring the data"/></div><p>结果如下:</p><p>Exploring the dimension of the <code class="literal">MarkovSwitchData</code> data frame. The <code class="literal">dim()</code>function returns the dimension of the <code class="literal">MarkovSwitchData</code> frame. The <code class="literal">MarkovSwitchData</code> data frame is passed as an input parameter. The result clearly states that there are 66 rows of data and seven single columns:</p><pre class="programlisting">
<strong>&gt; dim(MarkovSwitchData)</strong>
</pre><p>The result is as follows:</p><p>打印<code class="literal">MarkovSwitchData</code>数据框的摘要。<code class="literal">summary()</code>功能是多功能功能。<code class="literal">summary()</code>函数是一个通用函数，提供与单个对象或数据框相关的数据汇总。<code class="literal">MarkovSwitchData</code>数据帧作为 R 对象传递给<code class="literal">summary()</code>函数:</p><div><img src="img/image_08_003.jpg" alt="Step 2 - exploring the data"/></div><p>结果如下:</p><p>Printing the summary of the <code class="literal">MarkovSwitchData</code> data frame. The <code class="literal">summary()</code> function is a multipurpose function. The <code class="literal">summary()</code> function is a generic function that provides a summary of the data related to the individual object or data frame. The <code class="literal">MarkovSwitchData</code> data frame is passed as an R object to the <code class="literal">summary()</code> function:</p><pre class="programlisting">
<strong>&gt; summary(MarkovSwitchData)</strong>
</pre><p>The result is as follows:</p><p><a id="ch08lvl3sec127"/>步骤 3 -准备回归模型</p><div><img src="img/image_08_004.jpg" alt="Step 2 - exploring the data"/></div><p>将在数据集上准备回归模型。当两个或多个变量被认为通过线性关系系统地联系在一起时，就使用回归分析。回归模型用于从一个变量预测另一个变量。它们根据信息提供对过去、现在和未来事件的预测。</p></div><div><div><div><div><h3 class="title">定义因变量。<code class="literal">cbind()</code>功能用于定义因变量。该函数接收<code class="literal">LVS</code>数据帧。结果数据帧存储在<code class="literal">yLogValueStocks</code>数据帧中:</h3></div></div></div><p>打印<code class="literal">yLogValueStocks</code>帧。<code class="literal">head()</code>函数返回<code class="literal">yLogValueStocks</code>帧的第一部分。<code class="literal">yLogValueStocks</code>帧作为输入参数传递:</p><p>结果如下:</p><pre class="programlisting">
<strong>    &gt; yLogValueStocks &lt;- cbind(LVS)</strong>
</pre><p>Printing the <code class="literal">yLogValueStocks</code> frame. The <code class="literal">head()</code> function returns the first part of the <code class="literal">yLogValueStocks</code> frame. The <code class="literal">yLogValueStocks</code> frame is passed as an input parameter:</p><pre class="programlisting">
<strong>    &gt; head(yLogValueStocks)</strong>
</pre><p>The result is as follows:</p><p><code class="literal">cbind ()</code>函数接收<code class="literal">LGS</code>数据帧。结果数据帧存储在<code class="literal">yLogGrowthStocks</code>数据帧中。</p><div><img src="img/image_08_005.jpg" alt="Step 3 - preparing the regression model"/></div><p>打印<code class="literal">yLogGrowthStocks</code>画面。<code class="literal">head()</code>函数返回<code class="literal">yLogGrowthStocks</code>数据帧的第一部分。<code class="literal">yLogGrowthStocks</code>帧作为输入参数传递:</p><p>结果如下:</p><p>Printing the <code class="literal">yLogGrowthStocks</code> frame. The <code class="literal">head()</code> function returns the first part of the <code class="literal">yLogGrowthStocks</code> data frame. The <code class="literal">yLogGrowthStocks</code> frame is passed as an input parameter:</p><pre class="programlisting">
<strong>&gt; head(yLogGrowthStocks)</strong>
</pre><p>The result is as follows:</p><p>定义自变量<code class="literal">cbind()</code>函数用于定义因变量。该函数接收<code class="literal">LRY</code>、<code class="literal">LRC</code>、<code class="literal">INT</code>、<code class="literal">LRV</code>数据帧。结果数据帧存储在<code class="literal">x</code>数据帧中:</p><div><img src="img/image_08_006.jpg" alt="Step 3 - preparing the regression model"/></div><p>创建一个<strong>普通最小二乘</strong> ( <strong> OLS </strong>)回归方程。<code class="literal">lm()</code>功能用于拟合线性模型。待拟合的模型象征性地由<code class="literal">yLogValueStocks~x</code>表示。结果存储在<code class="literal">olsLogValueStocks</code>数据框中:</p><p>打印<code class="literal">olsLogValueStocks</code>数据帧的摘要。<code class="literal">summary()</code>功能用于提供与单个对象或数据框相关的数据摘要。<code class="literal">olsLogValueStocks</code>数据帧作为 R 对象传递给<code class="literal">summary()</code>函数:</p><pre class="programlisting">
<strong>&gt; x &lt;- cbind(LRY, LRC, INT, LRV)</strong>
</pre><p>结果如下:</p><pre class="programlisting">
<strong>&gt; olsLogValueStocks &lt;- lm(yLogValueStocks~x)</strong>
</pre><p>Printing the summary of the <code class="literal">olsLogValueStocks</code> data frame. The <code class="literal">summary()</code> function is used to provide a summary of the data related to the individual object or data frame. The <code class="literal">olsLogValueStocks</code> data frame is passed as an R object to the <code class="literal">summary()</code> function:</p><pre class="programlisting">
<strong>&gt; summary(olsLogValueStocks)</strong>
</pre><p>The result is as follows:</p><p>创建普通最小二乘回归方程。待拟合的模型象征性地由<code class="literal">yLogGrowthStocks~x</code>表示。然后将结果存储在<code class="literal">olsLogGrowthStocks</code>数据帧中:</p><div><img src="img/image_08_007.jpg" alt="Step 3 - preparing the regression model"/></div><p>打印<code class="literal">olsLogGrowthStocks</code>数据帧的摘要。<code class="literal">olsLogGrowthStocks</code>数据帧作为 R 对象传递给<code class="literal">summary()</code>函数:</p><p>结果如下:</p><pre class="programlisting">
<strong>&gt; olsLogGrowthStocks &lt;- lm(yLogGrowthStocks~x)</strong>
</pre><p>Printing the summary of the <code class="literal">olsLogGrowthStocks</code> data frame. The <code class="literal">olsLogGrowthStocks</code> data frame is passed as an R object to the <code class="literal">summary()</code> function:</p><pre class="programlisting">
<strong>&gt; summary(olsLogGrowthStocks)</strong>
</pre><p>The result is as follows:</p><p><a id="ch08lvl3sec128"/>步骤 4 -准备马尔可夫转换模型</p><div><img src="img/image_08_008.jpg" alt="Step 3 - preparing the regression model"/></div><p>马尔可夫转换模型包括多个方程，这些方程可以描述不同状态下的时间序列行为。该模型能够通过在结构之间切换来捕捉复杂的动态模式。状态变量的当前值取决于刚刚过去的值，该值由马尔可夫特性控制。</p></div><div><div><div><div><h3 class="title">为股票价值创建马尔可夫转换模型。<code class="literal">msmFit()</code>函数使用 EM 算法实现马尔可夫切换模型，如下所示。<code class="literal">olsLogValueStocks</code>属于<code class="literal">lm</code>类型的对象类。<code class="literal">k = 2</code>代表估计的政权数量。结果存储在<code class="literal">MarkovSwtchLogValueStocks</code>数据帧中:</h3></div></div></div><p>如下打印<code class="literal">MarkovSwtchLogValueStocks</code>数据帧的摘要。<code class="literal">MarkovSwtchLogValueStocks</code>数据帧作为 R 对象传递给<code class="literal">summary()</code>函数:</p><p>结果如下:</p><pre class="programlisting">
<strong>&gt; MarkovSwtchLogValueStocks &lt;- msmFit(olsLogValueStocks, k = 2, sw = rep(TRUE, 6))</strong>
</pre><p>Printing the summary of the <code class="literal">MarkovSwtchLogValueStocks</code> data frame as follows. The <code class="literal">MarkovSwtchLogValueStocks</code> data frame is passed as an R object to the <code class="literal">summary()</code> function:</p><pre class="programlisting">
<strong>&gt; summary(MarkovSwtchLogValueStocks)</strong>
</pre><p>The result is as follows:</p><p><strong> </strong></p><div><img src="img/image_08_009.jpg" alt="Step 4 - preparing the Markov-switching model"/></div><p>
</p><p>为成长型股票创建马尔可夫转换模型。<code class="literal">msmFit()</code>函数使用 EM 算法实现马尔可夫切换模型。<code class="literal">olsLogGrowthStocks</code>是<code class="literal">lm</code>类型的对象类。<code class="literal">k = 2</code>代表估计的政权数量。结果存储在<code class="literal">MarkoSwtchLogGrowthStocks</code>数据帧中:</p><div><img src="img/image_08_010.jpg" alt="Step 4 - preparing the Markov-switching model"/></div><p>打印<code class="literal">MarkoSwtchLogGrowthStocksdata</code>帧的摘要。<code class="literal">MarkoSwtchLogGrowthStocks</code>数据帧作为 R 对象传递给<code class="literal">summary()</code>函数:</p><p>结果如下:</p><pre class="programlisting">
<strong>&gt; MarkoSwtchLogGrowthStocks&lt;- msmFit(olsLogGrowthStocks, k = 2, sw = rep(TRUE, 6))</strong>
</pre><p>Printing the summary of the <code class="literal">MarkoSwtchLogGrowthStocksdata</code> frame. The <code class="literal">MarkoSwtchLogGrowthStocks</code> data frame is passed as an R object to the <code class="literal">summary()</code> function:</p><pre class="programlisting">
<strong>&gt; summary(MarkoSwtchLogGrowthStocks)</strong>
</pre><p>The result is as follows:</p><p><strong> </strong></p><div><img src="img/image_08_011.jpg" alt="Step 4 - preparing the Markov-switching model"/></div><p>
</p><p><a id="ch08lvl3sec129"/>第 5 步——绘制制度概率图</p><div><img src="img/image_08_012.jpg" alt="Step 4 - preparing the Markov-switching model"/></div><p>接下来我们将绘制已经计算过的状态概率。</p></div><div><div><div><div><h3 class="title">绘制股票价值的制度概率。<code class="literal">par()</code>功能用于查询如下图形参数:</h3></div></div></div><p><code class="literal">plotProb()</code>功能为每个政权创建每个地块。该图包含平滑和过滤的概率。<code class="literal">MarkovSwtchLogValueStocks</code>作为类型<code class="literal">MSM.lm</code>的对象被传递。<code class="literal">which = 1</code>值代表所需的绘图子集。使用以下命令:</p><p>结果如下:</p><pre class="programlisting">
<strong>&gt; par(mar=c(3,3,3,3))</strong>
</pre><p>The <code class="literal">plotProb()</code> function creates each plot for each regime. The plot contains smoothed and filtered probabilities. <code class="literal">MarkovSwtchLogValueStocks</code> is passed as an object of type <code class="literal">MSM.lm</code>. The <code class="literal">which = 1</code> value represents the subset of the plots that is required. Use the following command:</p><pre class="programlisting">
<strong>&gt; plotProb(MarkovSwtchLogValueStocks, which=1)</strong>
</pre><p>The result is as follows:</p><p><code class="literal">plotProb()</code>功能为每个状态创建每个图。该图包含平滑和过滤的概率。<code class="literal">MarkovSwtchLogValueStocks</code>作为<code class="literal">MSM.lm </code>类型的对象被传递。<code class="literal">which = 2</code>值代表响应变量与平滑概率的状态图。使用以下命令:</p><div><img src="img/image_08_013.jpg" alt="Step 5 - plotting the regime probabilities"/></div><p>结果如下:</p><p>The <code class="literal">plotProb()</code> function creates each plot for each regime. The plot contains smoothed and filtered probabilities. <code class="literal">MarkovSwtchLogValueStocks</code> is passed as an object of the <code class="literal">MSM.lm </code>type. The <code class="literal">which = 2</code> value represents the plot of the regime with the response variable against the smoothed probabilities. Use the following command:</p><pre class="programlisting">
<strong>&gt; plotProb(MarkovSwtchLogValueStocks, which=2)</strong>
</pre><p>The result is as follows:</p><p><code class="literal">plotProb()</code>功能为每个状态创建每个图。<code class="literal">MarkoSwtchLogGrowthStocks</code>作为<code class="literal">MSM.lm</code>类型的对象传递。<code class="literal">which = 1</code>值代表所需的绘图子集:</p><div><img src="img/image_08_014.jpg" alt="Step 5 - plotting the regime probabilities"/></div><p>结果如下:</p><p>The <code class="literal">plotProb()</code> function creates each plot for each regime. <code class="literal">MarkoSwtchLogGrowthStocks</code> is passed as an object of the <code class="literal">MSM.lm</code> type. The <code class="literal">which = 1</code> value represents the subset of the plots that is required:</p><pre class="programlisting">
<strong>&gt; plotProb(MarkoSwtchLogGrowthStocks, which=1)</strong>
</pre><p>The result is as follows:</p><p><code class="literal">plotProb()</code>功能为每个状态创建每个图。<code class="literal">MarkoSwtchLogGrowthStocks</code>作为<code class="literal">MSM.lm</code>类型的对象传递。<code class="literal">which = 2</code>值代表响应变量与平滑概率的状态图。使用以下命令:</p><div><img src="img/image_08_015.jpg" alt="Step 5 - plotting the regime probabilities"/></div><p>结果如下:</p><p>The <code class="literal">plotProb()</code> function creates each plot for each regime. <code class="literal">MarkoSwtchLogGrowthStocks</code> is passed as an object of  the <code class="literal">MSM.lm</code> type. The <code class="literal">which = 2</code> value represents the plot of the regime with the response variable against the smoothed probabilities. Use the following command:</p><pre class="programlisting">
<strong>&gt; plotProb(MarkoSwtchLogGrowthStocks, which=2)</strong>
</pre><p>The result is as follows:</p><p><a id="ch08lvl3sec130"/>步骤 6 -测试马尔可夫转换模型</p><div><img src="img/image_08_016.jpg" alt="Step 5 - plotting the regime probabilities"/></div><p>接下来，我们将对马尔可夫转换模型进行一系列诊断测试。</p></div><div><div><div><div><h3 class="title">绘制股票价值的制度概率。<code class="literal">par()</code>功能用于查询图形参数:</h3></div></div></div><p>创建残差分析图。<code class="literal">plotDiag()</code>函数绘制拟合值的残差。<code class="literal">MarkovSwtchLogValueStocks</code>作为一个<code class="literal">MSM.lm</code>类型的对象被传递。<code class="literal">which = 1</code>值代表所需的绘图子集。<code class="literal">which=1</code>值代表残差与拟合值的关系图:</p><p>结果如下:</p><pre class="programlisting">
<strong>&gt; par(mar=c(3,3,3,3))</strong>
</pre><p>Creating the plots for the residual analysis. The <code class="literal">plotDiag()</code> function plots the residuals against the fitted values. <code class="literal">MarkovSwtchLogValueStocks</code> is passed as an object of the <code class="literal">MSM.lm</code> type. The <code class="literal">which = 1</code> value represents the subset of the plots is that required. The <code class="literal">which=1</code> value represents the plot of residuals against fitted values:</p><pre class="programlisting">
<strong>&gt; plotDiag(MarkovSwtchLogValueStocks, regime=1, which=1)</strong>
</pre><p>The result is as follows:</p><p><code class="literal">plotDiag()</code>函数绘制残差与拟合值的关系。<code class="literal">MarkovSwtchLogValueStocks</code>作为<code class="literal">MSM.lm</code>类型的对象被传递。<code class="literal">which = 2</code>代表所需的绘图子集。<code class="literal">which=2</code>代表正常 Q-Q 图:</p><div><img src="img/image_08_017.jpg" alt="Step 6 - testing the Markov switching model"/></div><p>结果如下:</p><p>The <code class="literal">plotDiag()</code> function plots the residuals against the fitted values. <code class="literal">MarkovSwtchLogValueStocks</code> is passed as an object of the <code class="literal">MSM.lm</code> type. <code class="literal">which = 2</code> represents the subset of the plots that is required. <code class="literal">which=2</code> represents the Normal Q-Q plot:</p><pre class="programlisting">
<strong>&gt; plotDiag(MarkovSwtchLogValueStocks, regime=1, which=2)</strong>
</pre><p>The result is as follows:</p><p><code class="literal">plotDiag()</code>函数绘制拟合值的残差。<code class="literal">MarkoSwtchLogGrowthStocks</code>作为<code class="literal">MSM.lm</code>类型的对象传递。<code class="literal">which = 3</code>代表所需的绘图子集。<code class="literal">which=3</code>表示残差的 ACF/PACF 和残差平方的 ACF/PACF:</p><div><img src="img/image_08_018.jpg" alt="Step 6 - testing the Markov switching model"/></div><p>结果如下:</p><p>The <code class="literal">plotDiag()</code> function plots the residuals against the fitted values. <code class="literal">MarkoSwtchLogGrowthStocks</code> is passed as an object of the <code class="literal">MSM.lm</code> type. <code class="literal">which = 3</code> represents the subset of the plots that is required. <code class="literal">which=3</code> represents the ACF/PACF of residuals and the ACF/PACF of square residuals:</p><pre class="programlisting">
<strong>&gt; plotDiag(MarkoSwtchLogGrowthStocks, regime=1, which=3)</strong>
</pre><p>The result is as follows:</p><p><code class="literal">plotDiag()</code>功能根据拟合值绘制残差。<code class="literal">MarkoSwtchLogGrowthStocks</code>作为<code class="literal">MSM.lm</code>类型的对象传递。<code class="literal">which = 1</code>代表所需的绘图子集。<code class="literal">which = 1</code>代表残差与拟合值的关系图:</p><div><img src="img/image_08_019.jpg" alt="Step 6 - testing the Markov switching model"/></div><p>结果如下:</p><p>The <code class="literal">plotDiag()</code> function plots the residuals against the fitted values. <code class="literal">MarkoSwtchLogGrowthStocks</code> is passed as an object of the <code class="literal">MSM.lm</code> type. <code class="literal">which = 1</code> represents the subset of the plots that is required. <code class="literal">which = 1</code> represents the plot of residuals against fitted values:</p><pre class="programlisting">
<strong>&gt; plotDiag(MarkoSwtchLogGrowthStocks, regime=1, which=1)</strong>
</pre><p>The result is as follows:</p><p><code class="literal">plotDiag()</code>功能根据拟合值绘制残差。<code class="literal">MarkoSwtchLogGrowthStocks</code>是作为<code class="literal">MSM.lm</code>类型的对象传递的。<code class="literal">which = 2</code>代表所需的绘图子集。<code class="literal">which=2</code>代表正常 Q-Q 图:</p><div><img src="img/image_08_020.jpg" alt="Step 6 - testing the Markov switching model"/></div><p>结果如下:</p><p>The <code class="literal">plotDiag()</code> function plots the residuals against the fitted values. <code class="literal">MarkoSwtchLogGrowthStocks</code> is passed as an object of the <code class="literal">MSM.lm</code> type. <code class="literal">which = 2</code> represents the subset of the plots that is required. <code class="literal">which=2</code> represents the Normal Q-Q plot:</p><pre class="programlisting">
<strong>&gt; plotDiag(MarkoSwtchLogGrowthStocks, regime=1, which=2)</strong>
</pre><p>The result is as follows:</p><p><code class="literal">plotDiag()</code>功能根据拟合值绘制残差。<code class="literal">MarkoSwtchLogGrowthStocks</code>作为<code class="literal">MSM.lm</code>类型的对象传递。<code class="literal">which = 3</code>代表所需的绘图子集。<code class="literal">which=3</code>表示残差的 ACF/PACF 和残差平方的 ACF/PACF:</p><div><img src="img/image_08_021.jpg" alt="Step 6 - testing the Markov switching model"/></div><p>结果如下:</p><p>The <code class="literal">plotDiag()</code> function plots the residuals against the fitted values. <code class="literal">MarkoSwtchLogGrowthStocks</code> is passed as an object of the <code class="literal">MSM.lm</code> type. <code class="literal">which = 3</code> represents the subset of the plots that is required. <code class="literal">which=3</code> represents the ACF/PACF of residuals and the ACF/PACF of square residuals:</p><pre class="programlisting">
<strong>&gt; plotDiag(MarkoSwtchLogGrowthStocks, regime=1, which=3)</strong>
</pre><p>The result is as follows:</p><p><a id="ch08lvl1sec42"/>马尔可夫链-多渠道归因模型</p><div><img src="img/image_08_022.jpg" alt="Step 6 - testing the Markov switching model"/></div><p>在电子商务网站上购买之前，客户的旅程经历了不同渠道的路径。多渠道归因为旅程中的每一步赋予一个价值。问题是，如何识别人们在你的网站上采取的导致转化的行动的价值。通常，企业使用“最后一次点击”归因，这意味着将所有转化价值分配给旅程的最后一步或“第一次点击”归因。开发多渠道归因分析的第一步是了解客户的旅程——从认知到购买再到售后支持。最终目标是发展忠诚的顾客，他们会花大量的钱购买，向他人推荐这个品牌，这个品牌有可能成为一个品牌。</p></div></div></div>





<title>Markov chains - the multi-channel attribution model</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title">准备就绪</h1></div></div></div><p>为了执行马尔可夫链多渠道归因模型，我们将模拟包含三个独特渠道的客户旅程。</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec52"/>怎么做...</h2></div></div></div><p>让我们进入细节。</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl3sec131"/>步骤 1 -准备数据集</h2></div></div></div><p>首先加载以下软件包:</p><div><div><div><div><h3 class="title"><a id="note23"/>注意</h3></div></div></div><p>版本信息:此页面的代码已在 R 版本 3.2.2 中测试过(2015-08-14)。</p><pre class="programlisting">
<strong>    &gt; install.packages("dplyr")</strong>
<strong>    &gt; install.packages("reshape2")</strong>
<strong>    &gt; install.packages("ggplot2")</strong>
<strong>    &gt; install.packages("ChannelAttribution")</strong>
<strong>    &gt; install.packages("markovchain")</strong>
<strong>    &gt; library(dplyr)</strong>
<strong>    &gt; library(reshape2)</strong>
<strong>    &gt; library(ggplot2)</strong>
<strong>    &gt; library(ChannelAttribution)</strong>
<strong>    &gt; library(markovchain)</strong>
</pre><div><div><h3 class="title">创建数据样本:<code class="literal">c()</code>函数将参数组合成一个向量。传递给函数的所有参数被组合成一个公共类型，即返回值的类型。<code class="literal">data.frame()</code>函数创建了一个紧密耦合的数据框架，它是共享矩阵和列表的许多属性的变量的集合。我们将数据保存到<code class="literal">datafrm1</code>数据框，如下所示:</h3><p>如下打印<code class="literal">datafrm1</code>数据帧:</p></div></div><p>结果如下:</p><pre class="programlisting">
<strong>&gt; datafrm1 &lt;- data.frame(path = c('c1 &gt; c2 &gt; c3', 'c1', 'c2 &gt; c3'), conv = c(1, 0, 0), conv_null = c(0, 1, 1))</strong>
</pre><p>Print the <code class="literal">datafrm1</code> data frame as follows:</p><pre class="programlisting">
<strong>&gt; datafrm1</strong>
</pre><p>The result is as follows:</p><p><a id="ch08lvl3sec132"/>步骤 2 -准备模型</p><div><img src="img/image_08_023.jpg" alt="Step 1 - preparing the dataset"/></div><p>准备马尔可夫模型。<code class="literal">markov_model()</code>函数从客户旅程数据中估计 k 阶马尔可夫模型。<code class="literal">datafrm1</code>是包含定义的客户旅程的数据帧。<code class="literal">var_path</code>变量具有包含旅程路径的列的名称。<code class="literal">var_conv</code>变量表示包含总转换的列的名称。<code class="literal">var_null</code>变量表示包含不导致转换的总路径的列。<code class="literal">out_more = TRUE</code>返回通道和移除效果之间的转换概率。</p></div><div><div><div><div><h3 class="title">估计的 k 阶马尔可夫模型的结果存储在<code class="literal">model1</code>数据帧中，如下所示:</h3></div></div></div><p>打印<code class="literal">model1</code>数据帧:</p><p>结果如下:</p><pre class="programlisting">
<strong>&gt; model1 &lt;- markov_model(datafrm1, var_path = 'path', var_conv = 'conv', var_null = 'conv_null', out_more = TRUE)</strong>
</pre><p>Printing the <code class="literal">model1</code> data frame:</p><pre class="programlisting">
<strong>&gt; model1</strong>
</pre><p>The result is as follows:</p><p>从<code class="literal">model1data</code>帧中提取结果属性如下。然后将结果存储在<code class="literal">datafrmresult1</code>数据帧中:</p><div><img src="img/image_08_024.jpg" alt="Step 2 - preparing the model"/></div><p>如下从<code class="literal">model1data</code>帧中提取<code class="literal">transition_matrix</code>属性。结果存储在<code class="literal">datafrmtransmatrix1</code>数据框中:</p><p>重塑数据框。整形数据帧的结果存储在<code class="literal">datafrmtransmatrix</code>中:</p><pre class="programlisting">
<strong>&gt; datafr{BS}l1$result</strong>
</pre><p>打印<code class="literal">datafrmtransmatrix</code>数据框:</p><pre class="programlisting">
<strong>&gt; datafrmtransmatrix1 &lt;- model1$transition_matrix</strong>
</pre><p>结果如下:</p><pre class="programlisting">
<strong>&gt; datafrmtransmatrix &lt;- dcast(datafrmtransmatrix1, channel_from ~ channel_to, value.var = 'transition_probability')</strong>
</pre><p>Printing the <code class="literal">datafrmtransmatrix</code> data frame:</p><pre class="programlisting">
<strong>&gt; datafrmtransmatrix</strong>
</pre><p>The result is as follows:</p><p>第三步——绘制马尔可夫图</p><div><img src="img/image_08_025.jpg" alt="Step 2 - preparing the model"/></div><p>从<code class="literal">model1</code>数据帧中提取<code class="literal">transition_matrix</code>属性。然后将结果存储在<code class="literal">datafrmtransmatrix</code>数据帧中:</p></div><div><div><div><div><h3 class="title">打印<code class="literal">datafrmtransmatrix</code>数据帧，如下所示:</h3></div></div></div><p>结果如下:</p><pre class="programlisting">
<strong>&gt; datafrmtransmatrix &lt;- model1$transition_matrix</strong>
</pre><p>Print the <code class="literal">datafrmtransmatrix</code> data frame as follows:</p><pre class="programlisting">
<strong>&gt; datafrmtransmatrix</strong>
</pre><p>The result is as follows:</p><p>创建<code class="literal">datafrmdummy</code>数据样本。<code class="literal">c()</code>函数将参数组合成一个向量。传递给函数的所有参数被组合成一个公共类型，即返回值的类型。<code class="literal">data.frame()</code>函数创建了一个紧密耦合的数据框架，它是共享矩阵和列表的许多属性的变量的集合。我们将数据保存到<code class="literal">datafrmdummy</code>数据框，如下所示:</p><div><img src="img/image_08_026.jpg" alt="Step 3 - plotting the Markov graph"/></div><p>打印<code class="literal">datafrmtransmatrix</code>数据帧:</p><p>结果如下:</p><pre class="programlisting">
<strong>&gt; datafrmdummy &lt;- data.frame(channel_from = c('(start)', '(conversion)', '(null)'), channel_to = c('(start)', '(conversion)', '(null)'), transition_probability = c(0, 1, 1))</strong>
</pre><p>Printing the <code class="literal">datafrmtransmatrix</code> data frame:</p><pre class="programlisting">
<strong>&gt; datafrmtransmatrix</strong>
</pre><p>The result is as follows:</p><p>如下组合各列<em>。</em> <code class="literal">rbind()</code>获取一系列数据帧并将其组合。<code class="literal">datafrmtransmatrix</code>和<code class="literal">df_dummy</code>作为输入参数传递。结果是<code class="literal">datafrmtransmatrix</code>数据帧:</p><div><img src="img/image_08_027.jpg" alt="Step 3 - plotting the Markov graph"/></div><p>打印<code class="literal">datafrmtransmatrix</code>数据帧:</p><p>结果如下:</p><pre class="programlisting">
<strong>&gt; datafrmtransmatrix &lt;- rbind(datafrmtransmatrix, datafrmdummy)</strong>
</pre><p>Printing the <code class="literal">datafrmtransmatrix</code> data frame:</p><pre class="programlisting">
<strong>&gt; datafrmtransmatrix</strong>
</pre><p>The result is as follows:</p><p>按如下方式对频道进行排序。<code class="literal">factor()</code> as 函数用于编码一个矢量作为因子。<code class="literal">datafrmtransmatrix$channel_from</code>是作为向量传递的数据。<code class="literal">levels = c('(start)', '(conversion)', '(null)', 'c1', 'c2', 'c3')</code>代表可选向量的值:</p><div><img src="img/image_08_028.jpg" alt="Step 3 - plotting the Markov graph"/></div><p>打印<code class="literal">datafrmtransmatrix$channel_from</code>数据帧如下:</p><p>结果如下:</p><pre class="programlisting">
<strong>&gt; datafrmtransmatrix$channel_from &lt;- factor(datafrmtransmatrix$channel_from, levels = c('(start)', '(conversion)', '(null)', 'c1', 'c2', 'c3'))</strong>
</pre><p>Printing the <code class="literal">datafrmtransmatrix$channel_from</code> data frame as follows:</p><pre class="programlisting">
<strong>&gt; datafrmtransmatrix$channel_from</strong>
</pre><p>The result is as follows:</p><p>如下对通道进行排序。<code class="literal">datafrmtransmatrix$channel_to</code>作为向量传递的数据:</p><div><img src="img/image_08_029.jpg" alt="Step 3 - plotting the Markov graph"/></div><p>打印<code class="literal">datafrmtransmatrix$channel_to</code>数据帧:</p><p>结果如下:</p><pre class="programlisting">
<strong>&gt; datafrmtransmatrix$channel_to &lt;- factor(datafrmtransmatrix$channel_to, levels = c('(start)', '(conversion)', '(null)', 'c1', 'c2', 'c3'))</strong>
</pre><p>Print <code class="literal">datafrmtransmatrix$channel_to</code> the data frame:</p><pre class="programlisting">
<strong>&gt; datafrmtransmatrix$channel_to</strong>
</pre><p>The result is as follows:</p><p>重塑数据框。整形数据帧的结果存储在<code class="literal">datafrmtransmatrix</code>中:</p><div><img src="img/image_08_030.jpg" alt="Step 3 - plotting the Markov graph"/></div><p>打印<code class="literal">datafrmtransmatrix</code>数据帧:</p><p>结果如下:</p><pre class="programlisting">
<strong>&gt; datafrmtransmatrix &lt;- dcast(datafrmtransmatrix, channel_from ~ channel_to, value.var = 'transition_probability')</strong>
</pre><p>Printing the <code class="literal">datafrmtransmatrix</code> data frame:</p><pre class="programlisting">
<strong>&gt; datafrmtransmatrix</strong>
</pre><p>The result is as follows:</p><p>创建马尔可夫链对象。<code class="literal">matrix()</code> as 函数根据一组给定的值创建一个矩阵:</p><div><img src="img/image_08_031.jpg" alt="Step 3 - plotting the Markov graph"/></div><p>打印<code class="literal">transitionmatrix</code>数据帧:</p><p>结果如下:</p><pre class="programlisting">
<strong>&gt; transitionmatrix &lt;- matrix(data = as.matrix(datafrmtransmatrix[, -1]), nrow = nrow(datafrmtransmatrix[, -1]), ncol = ncol(datafrmtransmatrix[, -1]), dimnames = list</strong>
<strong>(c(as.character(datafrmtransmatrix[, 1])), c(colnames(datafrmtransmatrix[, -1]))))</strong>
</pre><p>Printing the <code class="literal">transitionmatrix</code> data frame:</p><pre class="programlisting">
<strong>&gt; transitionmatrix</strong>
</pre><p>The result is as follows:</p><p>创建马尔可夫链对象。<code class="literal">transitionMatrix</code>将是一个转移矩阵，也就是说，所有条目都是概率，所有行或所有列的总和为 1:</p><div><img src="img/image_08_032.jpg" alt="Step 3 - plotting the Markov graph"/></div><p>打印<code class="literal">transitionmatrix1</code>数据框:</p><pre class="programlisting">
<strong>&gt; transitionmatrix[is.na(transitionmatrix)] &lt;- 0</strong>
</pre><p>结果如下:</p><pre class="programlisting">
<strong>&gt; transitionmatrix1 &lt;- new("markovchain", transitionMatrix = transitionmatrix)</strong>
</pre><p>Printing the <code class="literal">transitionmatrix1</code> data frame:</p><pre class="programlisting">
<strong>&gt; transitionmatrix1</strong>
</pre><p>The result is as follows:</p><p>绘制图表:</p><div><img src="img/image_08_033.jpg" alt="Step 3 - plotting the Markov graph"/></div><p>结果如下:</p><p>Plotting the graph:</p><pre class="programlisting">
<strong>&gt; plot(transitionmatrix1, edge.arrow.size = 0.5, main = "Markov Graph Transition Matrix - transitionmatrix1")</strong>
</pre><p>The result is as follows:</p><p><a id="ch08lvl3sec134"/>第 4 步-模拟顾客旅程的数据集</p><div><img src="img/image_08_034.jpg" alt="Step 3 - plotting the Markov graph"/></div><p><code class="literal">data.frame()</code>函数创建了一个紧密耦合的数据框架，它是共享矩阵和列表的许多属性的变量的集合。我们将数据保存到<code class="literal">datafrm2</code>数据框，如下所示:</p></div><div><div><div><div><h3 class="title">打印<code class="literal">datafrm2</code>帧。<code class="literal">head()</code>函数返回<code class="literal">datafrm2</code>帧的第一部分。<code class="literal">datafrm2</code>帧作为输入参数传递:</h3></div></div></div><p>结果如下:</p><pre class="programlisting">
<strong>    &gt; set.seed(354)</strong>
<strong>    &gt; datafrm2 &lt;- data.frame(client_id = sample(c(1:1000), 5000, replace = TRUE), date = sample(c(1:32), 5000, replace = TRUE), channel = sample(c(0:9), 5000, replace = TRUE, prob = c(0.1, 0.15, 0.05, 0.07, 0.11, 0.07, 0.13, 0.1, 0.06, 0.16)))</strong>
</pre><p>Printing the <code class="literal">datafrm2</code> frame. The <code class="literal">head()</code> function returns the first part of the <code class="literal">datafrm2</code> frame. The <code class="literal">datafrm2</code> frame is passed as an input parameter:</p><pre class="programlisting">
<strong>&gt; head(datafrm2)</strong>
</pre><p>The result is as follows:</p><p>将字符对象转换为日期对象。<code class="literal">datafrm2$date</code>表示要转换的对象。<code class="literal">origin = "2016-01-01"</code>代表<code class="literal">Date</code>对象:</p><div><img src="img/image_08_035.jpg" alt="Step 4 - simulating the dataset of customer journeys"/></div><p>在转换成字符后连接向量。将<code class="literal">channel_</code>对象添加到通道中。<code class="literal">datafrm2$channel</code>代表数据帧:</p><p>打印<code class="literal">datafrm2</code>帧。<code class="literal">head()</code>函数返回<code class="literal">datafrm2</code>帧的第一部分。<code class="literal">datafrm2</code>帧作为输入参数传递:</p><pre class="programlisting">
<strong>&gt; datafrm2$date &lt;- as.Date(datafrm2$date, origin = "2016-01-01")</strong>
</pre><p>结果如下:</p><pre class="programlisting">
<strong>&gt; datafrm2$channel &lt;- paste0('channel_', datafrm2$channel)</strong>
</pre><p>Printing the <code class="literal">datafrm2</code> frame. The <code class="literal">head()</code> function returns the first part of the <code class="literal">datafrm2</code> frame. The <code class="literal">datafrm2</code> frame is passed as an input parameter:</p><pre class="programlisting">
<strong>&gt; head(datafrm2)</strong>
</pre><p>The result is as follows:</p><p>将渠道聚合到每个客户的路径:</p><div><img src="img/image_08_036.jpg" alt="Step 4 - simulating the dataset of customer journeys"/></div><p>打印<code class="literal">datafrm2</code>数据帧:</p><p>结果如下:</p><pre class="programlisting">
<strong>&gt; datafrm2 &lt;- datafrm2 %&gt;% group_by(client_id) %&gt;% summarise(path = paste(channel, collapse = ' &gt; '), conv = 1, conv_null = 0) %&gt;% ungroup()</strong>
</pre><p>Printing the <code class="literal">datafrm2</code> data frame:</p><pre class="programlisting">
<strong>&gt; datafrm2</strong>
</pre><p>The result is as follows:</p><p>准备马尔可夫模型。<code class="literal">markov_model()</code>函数根据客户旅程数据估计 k 阶马尔可夫模型。<code class="literal">datafrm2</code>是包含定义的客户旅程的数据帧。<code class="literal">var_path</code>具有包含旅程路径的列的名称。<code class="literal">var_conv</code>表示包含总转换的列的名称。<code class="literal">var_null</code>表示包含不导致转换的总路径的列。<code class="literal">out_more = TRUE</code>返回通道和移除效果之间的转换概率。</p><div><img src="img/image_08_037.jpg" alt="Step 4 - simulating the dataset of customer journeys"/></div><p>估计的 k 阶马尔可夫模型的结果存储在<code class="literal">model2</code>数据帧中，如下所示:</p><p>打印<code class="literal">datafrmheuristic</code>数据帧:</p><p>结果如下:</p><pre class="programlisting">
<strong>&gt; model2 &lt;- markov_model(datafrm2, var_path = 'path', var_conv = 'conv', var_null = 'conv_null', out_more = TRUE)</strong>
</pre><pre class="programlisting">
<strong>&gt; datafrmheuristic &lt;- datafrm2 %&gt;% mutate(channel_name_ft = sub('&gt;.*', '', path), channel_name_ft = sub(' ', '', channel_name_ft), channel_name_lt = sub('.*&gt;', '', path), channel_name_lt = sub(' ', '', channel_name_lt))</strong>
</pre><p>Printing the <code class="literal">datafrmheuristic</code> data frame:</p><pre class="programlisting">
<strong>&gt; datafrmheuristic</strong>
</pre><p>The result is as follows:</p><p>打印<code class="literal">datafrmfirsttouch</code>数据帧:</p><div><img src="img/image_08_038.jpg" alt="Step 4 - simulating the dataset of customer journeys"/></div><p>结果如下:</p><pre class="programlisting">
<strong>&gt; datafrmfirsttouch &lt;- datafrmheuristic %&gt;% group_by(channel_name_ft) %&gt;% summarise(first_touch_conversions = sum(conv)) %&gt;% ungroup()</strong>
</pre><p>打印<code class="literal">datafrmfirsttouch</code>数据帧:</p><pre class="programlisting">
<strong>&gt; datafrmfirsttouch</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_08_039.jpg" alt="Step 4 - simulating the dataset of customer journeys"/></div><p>
</p><pre class="programlisting">
<strong>&gt; datafrmlasttouch &lt;- datafrmheuristic %&gt;% group_by(channel_name_lt) %&gt;% summarise(last_touch_conversions = sum(conv)) %&gt;% ungroup()</strong>
</pre><p>通过公共列合并两个数据框。结果存储在<code class="literal">heuristicmodel2</code>数据帧中:</p><pre class="programlisting">
<strong>&gt; datafrmfirsttouch</strong>
</pre><p>打印<code class="literal">heuristicmodel2</code>数据框:</p><p>结果如下:</p><div><img src="img/image_08_040.jpg" alt="Step 4 - simulating the dataset of customer journeys"/></div><p>
</p><p>Merging the two data frames by common columns. The result is stored in the <code class="literal">heuristicmodel2</code> data frame:</p><pre class="programlisting">
<strong>&gt; heuristicmodel2 &lt;- merge(datafrmfirsttouch, datafrmlasttouch, by.x = 'channel_name_ft', by.y = 'channel_name_lt')</strong>
</pre><p>合并所有模型:</p><pre class="programlisting">
<strong>&gt; heuristicmodel2</strong>
</pre><p>打印<code class="literal">allmodels</code>数据帧:</p><p>结果如下:</p><div><img src="img/image_08_041.jpg" alt="Step 4 - simulating the dataset of customer journeys"/></div><p>
</p><p>Merging all the models:</p><pre class="programlisting">
<strong>&gt; allmodels &lt;- merge(heuristicmodel2, model2$result, by.x = 'channel_name_ft', by.y = 'channel_name')</strong>
</pre><p><a id="ch08lvl3sec135"/>步骤 5 -为真实数据准备转换矩阵热图</p><pre class="programlisting">
<strong>&gt; allmodels</strong>
</pre><p>绘制热图。</p><p>返回<code class="literal">datafrmplottransition$transition_probability</code>数据框中所有参数的最大值:</p><div><img src="img/image_08_042.jpg" alt="Step 4 - simulating the dataset of customer journeys"/></div><p>打印<code class="literal">t</code>的值:</p></div><div><div><div><div><h3 class="title">结果如下:</h3></div></div></div><p>Plotting the heatmap.</p><pre class="programlisting">
<strong>    &gt; colnames(allmodels)[c(1, 4)] &lt;- c('channel_name', 'attrib_model_conversions')</strong>
<strong>    &gt; datafrmplottransition &lt;- model2$transition_matrix</strong>
<strong>    &gt; cols &lt;- c("#e7f0fa", "#c9e2f6", "#95cbee", "#0099dc", "#4ab04a", "#ffd73e", "#eec73a", "#e29421", "#e29421", "#f05336", "#ce472e")</strong>
</pre><p>Return the maximum value of all the arguments present in the <code class="literal">datafrmplottransition$transition_probability</code> data frame:</p><pre class="programlisting">
<strong>&gt; t &lt;- max(datafrmplottransition$transition_probability)</strong>
</pre><p>结果如下:</p><pre class="programlisting">
<strong>&gt; t</strong>
</pre><p>The result is as follows:</p><p>
</p><div><img src="img/image_08_043.jpg" alt="Step 5 - preparing a transition matrix heat map for real data"/></div><p><a id="ch08lvl1sec43"/>马尔可夫链-汽车租赁代理服务</p><pre class="programlisting">
<strong>&gt; ggplot(datafrmplottransition, aes(y = channel_from, x = channel_to, fill = transition_probability)) + theme_minimal() + geom_tile(colour = "white", width = .9, height = .9) + scale_fill_gradientn(colours = cols, limits = c(0, t), breaks = seq(0, t, by = t/4), labels = c("0", round(t/4*1, 2), round(t/4*2, 2), round(t/4*3, 2), round(t/4*4, 2)), guide = guide_colourbar(ticks = T, nbin = 50, barheight = .5, label = T, barwidth = 10)) + geom_text(aes(label = round(transition_probability, 2)), fontface = "bold", size = 4) + theme(legend.position = 'bottom', legend.direction = "horizontal", panel.grid.major = element_blank(), panel.grid.minor = element_blank(), plot.title = element_text(size = 20, face = "bold", vjust = 2, color = 'black', lineheight = 0.8), axis.title.x = element_text(size = 24, face = "bold"), axis.title.y = element_text(size = 24, face = "bold"), axis.text.y = element_text(size = 8, face = "bold", color = 'black'), axis.text.x = element_text(size = 8, angle = 90, hjust = 0.5, vjust = 0.5, face = "plain")) + ggtitle("Heatmap - Transition Matrix ")</strong>
</pre><p>假设一家汽车租赁公司在渥太华有三个位置:市中心位置(标记为 A)、东区位置(标记为 B)和西区位置(标记为 C)。该机构有一组送货司机为所有三个地点提供服务。该机构的统计员已确定如下:</p><p>在对<code class="literal">Downtown</code>位置的呼叫中，30%在市中心地区发送，30%在<code class="literal">East</code>端发送，40%在<code class="literal">West</code>端发送</p><div><img src="img/image_08_044.jpg" alt="Step 5 - preparing a transition matrix heat map for real data"/></div><p>到<code class="literal">East</code>端位置的呼叫中，40%在市中心地区发送，40%在<code class="literal">East</code>端发送，20%在<code class="literal">West</code>端发送</p></div></div></div>





<title>Markov chains - the car rental agency service</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title">到<code class="literal">West</code>端位置的呼叫中，50%在闹市区，30%在<code class="literal">East</code>端，20%在<code class="literal">West</code>端</h1></div></div></div><p>送货后，司机会去最近的地方进行下一次送货。这样，特定驾驶员的位置仅由他们先前的位置来确定。</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">如何做到这一点...</li><li class="listitem" style="list-style-type: disc">让我们进入细节。</li><li class="listitem" style="list-style-type: disc"><a id="ch08lvl3sec136"/>步骤 1 -准备数据集</li></ul></div><p>加载以下包:</p><div><div><div><div><h2 class="title"><a id="note24"/>注</h2></div></div></div><p>版本信息:此页面的代码已在 R 版本 3.2.2 中测试过(2015-08-14)。</p><div><div><div><div><h3 class="title">创建数据样本。<code class="literal">c()</code>函数将参数组合成一个向量。传递给函数的所有参数被组合成一个公共类型，即返回值的类型。我们将把数据保存到<code class="literal">RentalStates</code>数据框:</h3></div></div></div><p>打印<code class="literal">RentalStates</code>的值:</p><pre class="programlisting">
<strong>    &gt; install.packages("markovchain")</strong>
<strong>    &gt; library(markovchain)</strong>
</pre><div><div><h3 class="title">结果如下:</h3><p>创建矩阵。<code class="literal">matrix()</code>函数从给定的一组值中创建一个矩阵。<code class="literal">byrow = T</code>矩阵由行填充。<code class="literal">nrow = 3</code>代表所需的行数。<code class="literal">c()</code>函数将参数组合成一个向量。传递给函数的所有参数被组合成一个公共类型，即返回值的类型:</p></div></div><p>打印<code class="literal">RentalTransitionMatrix</code>的值:</p><pre class="programlisting">
<strong>&gt; RentalStates &lt;- c("Downtown", "East", "West")</strong>
</pre><p>结果如下:</p><pre class="programlisting">
<strong>&gt; RentalStates</strong>
</pre><p>The result is as follows:</p><p>
</p><div><img src="img/image_08_045.jpg" alt="Step 1 - preparing the dataset"/></div><p><a id="ch08lvl3sec137"/>步骤 2 -准备模型</p><p>创建马尔可夫链对象。<code class="literal">new()</code>函数创建类型为<code class="literal">markovchain</code>的对象。States 代表先前定义的<code class="literal">RentalStates</code>。<code class="literal">byrow = T matrix</code>由行填充。然后将结果存储在数据帧<code class="literal">mcRental</code>中:</p><pre class="programlisting">
<strong>&gt; RentalTransitionMatrix &lt;- matrix(c(0.3, 0.3, 0.4, </strong>
<strong>                                     0.4, 0.4, 0.2, </strong>
<strong>                                     0.5, 0.3, 0.2),</strong>
<strong>  byrow = T, nrow = 3, dimnames = list(RentalStates, RentalStates))</strong>
</pre><p>打印<code class="literal">mcRental</code>数据帧:</p><pre class="programlisting">
<strong>&gt; RentalTransitionMatrix</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_08_046.jpg" alt="Step 1 - preparing the dataset"/></div><p>
</p></div><div><div><div><div><h3 class="title">通过调用<code class="literal">mcRental</code>对象访问转移矩阵，如下所示:</h3></div></div></div><p>结果如下:</p><pre class="programlisting">
<strong>&gt; mcRental &lt;- new("markovchain", states = RentalStates, byrow = T, transitionMatrix = RentalTransitionMatrix, name = "Rental Cars")</strong>
</pre><p>Printing the <code class="literal">mcRental</code> data frame:</p><pre class="programlisting">
<strong>&gt; mcRental</strong>
</pre><p>The result is as follows:</p><p>绘制<code class="literal">mcRental</code>对象。<code class="literal">plot()</code>是绘制 R 对象的通用函数:</p><div><img src="img/image_08_047.jpg" alt="Step 2 - preparing the model"/></div><p>结果如下:</p><p>Accessing the transition matrix by calling the <code class="literal">mcRental</code> object as follows:</p><pre class="programlisting">
<strong>&gt; mcRental[2]</strong>
</pre><p>The result is as follows:</p><p>计算转移概率。<code class="literal">transitionProbability</code> <code class="literal">()</code>提供对转移概率的直接访问。</p><div><img src="img/image_08_048.jpg" alt="Step 2 - preparing the model"/></div><p>结果如下:</p><p>Ploting the <code class="literal">mcRental</code> object. <code class="literal">plot()</code> is a generic function to plot R objects:</p><pre class="programlisting">
<strong>&gt; plot(mcRental)</strong>
</pre><p>The result is as follows:</p><p><a id="ch08lvl3sec138"/>第三步-改进模型</p><div><img src="img/image_08_049.jpg" alt="Step 2 - preparing the model"/></div><p>计算两次出行中位于市中心的概率；市区到市区:</p><p>计算从东部位置去市区的概率；东至市中心:</p><pre class="programlisting">
<strong>&gt; transitionProbability(mcRental, "East", "West")</strong>
</pre><p>计算从西边位置去市区的概率；从西部到市中心:</p><p>结果如下:</p><div><img src="img/image_08_050.jpg" alt="Step 2 - preparing the model"/></div><p>
</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec138"/>Step 3 - improving the model</h3></div></div></div><p>对<code class="literal">mcRental</code>矩阵求平方以计算概率，我们将分两次前往市中心:</p><pre class="programlisting">
<strong>&gt; x &lt;- 0.3 * 0.3</strong>
</pre><p>结果如下:</p><pre class="programlisting">
<strong>&gt; y &lt;- 0.3 * 0.4</strong>
</pre><p>Calculating the probability of going Downtown from the West location; West to Downtown:</p><pre class="programlisting">
<strong>    &gt; z &lt;- 0.4 * 0.5</strong>
<strong>    &gt; x + y + z</strong>
</pre><p>The result is as follows:</p><p>使用<code class="literal">mcRental</code>矩阵概率计算检查我们将在 20 次旅行中到达市中心的概率，如下所示:</p><div><img src="img/image_08_051.jpg" alt="Step 3 - improving the model"/></div><p>结果如下:</p><p>Squaring the <code class="literal">mcRental</code> matrix to calculate the probability, we will be downtown in two trips:</p><pre class="programlisting">
<strong>&gt; mcRental ^ 2</strong>
</pre><p>The result is as follows:</p><p>使用<code class="literal">mcRental</code>矩阵概率计算检查我们在三次旅行中到达市中心的概率，如下所示:</p><div><img src="img/image_08_052.jpg" alt="Step 3 - improving the model"/></div><p>结果如下:</p><p>Checking the probability that we will be downtown in 20 trips using the <code class="literal">mcRental</code> matrix probability calculation as follows:</p><pre class="programlisting">
<strong>&gt; mcRental ^ 20</strong>
</pre><p>The result is as follows:</p><p>此方法以 markovchain 对象的矩阵形式返回固定向量:</p><div><img src="img/image_08_053.jpg" alt="Step 3 - improving the model"/></div><p>结果如下:</p><p>Checking the probability that we will be downtown in three trips using the <code class="literal">mcRental</code> matrix probability calculation as follows:</p><pre class="programlisting">
<strong>&gt; mcRental ^ 30</strong>
</pre><p>The result is as follows:</p><p>打印<code class="literal">mcRental</code>的摘要:</p><div><img src="img/image_08_054.jpg" alt="Step 3 - improving the model"/></div><p>结果如下:</p><p>This method returns the stationary vector in matrix form of a markovchain object:</p><pre class="programlisting">
<strong>&gt; 70 * steadyStates(mcRental)</strong>
</pre><p>The result is as follows:</p><p>给定当前状态，提取后续状态的条件分布。<code class="literal">mcRental</code>是通过的马尔可夫链对象，而<code class="literal">"Downtown"</code>是下一个状态:</p><div><img src="img/image_08_055.jpg" alt="Step 3 - improving the model"/></div><p>结果如下:</p><p>Printing the summary of <code class="literal">mcRental</code>:</p><pre class="programlisting">
<strong>&gt; summary(mcRental)</strong>
</pre><p>The result is as follows:</p><p>结果如下:</p><div><img src="img/image_08_056.jpg" alt="Step 3 - improving the model"/></div><p>
</p><p>Extracting the conditional distribution of the subsequent state, given the current state. <code class="literal">mcRental</code> is the markov chain object that is passed while <code class="literal">"Downtown"</code> is the next state:</p><pre class="programlisting">
<strong>&gt; conditionalDistribution(mcRental, "Downtown")</strong>
</pre><p>结果如下:</p><p><a id="ch08lvl1sec44"/>连续马尔可夫链——加油站的车辆服务</p><div><img src="img/image_08_057.jpg" alt="Step 3 - improving the model"/></div><p>加油站只有一个油泵。没有车辆等待的空间。如果车辆到达加油站，并且车辆离开时没有一个地方不在加油站加油。车辆以每分钟 3/20 辆的速度遵循泊松过程到达加油站。在到达泵的车辆中，75%是汽车，25%是摩托车。加油时间可以用指数随机变量来建模，汽车的平均值为 8 分钟，摩托车的平均值为 3 分钟。</p><pre class="programlisting">
<strong>&gt; conditionalDistribution(mcRental, "West")</strong>
</pre><p>准备就绪</p><p>为了在加油站执行车辆服务的连续马尔可夫链，我们将模拟数据。</p><div><img src="img/image_08_058.jpg" alt="Step 3 - improving the model"/></div><p><a id="ch08lvl2sec55"/>怎么做...</p><pre class="programlisting">
<strong>&gt; conditionalDistribution(mcRental, "East")</strong>
</pre><p>让我们进入细节。</p><p><a id="ch08lvl3sec139"/>步骤 1 -准备数据集</p><div><img src="img/image_08_059.jpg" alt="Step 3 - improving the model"/></div><p>加载以下包:</p></div></div></div>





<title>Continuous Markov chains - vehicle service at a gas station</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title"><a id="note25"/>注意</h1></div></div></div><p>版本信息:此页面的代码已在 R 版本 3.2.2 中测试过(2015-08-14)</p><div><div><div><div><h2 class="title">初始化车辆到达率:</h2></div></div></div><p>打印<code class="literal">ArrivalRate</code>数据帧:</p></div><div><div><div><div><h2 class="title">结果如下:</h2></div></div></div><p>Let's get into the details.</p><div><div><div><div><h3 class="title"><a id="ch08lvl3sec139"/>Step 1 - preparing the dataset</h3></div></div></div><p>初始化车辆的服务率并创建数据样本。<code class="literal">c()</code>函数将参数组合成一个向量。传递给函数的所有参数被组合成一个公共类型，即返回值的类型。我们将把数据保存到<code class="literal">ServiceRate</code>数据框中:</p><pre class="programlisting">
<strong>    &gt; install.packages("simmer")</strong>
<strong>    &gt; install.packages("ggplot2")</strong>
<strong>    &gt; library(simmer)</strong>
<strong>    &gt; library(ggplot2)</strong>
</pre><div><div><h3 class="title">打印<code class="literal">ServiceRate</code>数据帧:</h3><p>结果如下:</p></div></div><p>Initializing the vehicle arrival rate:</p><pre class="programlisting">
<strong>&gt; ArrivalRate &lt;- 3/20</strong>
</pre><p>Printing the <code class="literal">ArrivalRate</code> data frame:</p><pre class="programlisting">
<strong>&gt; ArrivalRate</strong>
</pre><p>初始化汽车到达的概率:</p><p>创建转换矩阵。<code class="literal">matrix()</code>作为一个函数从一组给定的值中创建一个矩阵。结果存储在<code class="literal">TransitionMatrix</code>数据帧中:</p><div><img src="img/image_08_060.jpg" alt="Step 1 - preparing the dataset"/></div><p>打印<code class="literal">TransitionMatrix</code>数据帧:</p><p>结果如下:</p><pre class="programlisting">
<strong>&gt; ServiceRate &lt;- c(1/8, 1/3)</strong>
</pre><p>Printing the <code class="literal">ServiceRate</code> data frame:</p><pre class="programlisting">
<strong>&gt; ServiceRate</strong>
</pre><p>The result is as follows:</p><p>初始化向量:</p><div><img src="img/image_08_061.jpg" alt="Step 1 - preparing the dataset"/></div><p><a id="ch08lvl3sec140"/>步骤 2 -计算理论分辨率</p><p>解线性方程组。<code class="literal">solve()</code>用于计算线性方程。<code class="literal">t(A)</code>表示转移矩阵，而<code class="literal">B</code>是向量。然后将结果存储在<code class="literal">P</code>中:</p><pre class="programlisting">
<strong>&gt; p &lt;- 0.75</strong>
</pre><p>打印<code class="literal">P</code>数据帧:</p><pre class="programlisting">
<strong>&gt; TransitionMatrix &lt;- matrix(c(1,   ServiceRate[1],     0,</strong>
<strong>    1,   -ArrivalRate,       (1-p)*ArrivalRate,</strong>
<strong>    1,   ServiceRate[2],     -ServiceRate[2]), byrow=T, ncol=3)</strong>
</pre><p>结果如下:</p><pre class="programlisting">
<strong>&gt; TransitionMatrix</strong>
</pre><p>The result is as follows:</p><p>
</p><div><img src="img/image_08_062.jpg" alt="Step 1 - preparing the dataset"/></div><p>计算理论分辨率。<code class="literal">sum()</code>计算总和。然后将结果存储在<code class="literal">Resolution</code>中:</p><p>打印<code class="literal">Resolution</code>数据帧:</p><pre class="programlisting">
<strong>&gt; B &lt;- c(1, 0, 0)</strong>
</pre></div><div><div><div><div><h3 class="title">结果如下:</h3></div></div></div><p>Solving the linear system of equations. <code class="literal">solve()</code> is used to compute the linear equation. <code class="literal">t(A)</code> represents the transition matrix while <code class="literal">B</code> is the vector. The result is then stored in <code class="literal">P</code>:</p><pre class="programlisting">
<strong>&gt; P &lt;- solve(t(A), B)</strong>
</pre><p>Printing the <code class="literal">P</code> data frame:</p><pre class="programlisting">
<strong>&gt; P</strong>
</pre><p><a id="ch08lvl3sec141"/>步骤 3 -验证理论解的收敛性</p><p>模拟系统并验证其收敛于理论解:</p><div><img src="img/image_08_063.jpg" alt="Step 2 - computing the theoretical resolution"/></div><p>定义<code class="literal">option.1</code>功能。一个<code class="literal">create_trajectory()</code>函数创建汽车和摩托车类型的轨迹对象。这些对象包含一系列要附加到生成器对象的活动。执行按名称获取泵对象的活动。<code class="literal">amount=1</code>指需要扣押的物品的数量。<code class="literal">timeout()</code>功能根据用户定义插入延迟。<code class="literal">timeout()</code>函数也接受<code class="literal">rexp()</code>函数，该函数随机生成指数分布，其比率定义为<code class="literal">car</code>对象的<code class="literal">ServiceRate[1] = 1/8</code>和<code class="literal">motorcycle</code>对象的<code class="literal">ServiceRate[1] = 1/3</code>。</p><p>然后如下创建模拟器对象。该方法初始化模拟环境。<code class="literal">car</code>和<code class="literal">motorcycle</code>对象以指数分布创建，比率定义为<code class="literal">p*ArrivalRate</code>，其中<code class="literal">ArrivalRate = 0.15</code>。然后，在模拟环境中创建新的到达生成器:</p><pre class="programlisting">
<strong>&gt; Resolution &lt;- sum(P * c(1, 0, 1)) </strong>
</pre><p>定义<code class="literal">option.2</code>功能。为所有类型的车辆定义单个生成器和单个轨迹。为了区分汽车和摩托车，在抢占资源后定义一个分支来选择合适的服务时间。</p><pre class="programlisting">
<strong>&gt; Resolution</strong>
</pre><p>一个<code class="literal">create_trajectory()</code>功能创建一个<code class="literal">vehicle</code>类型的轨迹对象。该对象包含一系列附加到生成器对象的活动。执行按名称获取泵对象的活动。<code class="literal">amount=1</code>指需要扣押的物品数量。然后<code class="literal">create_trajectory()</code>函数调用<code class="literal">timeout()</code>函数，根据用户定义插入延迟。<code class="literal">timeout()</code>函数也接受<code class="literal">rexp()</code>函数，该函数随机生成指数分布，比率定义为汽车对象的<code class="literal">ServiceRate[1] = 1/8</code>和<code class="literal">motorcycle</code>对象的<code class="literal">ServiceRate[1] = 1/3</code>。</p><p>然后如下创建模拟器对象。该方法初始化模拟环境。<code class="literal">car</code>和<code class="literal">motorcycle</code>对象是以指数分布创建的，其速率定义为<code class="literal">p*ArrivalRate. ArrivalRate = 0.15</code>。然后<code class="literal">run()</code>功能继续运行，直到用户定义的超时，如<code class="literal">until=t</code>中所述:</p><div><img src="img/image_08_064.jpg" alt="Step 2 - computing the theoretical resolution"/></div><p>定义<code class="literal">option.3</code>功能。<code class="literal">option.2</code>增加了不必要的开销。进行额外的调用来选择分支，因此性能下降。在<code class="literal">timeout()</code>功能中直接选择服务时间:</p></div><div><div><div><div><h3 class="title">调用如下创建的选项:</h3></div></div></div><p><a id="ch08lvl3sec142"/>第 4 步-绘制结果</p><pre class="programlisting">
<strong>&gt; set.seed(1234)</strong>
</pre><p>绘制结果。<code class="literal">plot_resource_usage()</code>用于绘制模拟时间范围内的资源使用情况。<code class="literal">gas.station</code>代表单煨环境。<code class="literal">"pump"</code>代表资源的名称。<code class="literal">items="system"</code>指要绘制的资源的组成部分。然后将结果存储在<code class="literal">ggplot2</code>类型图形的对象中:</p><p>结果如下:</p><pre class="programlisting">
<strong>&gt; option.1 &lt;- function(t) {</strong>
<strong>      car &lt;- create_trajectory() %&gt;%</strong>
<strong>          seize("pump", amount=1) %&gt;%</strong>
<strong>          timeout(function() rexp(1, ServiceRate[1])) %&gt;%</strong>
<strong>          release("pump", amount=1)</strong>
</pre><pre class="programlisting">
<strong>      motorcycle &lt;- create_trajectory() %&gt;%</strong>
<strong>          seize("pump", amount=1) %&gt;%</strong>
<strong>          timeout(function() rexp(1, ServiceRate[2])) %&gt;%</strong>
<strong>          release("pump", amount=1)</strong>
</pre><pre class="programlisting">
<strong>      simmer() %&gt;%</strong>
<strong>          add_resource("pump", capacity=1, queue_size=0) %&gt;%</strong>
<strong>          add_generator("car", car, function() rexp(1, p*ArrivalRate)) %&gt;%</strong>
<strong>          add_generator("motorcycle", motorcycle, function() rexp(1, (1-p)*ArrivalRate)) %&gt;%</strong>
<strong>          run(until=t)</strong>
<strong>  }</strong>
</pre><p>Defining the <code class="literal">option.2</code> function. Define a single generator for all kinds of vehicles and a single trajectory. In order to distinguish between cars and motorcycles, define a branch after seizing the resource to select the proper service time.</p><p>A <code class="literal">create_trajectory()</code> function creates the trajectory object of the <code class="literal">vehicle</code> type. This object comprises a chain of activities that is to be attached to a generator object. Activities for seizing the pump object by name are carried out. <code class="literal">amount=1</code> means the number of objects that are required to be seized. The <code class="literal">create_trajectory()</code> function then calls the <code class="literal">timeout()</code> function that inserts the delays based on the user definition. The <code class="literal">timeout()</code> function, also takes in the <code class="literal">rexp()</code> function which randomly generates the exponential distribution with the rate defined as <code class="literal">ServiceRate[1] = 1/8</code> for a car object and <code class="literal">ServiceRate[1] = 1/3</code> for a <code class="literal">motorcycle</code> object.</p><p><a id="ch08lvl1sec45"/>蒙特卡洛模拟-校准船体和白色短装率</p><pre class="programlisting">
<strong>&gt; option.2 &lt;- function(t) {</strong>
<strong>      vehicle &lt;- create_trajectory() %&gt;%</strong>
<strong>          seize("pump", amount=1) %&gt;%</strong>
<strong>          branch(function() sample(c(1, 2), 1, prob=c(p, 1-p)), merge=c(T, T),</strong>
<strong>                 create_trajectory("car") %&gt;%</strong>
<strong>                     timeout(function() rexp(1, ServiceRate[1])),</strong>
<strong>                 create_trajectory("motorcycle") %&gt;%</strong>
<strong>                     timeout(function() rexp(1, ServiceRate[2]))) %&gt;%</strong>
<strong>          release("pump", amount=1)</strong>
<strong>      simmer() %&gt;%</strong>
<strong>          add_resource("pump", capacity=1, queue_size=0) %&gt;%</strong>
<strong>          add_generator("vehicle", vehicle, function() rexp(1, ArrivalRate)) %&gt;%</strong>
<strong>          run(until=t)</strong>
<strong>  }</strong>
</pre><p>蒙特卡罗模拟是对系统行为的随机模拟。模拟使用在模型上执行的采样实验，然后使用计算机进行数值实验，以获得对系统行为的统计理解。</p><pre class="programlisting">
<strong>    &gt; option.3 &lt;- function(t) {</strong>
<strong>       vehicle &lt;- create_trajectory() %&gt;%</strong>
<strong>       seize("pump", amount=1) %&gt;%</strong>
<strong>       timeout(function() {</strong>
<strong>          if (runif(1) &lt; p) rexp(1, ServiceRate[1]) </strong>
<strong>          else rexp(1, ServiceRate[2]) </strong>
<strong>       }) %&gt;%</strong>
<strong>    release("pump", amount=1)</strong>
<strong>    simmer() %&gt;%</strong>
<strong>    add_resource("pump", capacity=1, queue_size=0) %&gt;%</strong>
<strong>    add_generator("vehicle", vehicle, function() rexp(1, ArrivalRate)) %&gt;%</strong>
<strong>    run(until=t)</strong>
<strong>    }</strong>
</pre><p><a id="ch08lvl2sec56"/>做好准备</p><pre class="programlisting">
<strong>&gt; gas.station &lt;- option.3(5000)</strong>
</pre></div><div><div><div><div><h3 class="title">为了对校准的 hull 和 white 短期利率进行蒙特卡罗模拟，数据取自于随<code class="literal">QuantLib</code> 0.3.10 一起提供的样本代码，市场数据用于构建利率期限结构和对应到期日和期限的掉期期权波动率矩阵。</h3></div></div></div><p><a id="ch08lvl3sec143"/>步骤 1 -安装软件包和库</p><pre class="programlisting">
<strong>    &gt; graph &lt;- plot_resource_usage(gas.station, "pump", items="system")</strong>
<strong>    &gt; graph + geom_hline(yintercept = Resolution)</strong>
</pre><p>加载以下包:</p><p><a id="note26"/>注</p><div><img src="img/image_08_065.jpg" alt="Step 4 - plotting the results"/></div><p>版本信息:此页面的代码已在 R 版本 3.2.2 中测试过(2015-08-14)</p></div></div></div>





<title>Monte Carlo simulations - calibrated Hull and White short-rates</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title">为了使 R 环境可以访问部分<code class="literal">Quantlib</code>包，使用了<code class="literal">RQuantLib</code>。<code class="literal">Quantlib</code>软件包为量化金融提供了一个全面的软件框架。<code class="literal">RQuantLib</code>的目标是为本地或远程的建模、交易、源提供源库。GSPC 是资产。</h1></div></div></div><p><code class="literal">type="binary"</code>表示要下载和安装的软件包类型。这意味着要安装的包的性质不是源包。</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec57"/>怎么做...</h2></div></div></div><p>让我们进入细节。</p><div><div><div><div><h3 class="title"><a id="ch08lvl3sec144"/>步骤 2 -初始化数据和变量</h3></div></div></div><p>初始化变量:</p><pre class="programlisting">
<strong>    &gt;install.packages("RQuantLib", type="binary")</strong>
<strong>    &gt;install.packages("ESGtoolkit")</strong>
<strong>    &gt;library(RQuantLib)</strong>
<strong>    &gt;library(ESGtoolkit)</strong>
</pre><div><div><h3 class="title">打印<code class="literal">delta_t</code>的值:</h3><p>结果如下:</p></div></div><p>In order to make part of the <code class="literal">Quantlib</code> package accessible to the R environment <code class="literal">RQuantLib</code> is used. The <code class="literal">Quantlib</code> package provides a comprehensive software framework for quantitative finance. The goal of the <code class="literal">RQuantLib</code> is to provide source libraries for modeling, trading, sources, either local or remote sources. GSPC is assets.</p><p>
<code class="literal">type="binary"</code> indicates the type of package to be downloaded and installed. This means that the nature of the package to be installed is not a source package.</p></div></div><div><div><div><div><h2 class="title">从集成了<code class="literal">QuantLib</code> 0.3.10 的示例代码中初始化变量。指定<code class="literal">tradeDate</code>(月/日/年)、<code class="literal">settleDate</code>、远期汇率时间跨度<code class="literal">dt</code>和两个曲线构建选项的列表:<code class="literal">interpWhat</code>(可能值为贴现、远期和零)和<code class="literal">interpHow</code>(可能值为线性、对数线性和样条)。这里的样条是指<code class="literal">interpWhat</code>值的三次样条插值。</h2></div></div></div><p>然后将结果存储在<code class="literal">params</code>数据帧中:</p><div><div><div><div><h3 class="title">初始化市场数据。期限结构是为利率、存款和互换而构建的。然后将结果存储在<code class="literal">TermQuotes</code>中:</h3></div></div></div><p>正在初始化<code class="literal">Swaptionmaturities</code>:</p><pre class="programlisting">
<strong>    &gt; freq &lt;- "monthly"</strong>
<strong>    &gt; delta_t &lt;- 1/12</strong>
</pre><p>打印<code class="literal">SwaptionMaturities</code>的值:</p><pre class="programlisting">
<strong>&gt; delta_t</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_08_066.jpg" alt="Step 2 - initializing the data and variables"/></div><p>
</p><p>正在初始化交换凸榫:</p><p>打印<code class="literal">SwapTenors</code>的值:</p><pre class="programlisting">
<strong>&gt; params &lt;- list(tradeDate=as.Date('2002-2-15'),</strong>
<strong>                 settleDate=as.Date('2002-2-19'),</strong>
<strong>                 payFixed=TRUE,</strong>
<strong>                 dt=delta_t,</strong>
<strong>                 strike=.06,</strong>
<strong>                 method="HWAnalytic",</strong>
<strong>                 interpWhat="zero",</strong>
<strong>                 interpHow= "spline")</strong>
</pre><p>结果如下:</p><pre class="programlisting">
<strong>&gt; TermQuotes  &lt;- list(d1w =0.0382, # 1-week deposit rate</strong>
<strong>                      d1m =0.0372,# 1-month deposit rate</strong>
<strong>                      d3m = 0.0363,# 3-month deposit rate</strong>
<strong>                      d6m = 0.0353,# 6-month deposit rate</strong>
<strong>                      d9m = 0.0348,# 9-month deposit rate</strong>
<strong>                      d1y = 0.0345,# 1-year deposit rate</strong>
<strong>                      s2y = 0.037125,# 2-year swap rate</strong>
<strong>                      s3y =0.0398,# 3-year swap rate</strong>
<strong>                      s5y =0.0443,# 5-year swap rate</strong>
<strong>                      s10y =0.05165,# 10-year swap rate</strong>
<strong>                      s15y =0.055175)# 15-year swap rate</strong>
</pre><p>Initializing the <code class="literal">Swaptionmaturities</code>:</p><pre class="programlisting">
<strong>&gt; SwaptionMaturities &lt;- c(1,2,3,4,5)</strong>
</pre><p>Printing the value of <code class="literal">SwaptionMaturities</code>:</p><pre class="programlisting">
<strong>&gt; SwaptionMaturities</strong>
</pre><p>初始化波动矩阵。<code class="literal">matrix()</code>函数根据给定的一组值创建一个矩阵。<code class="literal">ncol=5</code>表示所需的列数。<code class="literal">byrow=TRUE</code>表示矩阵按行填充。然后将结果存储在<code class="literal">VolatilityMatrix</code>中:</p><p><a id="ch08lvl3sec145"/>步骤 3 -百慕大互换期权定价</p><div><img src="img/image_08_067.jpg" alt="Step 2 - initializing the data and variables"/></div><p>百慕大互换期权定价如下。<code class="literal">BermudanSwaption</code>是<code class="literal">Quantlib</code>包的一部分。这可以通过使用<code class="literal">RQuantLib</code>访问 R 环境。<code class="literal">BermudanSwaption</code>在将选定的短期利率模型校准到输入互换期权波动率矩阵后，为具有指定执行期和到期日(以年为单位)的百慕大互换期权定价。互换期权的到期日和互换期限都是以年为单位的。假设百慕大互换期权可在基础互换的每个重置日执行。传递<code class="literal">params</code>、<code class="literal">TermQuotes</code>、<code class="literal">SwaptionMaturities</code>、<code class="literal">SwapTenors</code>和<code class="literal">VolatilityMatrix</code>作为输入用于计算百慕大交换选项。结果存储在<code class="literal">BermudanSwaption</code>中:</p><p>显示<code class="literal">BermudanSwaption</code>估价。结果如下:</p><pre class="programlisting">
<strong>&gt; SwapTenors &lt;- c(1,2,3,4,5)</strong>
</pre><p>Printing the value of <code class="literal">SwapTenors</code>:</p><pre class="programlisting">
<strong>&gt; SwapTenors</strong>
</pre><p>The result is as follows:</p><p>打印<code class="literal">BermudanSwaption</code>的摘要:</p><div><img src="img/image_08_068.jpg" alt="Step 2 - initializing the data and variables"/></div><p>结果如下:</p><p>Initializing the volatility matrix. The <code class="literal">matrix()</code> function creates a matrix from the given set of values. <code class="literal">ncol=5</code> denotes the number of desired of columns. <code class="literal">byrow=TRUE</code> means the matrix is filled by rows. The result is then stored in <code class="literal">VolatilityMatrix</code>:</p><pre class="programlisting">
<strong>&gt; VolatilityMatrix &lt;- matrix(</strong>
<strong>      c(0.1490, 0.1340, 0.1228, 0.1189, 0.1148,</strong>
<strong>        0.1290, 0.1201, 0.1146, 0.1108, 0.1040,</strong>
<strong>        0.1149, 0.1112, 0.1070, 0.1010, 0.0957,</strong>
<strong>        0.1047, 0.1021, 0.0980, 0.0951, 0.1270,</strong>
<strong>        0.1000, 0.0950, 0.0900, 0.1230, 0.1160),</strong>
<strong>      ncol=5, byrow=TRUE)</strong>
</pre></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec145"/>Step 3 - pricing the Bermudan swaptions</h3></div></div></div><p>打印<code class="literal">BermudanSwaption</code>的估价:</p><pre class="programlisting">
<strong>&gt; BermudanSwaption &lt;- RQuantLib::BermudanSwaption(params, TermQuotes, SwaptionMaturities, SwapTenors, VolatilityMatrix)</strong>
</pre><p>结果如下:</p><p><a id="ch08lvl3sec146"/>步骤 4 -构建即期利率期限结构</p><div><img src="img/image_08_069.jpg" alt="Step 3 - pricing the Bermudan swaptions"/></div><p>初始化返回折扣因子、远期汇率和零汇率的时间向量。规定时间，使得最大时间加上<code class="literal">delta_t</code>不超过用于校准的仪器的最长到期时间(无外推法):</p><p><code class="literal">DiscountCurve</code>根据包括结算日、存款利率和掉期利率在内的输入市场数据，构建即期利率期限结构。它返回指定为输入的时间向量的相应折扣因子、零利率和远期利率。params 表示一个列表，它指定了<code class="literal">tradeDate</code>(月/日/年)、<code class="literal">settleDate</code>、远期汇率时间跨度和两个曲线构造选项:<code class="literal">interpWhat</code>(可能值为贴现、远期和零)和<code class="literal">interpHow</code>(可能值为<code class="literal">linear</code>、<code class="literal">loglinear</code>和<code class="literal">spline</code>)。这里的样条是指<code class="literal">interpWhat</code>值的三次样条插值。<code class="literal">TermQuotes</code>代表市场报价，用于构建即期利率期限结构。使用以下命令:</p><pre class="programlisting">
<strong>&gt; summary(BermudanSwaption)</strong>
</pre><p>探索<code class="literal">DiscountCurve</code>数据帧的内部结构。<code class="literal">str()</code>功能显示数据帧的内部结构。<code class="literal">DiscountCurve</code>作为 R 对象传递给<code class="literal">str()</code>函数:</p><p>结果如下:</p><div><img src="img/image_08_070.jpg" alt="Step 3 - pricing the Bermudan swaptions"/></div><p>
</p><p>Printing the valuations of <code class="literal">BermudanSwaption</code>:</p><pre class="programlisting">
<strong>&gt; BermudanSwaption</strong>
</pre><p>寻找返回贴现因子、远期利率和零利率的到期时间:</p><p>打印到期值:</p><div><img src="img/image_08_071.jpg" alt="Step 3 - pricing the Bermudan swaptions"/></div><p>结果如下:</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec146"/>Step 4 - constructing the spot term structure of interest rates</h3></div></div></div><p>Initializing the vector of times at which to return the discount factors, forward rates, and zero rates. Times are specified such that the largest time plus <code class="literal">delta_t</code> does not exceed the longest maturity of the instruments used for calibration (no extrapolation):</p><pre class="programlisting">
<strong>&gt; times &lt;- seq(from = delta_t, to = 5, by = delta_t)</strong>
</pre><p>寻找零息票利率:</p><pre class="programlisting">
<strong>&gt; DiscountCurve &lt;- RQuantLib::DiscountCurve(params, TermQuotes, times)</strong>
</pre><p>打印零息票利率的值:</p><pre class="programlisting">
<strong>&gt; str(DiscountCurve)</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_08_072.jpg" alt="Step 4 - constructing the spot term structure of interest rates"/></div><p>
</p><p>寻找折扣系数:</p><pre class="programlisting">
<strong>&gt; maturities &lt;- DiscountCurve$times</strong>
</pre><p>打印折扣系数:</p><pre class="programlisting">
<strong>&gt; maturities</strong>
</pre><p>结果如下:</p><p>
</p><div><img src="img/image_08_073.jpg" alt="Step 4 - constructing the spot term structure of interest rates"/></div><p>
</p><p><a id="ch08lvl3sec147"/>步骤 5 -模拟船壳白短费率</p><pre class="programlisting">
<strong>&gt; MarketZeroRates &lt;- DiscountCurve$zerorates</strong>
</pre><p>设定时间范围:</p><pre class="programlisting">
<strong>&gt; MarketZeroRates</strong>
</pre><p>设置模拟的数量:</p><p>打印<code class="literal">a</code>的值:</p><div><img src="img/image_08_074.jpg" alt="Step 4 - constructing the spot term structure of interest rates"/></div><p>
</p><p>Finding discount factors:</p><pre class="programlisting">
<strong>&gt; MarketPrices &lt;- DiscountCurve$discounts</strong>
</pre><p>打印<code class="literal">sigma</code>的值:</p><pre class="programlisting">
<strong>&gt; MarketPrices</strong>
</pre><p>The result is as follows:</p><p>
</p><div><img src="img/image_08_075.jpg" alt="Step 4 - constructing the spot term structure of interest rates"/></div><p>模拟高斯冲击。<code class="literal">simshocks()</code>为风险因素创建相关或相依高斯冲击的模拟版本。<code class="literal">n = NoSimulations</code>表示模拟次数。<code class="literal">horizon = 5</code>表示时间范围。<code class="literal">frequency = monthly</code>。结果存储在<code class="literal">GaussianShocks</code>数据框中:</p></div><div><div><div><div><h3 class="title"><code class="literal">simdiff()</code>模拟扩散过程。<code class="literal">n = NoSimulations</code>代表独立观察的次数。<code class="literal">frequency = freq</code>是月刊。<code class="literal">model = "OU"</code>代表奥恩斯坦-乌伦贝克方法。<code class="literal">x0 = 0</code>是流程的起始值。<code class="literal">eps = GaussianShocks</code>代表高斯冲击:</h3></div></div></div><p>计算远期汇率。<code class="literal">ts()</code>创建时间序列对象。<code class="literal">replicate(nb.sims, DiscountCurve$forwards)</code>创建时间序列值的向量。<code class="literal">start = start(x)</code>代表第一次观察的时间。<code class="literal">deltat = deltat(x)</code>代表连续观察之间的采样周期的分数。然后将结果存储在<code class="literal">ForwardRates</code>数据帧中:</p><pre class="programlisting">
<strong>&gt; horizon &lt;- 5</strong>
</pre><p>生成规则序列。<code class="literal">from = 0</code>、<code class="literal">to = horizon</code>表示序列的起始值和结束值。<code class="literal">by = delta_t</code>依次表示增量:</p><pre class="programlisting">
<strong>    &gt; NoSimulations &lt;- 10000</strong>
<strong>    &gt; a &lt;- BermudanSwaption$a</strong>
</pre><p>生成短期利率:</p><pre class="programlisting">
<strong>&gt; a</strong>
</pre><p>计算随机折扣值。<code class="literal">r = ShortRates</code>表示短期利率，<code class="literal">X = 1</code>表示资产价格:</p><div><img src="img/image_08_076.jpg" alt="Step 5 - simulating Hull-White short-rates"/></div><p>计算随机折扣值的平均值:</p><pre class="programlisting">
<strong>&gt; sigma &lt;- BermudanSwaption$sigma</strong>
</pre><p>打印<code class="literal">MonteCarloPrices</code>的值:</p><pre class="programlisting">
<strong>&gt; sigma</strong>
</pre><p>结果如下:</p><div><img src="img/image_08_077.jpg" alt="Step 5 - simulating Hull-White short-rates"/></div><p>
</p><p>Simulating Gaussian shocks. <code class="literal">simshocks()</code> create a simulated version of correlated or dependent Gaussian shocks for risk factors. <code class="literal">n = NoSimulations</code> denotes number of simulations. <code class="literal">horizon = 5</code> means the time horizons. <code class="literal">frequency = monthly</code>. The result is then stored in the <code class="literal">GaussianShocks</code> data frame:</p><pre class="programlisting">
<strong>&gt; GaussianShocks &lt;- ESGtoolkit::simshocks(n = NoSimulations, horizon = horizon, frequency = freq)</strong>
</pre><p>计算随机折扣值的零利率:</p><pre class="programlisting">
<strong>&gt; x &lt;- ESGtoolkit::simdiff(n = NoSimulations, horizon = horizon, frequency = freq, model = "OU", x0 = 0, theta1 = 0, theta2 = a, theta3 = sigma, eps = GaussianShocks)</strong>
</pre><p>打印<code class="literal">MonteCarloZeroRates</code>的值:</p><pre class="programlisting">
<strong>&gt; ForwardRates &lt;- ts(replicate(nb.sims, DiscountCurve$forwards), start = start(x), deltat = deltat(x))</strong>
</pre><p>结果如下:</p><pre class="programlisting">
<strong>    &gt; t.out &lt;- seq(from = 0, to = horizon, by = delta_t)</strong>
<strong>    &gt; param.alpha &lt;- ts(replicate(NoSimulations, 0.5*(sigma^2)*(1 - exp(-a*t.out))^2/(a^2)), start = start(x), deltat = deltat(x))</strong>
<strong>    &gt; alpha &lt;- ForwardRates + param.alpha</strong>
</pre><p>Generating the short-term rates:</p><pre class="programlisting">
<strong>&gt; ShortRates &lt;- x + alpha</strong>
</pre><p>Calculating stochastic discount values. <code class="literal">r = ShortRates</code> denotes the short term rates, <code class="literal">X = 1</code> denotes the asset's price:</p><pre class="programlisting">
<strong>&gt; StochasticDiscount &lt;- ESGtoolkit::esgdiscountfactor(r = ShortRates, X = 1)</strong>
</pre><p>对随机折扣条款和市场价格之间的差异进行 student t 检验。<code class="literal">t.test(x)</code>执行 t 检验。<code class="literal">conf.int</code>均值为均值的置信区间适当:</p><pre class="programlisting">
<strong>&gt; MonteCarloPrices &lt;- rowMeans(StochasticDiscount)</strong>
</pre><p><code class="literal">head()</code>函数返回<code class="literal">ConfidenceInterval</code>帧的第一部分。<code class="literal">ConfidenceInterval</code>帧作为输入参数传递如下:</p><pre class="programlisting">
<strong>&gt; MonteCarloPrices</strong>
</pre><p>The result is as follows:</p><p>
</p><div><img src="img/image_08_078.jpg" alt="Step 5 - simulating Hull-White short-rates"/></div><p>按如下方式设置图形参数:</p><p><code class="literal">esgplotbands()</code>绘制色带置信区间如下。<code class="literal">ShortRates</code>代表置信区间:</p><pre class="programlisting">
<strong>&gt; MonteCarloZeroRates &lt;- -log(MonteCarloPrices)/maturities</strong>
</pre><p>Printing the values of <code class="literal">MonteCarloZeroRates</code>:</p><pre class="programlisting">
<strong>&gt; MonteCarloZeroRates</strong>
</pre><p>The result is as follows:</p><p>绘制<strong>蒙特卡洛 v/s 市场 n 零利率</strong>如下。到期日，<code class="literal">MonteCarloZeroRates</code>代表时间序列:</p><div><img src="img/image_08_079.jpg" alt="Step 5 - simulating Hull-White short-rates"/></div><p>
</p><p>Performing the student t test on the difference between stochastic discount terms and market prices. <code class="literal">t.test(x)</code> performs the t test. <code class="literal">conf.int</code> means confidence interval for the mean appropriate:
</p><pre class="programlisting">
<strong>&gt; ConfidenceInterval &lt;- t(apply((StochasticDiscount - MarketPrices)[-1, ], 1, function(x) t.test(x)$conf.int))</strong>
</pre><p>在到期日之间的图的指定坐标处添加一系列点，<code class="literal">MonteCarloZeroRates</code>:</p><pre class="programlisting">
<strong>&gt; head(ConfidenceInterval)</strong>
</pre><p>
</p><div><img src="img/image_08_080.jpg" alt="Step 5 - simulating Hull-White short-rates"/></div><p>
</p><p>绘制蒙特卡洛 v/s 市场价格如下。到期日，<code class="literal">MonteCarloPrices</code>代表时间序列:</p><pre class="programlisting">
<strong>&gt; par(mfrow = c(2, 2))</strong>
</pre><p>在到期日之间的图的指定坐标处添加一系列点，<code class="literal">MonteCarloPrices</code>:</p><pre class="programlisting">
<strong>&gt; ESGtoolkit::esgplotbands(ShortRates, xlab = "maturities", ylab = "short-rate quantiles", main = "Short Rate Quantiles")</strong>
</pre><p>
</p><div><img src="img/image_08_081.jpg" alt="Step 5 - simulating Hull-White short-rates"/></div><p>
</p><p>Plotting the <strong>Monte Carlo v/s Market n Zero Rates</strong> as follows. maturities, <code class="literal">MonteCarloZeroRates</code> represents the time series:</p><pre class="programlisting">
<strong>&gt; plot(maturities, MonteCarloZeroRates, type='l', col = 'blue', lwd = 1, main = "Monte Carlo v/s Market n Zero Rates")</strong>
</pre><p>
</p><div><img src="img/image_08_082.jpg" alt="Step 5 - simulating Hull-White short-rates"/></div><p>
</p><p>Adding a sequence of points at the specified coordinates of the plot between maturities, <code class="literal">MonteCarloZeroRates</code>:</p><pre class="programlisting">
<strong>&gt; points(maturities, MonteCarloZeroRates, col = 'red')</strong>
</pre><p>
</p><div><img src="img/image_08_083.jpg" alt="Step 5 - simulating Hull-White short-rates"/></div><p>
</p><p>Plotting the Monte Carlo v/s Market Prices as follows. maturities, <code class="literal">MonteCarloPrices</code> represents the time series:</p><pre class="programlisting">
<strong>&gt; plot(maturities, MonteCarloPrices, type='l', col = 'blue', lwd = 1, main = "Monte Carlo v/s Market Prices")</strong>
</pre><p>
</p><div><img src="img/image_08_084.jpg" alt="Step 5 - simulating Hull-White short-rates"/></div><p>
</p><p>Adding a sequence of points at the specified coordinates of the plot between maturities, <code class="literal">MonteCarloPrices</code>:</p><pre class="programlisting">
<strong>&gt; points(maturities, MonteCarloPrices, col = 'red')</strong>
</pre><p>
</p><div><img src="img/image_08_085.jpg" alt="Step 5 - simulating Hull-White short-rates"/></div><p>
</p><pre class="programlisting">
<strong>&gt; matplot(maturities[-1], conf.int, type = 'l', main = "Confidence Interval for the price difference")</strong>
</pre></div></div></div>
</body></html>