<html><head/><body>



<title>Chapter 6. Getting Started with Django</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title"><a id="ch06"/>第六章。Django入门</h1></div></div></div><p>Django  <a id="id490" class="indexterm"/>是一个在商业环境中使用的开源web框架，因为它易于使用、稳定且灵活(它利用了Python中可用的多个库)。</p><p>在这一章中，我们将关注我们认为对于管理和分析框架中的数据至关重要的特性。我们还解释了与构建基本web应用程序相关的主要部分，但是更多的细节和信息可以在网上的<a class="ulink" href="https://docs.djangoproject.com">https://docs.djangoproject.com</a>或其他来源找到。我们将介绍框架的主要部分，包括web服务器应用程序的基本概念(设置、模型和命令)、HTML和shell接口的基础知识、REST框架接口的一般思想以及如何在Django中实现它(序列化器、REST调用和swagger)。在简单介绍了通过互联网传输数据的HTTP GET和POST方法之后，我们开始在Django中安装和创建一个新的服务器。</p><div><div><div><div><h1 class="title"><a id="ch06lvl1sec39"/>HTTP–GET和POST方法的基础</h1></div></div></div><p><strong>超文本传输协议</strong> ( <strong> HTTP </strong>)允许客户端(例如，网络浏览器)与<a id="id491" class="indexterm"/>服务器(我们的应用程序)进行交互。给定<a id="id492" class="indexterm"/>一个服务器web <a id="id493" class="indexterm"/>页面的URL，GET方法是<a id="id494" class="indexterm"/>客户端从服务器查询数据的方式，指定<a id="id495" class="indexterm"/>一些参数。这可以使用<code class="literal">curl</code>命令来解释，如下所示:</p><div><pre class="programlisting">
<strong>curl -X GET url_path?name1=value1&amp;name2=value2</strong>
</pre></div><p>在<code class="literal">?</code>符号之后，名称/值对指定要查询的数据，它们由一个<code class="literal">&amp;</code>符号分隔。</p><p>客户端向服务器传输数据的方式称为POST，数据在调用的<em>体</em>中:</p><div><pre class="programlisting">
<strong>curl -X POST  -d @datafile.txt url_path</strong>
</pre></div><p>现在我们可以开始讨论如何使用Django创建一个新的服务器和应用程序。</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec38"/>安装和服务器创建</h2></div></div></div><p>Django库<a id="id496" class="indexterm"/>通过在<a id="id497" class="indexterm"/>终端键入以下命令来安装:</p><div><pre class="programlisting">
<strong>sudo pip instal django</strong>
</pre></div><p>该命令应该安装Django版或更高版本(作者用的是1.7版)。为了启动一个新的应用程序，我们键入以下命令:</p><div><pre class="programlisting">
<strong>django-admin startproject test_server</strong>
</pre></div><p>它将生成一个新文件夹<code class="literal">test_app</code>,包含以下文件树:</p><div><pre class="programlisting">
<strong>└── test_server</strong>
<strong>    ├── manage.py</strong>
<strong>    └── test_server</strong>
<strong>        ├── __init__.py</strong>
<strong>        ├── settings.py</strong>
<strong>        ├── urls.py</strong>
<strong>        └── wsgi.py</strong>
</pre></div><p>我们可以看到，在该文件夹中，我们有一个<code class="literal">manage.py</code>文件，它允许程序员运行各种操作，还有另一个子文件夹<code class="literal">test_app</code>，它包含以下文件:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">settings.py</code>:存储配置服务器的所有参数设置</li><li class="listitem" style="list-style-type: disc"><code class="literal">urls.py</code>:它收集了你的web应用程序中所有可用的URL路径，网页背后的实际功能通常写在<code class="literal">views.py</code> app文件中</li><li class="listitem" style="list-style-type: disc"><code class="literal">wsgi.py</code>:这是一个让服务器与web应用程序通信的模块</li><li class="listitem" style="list-style-type: disc"><code class="literal">__init__.py</code>:该文件用于将每个文件夹定义为一个包，在内部导入模块</li></ul></div><p>在我们的本地机器上，带有<strong>欢迎来到Django </strong>页面的服务器部署在<code class="literal">http://127.0.0</code>T5上，只需输入以下命令:</p><div><pre class="programlisting">
<strong>python manage.py runserver 8080</strong>
</pre></div><p>这里，<code class="literal">8080</code>是服务器启动的端口(如果没有指定端口，默认情况下服务器在<code class="literal">port 8000</code>启动)。现在服务器已经准备好了，我们可以创建任意多的应用程序，只需输入以下命令:</p><div><pre class="programlisting">
<strong>python manage.py startapp nameapp</strong>
</pre></div><p>这将在根目录下的<code class="literal">test_app</code>文件夹中创建一个新文件夹<code class="literal">nameapp</code>:</p><div><pre class="programlisting">
<strong>├── manage.py</strong>
<strong>├── nameapp</strong>
<strong>│   ├── __init__.py</strong>
<strong>│   ├── admin.py</strong>
<strong>│   ├── migrations</strong>
<strong>│   ├── __init__.py</strong>
<strong>│   ├── models.py</strong>
<strong>│   ├── tests.py</strong>
<strong>│   └── views.py</strong>
<strong>└── test_server</strong>
<strong>    ├── __init__.py</strong>
<strong>    ├── settings.py</strong>
<strong>    ├── urls.py</strong>
<strong>    └── wsgi.py</strong>
</pre></div><p>在<a id="id499" class="indexterm"/>解释完最重要的设置参数后，我们将<a id="id498" class="indexterm"/>讨论该文件夹的内容及其功能。注意，对于Django版本1.9，<code class="literal">nameapp</code>文件夹包含<code class="literal">apps.py</code>文件，以便在不使用<code class="literal">settings.py</code>文件的情况下配置<code class="literal">nameapp</code>。</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec39"/>设置</h2></div></div></div><p>文件<code class="literal">settings.py</code>存储了Django服务器运行所需的所有配置。要设置的最重要的参数如下:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Apart from the common Django apps installed by default to manage a website, we will also install the REST framework:<div><pre class="programlisting">INSTALLED_APPS = (
...
'rest_framework',
'rest_framework_swagger',
'nameapp',
)</pre></div><p>REST框架是一个允许Django app(本例中为<code class="literal">nameapp</code>)通过REST API进行通信的应用，REST框架Swagger只是一个管理REST API的web交互接口。这些功能将在下面的章节中解释。另外，请注意，创建的每个应用程序都需要添加到该字段中(在本例中为<code class="literal">nameapp</code>)。</p></li><li class="listitem" style="list-style-type: disc">Different backend <a id="id501" class="indexterm"/>databases (<strong>MySQL</strong>, <strong>Oracle</strong>, <strong>PostgreSQL</strong>, and so on) can<a id="id502" class="indexterm"/> be <a id="id503" class="indexterm"/>used to store the data. In this case, we use <a id="id504" class="indexterm"/><strong>SQLite3</strong> (the default option):<div><pre class="programlisting">DATABASES = {
       'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': 'mydatabase',
        }
      }</pre></div><p>网页是用HTML编写的，所以需要一个文件夹来存储HTML代码。<code class="literal">templates</code>文件夹通常用于存储网页布局:</p><div><pre class="programlisting">TEMPLATE_DIRS = (
    os.path.join(BASE_DIR, 'templates'),
)</pre></div></li><li class="listitem" style="list-style-type: disc">为了修饰一个<a id="id505" class="indexterm"/>网站，CSS格式和JavaScript代码通常存储在另一个文件夹<code class="literal">static</code>中，与<code class="literal">server</code>文件夹在同一层。然后需要配置设置从文件夹中取出文件:<div> <pre class="programlisting">MEDIA_ROOT = os.path.join(BASE_DIR, 'static') STATIC_URL = '/static/' MEDIA_URL = '' STATIC_ROOT = '' STATICFILES_DIRS = ( os.path.join(BASE_DIR, "static"), )</pre> </div></li><li class="listitem" style="list-style-type: disc">要设置网站的URL，设置配置为从文件中获取路径(本例中为<code class="literal">test_server/urls.py</code> ): <div> <pre class="programlisting">ROOT_URLCONF = 'test_server.urls'</pre> </div></li><li class="listitem" style="list-style-type: disc">It is possible to set up a file to store all the printout statements we want to put in the code for debugging purposes. We use the <code class="literal">logging</code> library and the following configuration:<div><pre class="programlisting">LOGGING = {
    'version': 1,
    'disable_existing_loggers': True,
    'formatters': {
        'standard': {
            'format': '%(asctime)s %(levelname)s %(name)s %(message)s'
        },
    },
    'handlers': {
        'default': {
            'level':'DEBUG',
            'class':'logging.handlers.RotatingFileHandler',
            'filename': 'test_server.log',
            'maxBytes': 1024*1024*5, # 5 MB
            'backupCount': 5,
            'formatter':'standard',
        },  
    },
'loggers': {
        '': {
            'handlers': ['default'],
            'level': 'DEBUG',
            'propagate': True
        },
    }
}</pre></div><p>在这里，<code class="literal">test_server.log</code>文件存储了使用<code class="literal">logging</code>库定义的所有打印语句(例如，<code class="literal">logging.debug('write something')</code>)。</p></li></ul></div><p>现在所有最重要的设置都配置好了，我们可以专注于开发一个新的应用程序来创建一个简单的电子邮件地址簿。所以我们像往常一样创建应用程序:</p><div><pre class="programlisting">
<strong>python manage.py startapp addresesapp</strong>
</pre></div><p>现在，我们在服务器的根目录<code class="literal">test_server</code>下添加模板和静态文件夹:</p><div><pre class="programlisting">
<strong>├── addresesapp</strong>
<strong>│</strong>
<strong>   ├── __init__.py</strong>
<strong>│   ├── admin.py</strong>
<strong>│   ├── migrations</strong>
<strong>│   ├── models.py</strong>
<strong>│   ├── tests.py</strong>
<strong>│</strong>
<strong>   └── views.py</strong>
<strong>├── manage.py</strong>
<strong>└── test_server</strong>
<strong>    ├── __init__.py</strong>
<strong>    ├── __init__.pyc</strong>
<strong>    ├── settings.py</strong>
<strong>    ├── settings.pyc</strong>
<strong>    ├── static</strong>
<strong>    ├── templates</strong>
<strong>    ├── </strong>
<strong>urls.py</strong>
<strong>    └── wsgi.py</strong>
</pre></div><p>注意<a id="id507" class="indexterm"/>上的<code class="literal">nameapp</code>变成了<code class="literal">addressesapp</code>。在下一节中，我们将讨论如何实现该应用程序的主要功能。所有代码都可以在作者的GitHub资源库的<code class="literal">chapter_6</code>文件夹中找到(<a class="ulink" href="https://github.com/ai2010/machine_learning_for_the_web/tree/master/chapter_6">https://GitHub . com/ai 2010/machine _ learning _ for _ the _ web/tree/master/chapter _ 6</a>)。</p></div></div></div>





<title>Writing an app – most important features</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title"><a id="ch06lvl1sec40"/>编写应用程序——最重要的功能</h1></div></div></div><p>要创建一个存储电子邮件地址的web应用程序，我们需要一个表来存储数据和web页面，允许最终用户添加、删除和查看地址簿。此外，我们可能希望将地址簿转换为电子表格，或者通过互联网将数据发送到另一个应用程序。有特定的Django特性来完成所有这些动作(<code class="literal">models</code>、<code class="literal">views</code>、<code class="literal">admin</code>、API REST-framework和<code class="literal">commands</code>)，我们现在将讨论数据存储的方式。</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec40"/>车型</h2></div></div></div><p>要创建电子邮件地址簿，我们需要在一个表中存储每个联系人的姓名及其电子邮件地址。Django中的表格称为模型，它在<code class="literal">models.py</code>文件中定义:</p><div><pre class="programlisting">
<strong>from django.db import models</strong>
<strong>from django.utils.translation import ugettext_lazy as _</strong>

<strong>class Person(models.Model):</strong>
<strong>    name = models.CharField(_('Name'), max_length=255, unique=True)</strong>
<strong>    mail = models.EmailField(max_length=255, blank=True)</strong>
<strong>    #display name on admin panel</strong>
<strong>    def __unicode__(self):</strong>
<strong>            return self.name</strong>
</pre></div><p>在Django中，表的<a id="id509" class="indexterm"/>列是模型的字段，可以是不同类型的<a id="id510" class="indexterm"/>:integer、char等等。注意，Django会自动为任何新对象添加一个增量ID字段。unique选项意味着模型中不能存在重复的名称，而blank表示字段是否可以为空。<code class="literal">__unicode__</code>函数是可选的，它用于将每个人呈现为一个字符串(在本例中我们设置了姓名字符串)。</p><p>既然已经创建了模型，我们需要将它应用到SQLite数据库:</p><div><pre class="programlisting">
<strong>python manage.py makemigrations</strong>
<strong>python manage.py migrate</strong>
</pre></div><p><code class="literal">makemigrations</code>将模型变更转换到迁移文件中(对于<code class="literal">addressesapp</code>中的文件夹<code class="literal">migrations</code>，而<code class="literal">migrate</code>将变更应用到数据库模式中。注意，如果同一个网站使用多个应用程序，那么<a id="id511" class="indexterm"/>生成<a id="id512" class="indexterm"/>迁移的命令是<code class="literal">python manage.py makemigrations 'appname'</code>。</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec41"/>HTML网页背后的URL和视图</h2></div></div></div><p>现在<a id="id513" class="indexterm"/>我们知道了如何存储数据，我们需要通过<a id="id514" class="indexterm"/>网页记录联系人，并在另一个页面显示联系人。在下面的<a id="id515" class="indexterm"/>小节中，我们将简要介绍HTML页面的主要属性。</p><div><div><div><div><h3 class="title"><a id="ch06lvl3sec35"/> HTML页面</h3></div></div></div><p>本节解释的所有代码<a id="id516" class="indexterm"/>都存储在<code class="literal">test_server</code>文件夹下的文件夹模板中。</p><p>应用程序的主页面允许用户记录一个新的联系人，它看起来像下面的屏幕截图:</p><div><img src="img/B05143_06_01.jpg" alt="HTML pages"/></div><p>正如您所看到的，页面的主体由两个框指定，这两个框中要填入用户的姓名和电子邮件地址，按下<strong> Add </strong>将它们添加到数据库中。HTML文件<code class="literal">home.html</code>如下所示:</p><div><pre class="programlisting">{% extends "addressesapp/base.html" %}

{% block content %}
        &lt;form action="" method="POST"&gt;
            {% csrf_token %}
            &lt;h2 align = Center&gt;Add person to address book &lt;/h2&gt;
            &lt;p&gt; &lt;br&gt;&lt;br&gt;&lt;/p&gt;
            &lt;p align = Center&gt;&lt;input type="search" class="span3" placeholder="person" name="name" id="search" autofocus /&gt; &lt;/p&gt;
            &lt;p align = Center&gt;&lt;input type="search" class="span3" placeholder="email" name="email" id="search" autofocus /&gt; &lt;/p&gt;
            &lt;p align = Center&gt;&lt;button type="submit" class="btn btn-primary btn-large pull-center"&gt;Add &amp;raquo;&lt;/button&gt;&lt;/p&gt;
        &lt;/form&gt;  
{% endblock content %}</pre></div><p>我们使用<a id="id517" class="indexterm"/> POST表单提交由两个段落字段(由<code class="literal">&lt;p&gt;...&lt;/p&gt;</code>指定)收集并由<strong> Add </strong>按钮标签激活的数据(<code class="literal">&amp;raquo</code>:是呈现文本后的小箭头)。页面标题<strong>将人员添加到地址簿</strong>，由类型2 ( <code class="literal">&lt;h2&gt;...&lt;/h2&gt;</code>)的标题呈现。请注意<code class="literal">csrt_token</code>标签，它启用了<a id="id518" class="indexterm"/>跨站点伪造保护请求(更多信息请参见<a class="ulink" href="https://www.squarefree.com/securitytips/web-developers.html#CSRF">https://www . square free . com/security tips/we b-developers . html # CSRF</a>)。</p><p>页面的样式(CSS和JavaScript文件)，以及带有<strong>主页</strong>、<strong>电子邮件簿</strong>和<strong>查找</strong>按钮的页脚和标题栏都在<code class="literal">base.html</code>文件中定义(参见<code class="literal">template</code>文件夹)。<strong>查找</strong>按钮以表单形式实现:</p><div><pre class="programlisting">&lt;form class="navbar-search pull-left" action="{% url 'get_contacts' %}" method="GET"&gt;
          {% csrf_token %}
           &lt;div style="overflow: hidden; padding-right: .5em;"&gt;
             &lt;input type="text" name="term" style="width: 70%;" /&gt;
             &lt;input type="submit" name="search" value="Find" size="30" style="float: right" /&gt;
            &lt;/div&gt;
        &lt;/form&gt;</pre></div><p>标签<code class="literal">div</code>用于定义文本字段和<strong> Find </strong>按钮，该按钮激活对在<code class="literal">urls.py</code>文件中定义为<code class="literal">get_contacts</code>的URL的GET调用(见下一节)。</p><p>要显示的另一页是地址簿:</p><div><img src="img/B05143_06_02.jpg" alt="HTML pages"/></div><div><pre class="programlisting">{% extends "addressesapp/base.html" %}

{% block content %}
&lt;h2 align = Center&gt;Email address book&lt;/h2&gt;
&lt;P align=Center&gt;[
{% for letter in alphabet %}
which is given by the book.html file:
{% extends "addressesapp/base.html" %}

{% block content %}
&lt;h2 align = Center&gt;Email address book&lt;/h2&gt;
&lt;P align=Center&gt;[
{% for letter in alphabet %}
&lt;a href="{% url 'addressesbook'  %}?letter={{letter}}" &gt; {{letter}} &lt;/a&gt;
{% endfor %}
|&lt;a href="addressesapp/book.html"&gt; Index &lt;/a&gt; ] &lt;/P&gt;
&lt;section id="gridSystem"&gt;
{% for contact in contacts %}
&lt;div class="row show-grid"&gt;
	&lt;p align = Center&gt;&lt;strong&gt; name: &lt;/strong&gt;{{ contact.name }} &lt;strong&gt;email:&lt;/strong&gt; {{ contact.mail }}&amp;nbsp&amp;nbsp&amp;nbsp&amp;nbsp
        &lt;a class="right" href="{% url 'delete_person' contact.name  %}" &gt;   delete &lt;/a&gt;
    &lt;/p&gt;
&lt;/div&gt;
{% endfor %}
&lt;/section&gt;

{% endblock content %}</pre></div><p>再次调用<code class="literal">base.html</code>来呈现主要的标题按钮、页脚和样式。在包含<strong>电子邮件地址簿</strong>的标题(类型2)之后，对字母<code class="literal">{% for letter in alphabet %}</code>执行<code class="literal">for</code>循环，以仅显示以<a id="id519" class="indexterm"/>对应字母开始的联系人。这是通过调用带有字母的<code class="literal">addressesbook </code> URL来查询<code class="literal">{{letter}}</code>来实现的。然后显示联系人列表，在联系人列表上循环<code class="literal">{% for contact in contacts %}</code>:一个段落标签显示姓名、电子邮件和一个按钮，用于从数据库中删除这个人。我们现在将讨论页面操作(添加、查找或删除人员，以及显示地址簿)的实现。</p></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec42"/> URL声明和视图</h2></div></div></div><p>我们现在将<a id="id520" class="indexterm"/>讨论<code class="literal">urls.py</code>和<code class="literal">views.py</code>与每个页面的HTML代码一起执行期望的<a id="id522" class="indexterm"/>动作的方式。</p><p>正如我们所看到的，应用程序的两个主要页面home和address book都与一个URL相关联，在Django中，这个URL是在<code class="literal">urls.py</code>文件中声明的:</p><div><pre class="programlisting">
<strong>from django.conf.urls import patterns, include, url</strong>
<strong>from django.contrib import admin</strong>
<strong>from addressesapp.api import AddressesList</strong>

<strong>urlpatterns = patterns('',</strong>
<strong>    url(r'^docs/', include('rest_framework_swagger.urls')),</strong>
<strong>    url(r'^$','addressesapp.views.main'),</strong>
<strong>    url(r'^book/','addressesapp.views.addressesbook',name='addressesbook'),</strong>
<strong>    url(r'^delete/(?P&lt;name&gt;.*)/','addressesapp.views.delete_person', name='delete_person'),</strong>
<strong>    url(r'^book-search/','addressesapp.views.get_contacts', name='get_contacts'),</strong>
<strong>    url(r'^addresses-list/', AddressesList.as_view(), name='addresses-list'),</strong>
<strong>    url(r'^notfound/','addressesapp.views.notfound',name='notfound'),url(r'^admin/', include(admin.site.urls)),)</strong>
</pre></div><p>每个URL由一个regex(URL字符串前面的一个<code class="literal">r</code>)指定，因此主页面由<code class="literal">http://127.0.0.1:8000/</code>指定(<code class="literal">^</code>开始符号后面是<code class="literal">$</code>结束符号)，其动作(<code class="literal">add record</code>)在<code class="literal">views.py</code>文件的<code class="literal">main</code>函数中实现:</p><div><pre class="programlisting">
<strong>def main(request):    </strong>
<strong>    context={}</strong>
<strong>    if request.method == 'POST':</strong>
<strong>        post_data = request.POST</strong>
<strong>        data = {}</strong>
<strong>        data['name'] = post_data.get('name', None)</strong>
<strong>        data['email'] = post_data.get('email', None)</strong>
<strong>        if data:</strong>
<strong>            return redirect('%s?%s' % (reverse('addressesapp.views.main'),</strong>
<strong>                                urllib.urlencode({'q': data})))</strong>
<strong>    elif request.method == 'GET':</strong>
<strong>        get_data = request.GET</strong>
<strong>        data= get_data.get('q',None)</strong>
<strong>        if not data:</strong>
<strong>            return render_to_response(</strong>
<strong>                'addressesapp/home.html', RequestContext(request, context))</strong>
<strong>        data = literal_eval(get_data.get('q',None))</strong>
<strong>        print data</strong>
<strong>        if not data['name'] and not data['email']:</strong>
<strong>            return render_to_response(</strong>
<strong>                'addressesapp/home.html', RequestContext(request, context))</strong>
<strong>                </strong>
<strong>        #add person to emails address book or update</strong>
<strong>        if Person.objects.filter(name=data['name']).exists():</strong>
<strong>            p = Person.objects.get(name=data['name'])</strong>
<strong>            p.mail=data['email']</strong>
<strong>            p.save()</strong>
<strong>        else:</strong>
<strong>            p = Person()</strong>
<strong>            p.name=data['name']</strong>
<strong>            p.mail=data['email']</strong>
<strong>            p.save()</strong>
<strong>            </strong>
<strong>        #restart page</strong>
<strong>        return render_to_response(</strong>
<strong>            'addressesapp/home.html', RequestContext(request, context)) </strong>
</pre></div><p>每当<a id="id523" class="indexterm"/>用户发布一个要存储的新联系人时，POST <a id="id524" class="indexterm"/>方法<a id="id525" class="indexterm"/>将调用重定向到GET方法。如果已经提供了名称和电子邮件，那么将添加一个新的<code class="literal">Person</code>模型对象，或者更新它(如果它已经存在的话)。在此方法中，大写字母的相同姓名将被视为不同的姓名，因此<code class="literal">Andrea</code>、<code class="literal">ANDREA</code>和<code class="literal">andrea</code>将是三个独立的联系人。要改变这一点，读者可以简单地对name字段应用lower函数，这样三个<a id="id526" class="indexterm"/>表达式将都指向一个<code class="literal">andrea</code>。</p><p><code class="literal">base.html</code>文件中的<a id="id527" class="indexterm"/> find <a id="id528" class="indexterm"/>动作与<code class="literal">http://127.0.0.1:8000/book-search/</code> URL关联，该动作在<code class="literal">views.py</code>的<code class="literal">get_contacts</code>函数中定义:</p><div><pre class="programlisting">
<strong>def get_contacts(request):</strong>
<strong>    logging.debug('here')</strong>
<strong>    if request.method == 'GET':</strong>
<strong>        get_data = request.GET</strong>
<strong>        data= get_data.get('term','')</strong>
<strong>        if data == '':</strong>
<strong>            return render_to_response(</strong>
<strong>               'addressesapp/nopersonfound.html', RequestContext(request, {}))</strong>
<strong>        else:</strong>
<strong>            return redirect('%s?%s' % (reverse('addressesapp.views.addressesbook'),</strong>
<strong>    urllib.urlencode({'letter': data})))</strong>
</pre></div><p>如果用户在文本头字段上指定一个非空字符串，该函数将重定向到具有要搜索的名称的<code class="literal">addressesbook</code>函数(否则显示一个未找到的页面)。</p><p>标题按钮<strong>电子邮件簿</strong>链接到<code class="literal">http://127.0.0.1:8000/book/</code> URL，根据<code class="literal">addressesbook</code>功能显示联系人:</p><div><pre class="programlisting">
<strong>def addressesbook(request):</strong>
<strong>    context = {}</strong>
<strong>    logging.debug('address book')</strong>
<strong>    get_data = request.GET</strong>
<strong>    letter = get_data.get('letter',None)</strong>
<strong>    if letter:</strong>
<strong>        contacts = Person.objects.filter(name__iregex=r"(^|\s)%s" % letter)</strong>
<strong>    else:</strong>
<strong>        contacts = Person.objects.all()</strong>
<strong>    #sorted alphabetically</strong>
<strong>    contacts = sort_lower(contacts,"name")#contacts.order_by("name")</strong>
<strong>    context['contacts']=contacts</strong>
<strong>    alphabetstring='ABCDEFGHIJKLMNOPQRSTUVWXYZ'</strong>
<strong>    context['alphabet']=[l for l in alphabetstring]</strong>
<strong>    return render_to_response(</strong>
<strong>        'addressesapp/book.html', RequestContext(request, context)) </strong>
<strong>def sort_lower(lst, key_name):</strong>
<strong>    return sorted(lst, key=lambda item: getattr(item, key_name).lower())</strong>
</pre></div><p>信件字段<a id="id529" class="indexterm"/>存储姓名(在从<strong>查找</strong>标题按钮重定向的情况下)或信件(在从电子邮件簿页面呼叫的情况下)，并且在<code class="literal">Person</code>模型中的联系人上执行查找<a id="id530" class="indexterm"/>。检索到的联系人<a id="id531" class="indexterm"/>存储在<code class="literal">contacts</code>上下文对象中，而字母存储在<code class="literal">alphabet</code>上下文对象中。如果没有指定字母，则返回数据库中的所有联系人。请注意，名称可以同时包含大写和小写首字母，因此常用的<code class="literal">order_by</code>方法不会按字母顺序对名称进行排序。因此，函数<code class="literal">sort_lower</code>会将每个名字转换成小写，并按字母顺序对联系人进行排序。</p><p>删除操作由<code class="literal">delete_person</code>函数执行，并由<code class="literal">http://127.0.0.1:8000/delete/(?P&lt;name&gt;.*)/</code> URL调用。<code class="literal">.*</code>表示所有的字符对于构成一个名称都是有效的(注意，如果我们只需要字符数字和空白，我们应该有<code class="literal">[a-zA-Z0-9 ]+</code>):</p><div><pre class="programlisting">
<strong>def delete_person(request,name):</strong>
<strong>    if Person.objects.filter(name=name).exists():</strong>
<strong>       p =  Person.objects.get(name=name)</strong>
<strong>       p.delete()</strong>
<strong>       </strong>
<strong>    context = {}</strong>
<strong>    contacts = Person.objects.all()</strong>
<strong>    #sorted alphabetically</strong>
<strong>    contacts = sort_lower(contacts,"name")#contacts.order_by("name")</strong>
<strong>    context['contacts']=contacts   </strong>
<strong>    return render_to_response(</strong>
<strong>'addressesapp/book.html', RequestContext(request, context))</strong>
</pre></div><p>在数据库的<code class="literal">Person</code>表上搜索并删除<code class="literal">name</code>查询变量。该函数返回包含剩余联系人的电子邮件簿页面。</p><p>同样，未找到的URL激活了未找到功能，现在您应该能够理解它是如何工作的了。</p><p>admin URL指的是Django接口(参见下一节),而docs是本书的<em> RESTful应用程序编程接口(API)</em>一节中讨论的REST框架swagger。</p></div></div>





<title>Admin</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title">管理员</h1></div></div></div><p><a id="id532" class="indexterm"/>管理面板是用于管理应用程序的用户界面，可通过浏览器访问。在<code class="literal">admin.py</code>文件中，我们可以使用以下命令添加刚刚创建的模型:</p><div><pre class="programlisting">
<strong>from models import Person</strong>
<strong>admin.site.register(Person)</strong>
</pre></div><p>所有模型均可通过用户界面访问，网址为:</p><p><code class="literal">http://127.0.0.1:8000/admin/</code></p><p>在此链接中，用户名和密码是必需的。我们使用以下命令创建它:</p><div><pre class="programlisting">
<strong>python manage.py createsuperuser</strong>
</pre></div><p>然后，我们输入用户名和密码(在我的例子中是<code class="literal">andrea/a</code>)。</p><p>现在，我们可以浏览下面的面板:</p><div><img src="img/B05143_06_03.jpg" alt="Admin"/></div><p>点击<strong>人物</strong>，我们会看到所有的<code class="literal">Person</code>对象都是按名称显示的(因为模型中的<code class="literal">__unicode__</code>函数引用了名称字段):</p><div><img src="img/B05143_06_04.jpg" alt="Admin"/></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec43"/>外壳接口</h2></div></div></div><p>Django框架还提供了一个shell来探索和测试创建的模型。要启动它，我们在终端中键入以下内容:</p><div><pre class="programlisting">
<strong>python manage.py shell</strong>
</pre></div><p>现在我们可以导入<code class="literal">Person</code>模型并使用它:</p><div><pre class="programlisting">
<strong>In [1]: from addressesapp.models import Person</strong>
<strong>In [2]: newcontact = Person()</strong>
<strong>In [3]: newcontact.name = 'myfriend1'</strong>
<strong>In [4]: newcontact.mail = 'bla@.com'</strong>
<strong>In [5]: newcontact.save()</strong>
<strong>In [6]: Person.objects.all()</strong>
<strong>Out[6]: [&lt;Person: ss&gt;, &lt;Person: Andrea Isoni&gt;, &lt;Person: www 1&gt;, &lt;Person: addd-ww&gt;, &lt;Person: myfriend1&gt;]</strong>
</pre></div><p>在这几行中，我们创建了一个新的联系人<code class="literal">myfriend1</code>，并验证了它已经被添加到了<code class="literal">Person</code>对象列表中。</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec44"/>命令</h2></div></div></div><p>Django框架还允许我们通过<code class="literal">manage.py</code>模块编写定制命令。例如，我们希望将整个联系人列表导出到CSV文件中。为了<a id="id535" class="indexterm"/>实现这一点，我们在<code class="literal">management</code>文件夹中创建一个<code class="literal">commands</code>文件夹(每个文件夹中有<code class="literal">__init__.py</code>)。该文件实现了将联系人列表导出到CSV的自定义命令<a id="id536" class="indexterm"/>，扩展了<code class="literal">BaseCommand</code>类:</p><div><pre class="programlisting">
<strong>from addressesapp.models import Person</strong>
<strong>from django.core.management.base import BaseCommand, CommandError</strong>
<strong>from optparse import make_option</strong>
<strong>import csv</strong>

<strong>class Command(BaseCommand):</strong>
<strong>    </strong>
<strong>option_list = BaseCommand.option_list + (</strong>
<strong>                make_option('--output',</strong>
<strong>                             dest='output', type='string',</strong>
<strong>                             action='store',</strong>
<strong>                             help='output file'),</strong>
<strong>       )</strong>

<strong>    def person_data(self, person):</strong>
<strong>            return [person.name,person.mail]</strong>

<strong>    def handle(self, *args, **options):</strong>
<strong>         outputfile = options['output']</strong>
<strong>         </strong>
<strong>contacts = Person.objects.all()</strong>
<strong>         </strong>
<strong>         header = ['Name','email']</strong>
<strong>         f = open(outputfile,'wb')</strong>
<strong>         writer = csv.writer(f, quoting=csv.QUOTE_NONNUMERIC)</strong>
<strong>         writer.writerow(header)</strong>
<strong>         for person in contacts:</strong>
<strong>             writer.writerow(self.person_data(person))</strong>
</pre></div><p>命令<a id="id537" class="indexterm"/>必须定义一个<code class="literal">handler</code>函数，该函数将执行<a id="id538" class="indexterm"/>导出操作。从<code class="literal">test_server</code>文件夹中键入以下内容:</p><div><pre class="programlisting">
<strong>python manage.py contacts_tocsv –output='contacts_list.csv'</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec45"/> RESTful应用编程接口(API)</h2></div></div></div><p>RESTful API是一个应用程序编程接口，它使用HTTP请求(比如GET和POST)来管理应用程序的数据。在这种情况下，API<a id="id541" class="indexterm"/>用于通过<code class="literal">curl</code>调用获取地址簿。为此，我们在<code class="literal">settings.py</code>的<code class="literal">INSTALLED_APPS</code>部分定义了<code class="literal">rest_framework</code> app，然后<code class="literal">api.py</code>文件实现API:</p><div><pre class="programlisting">
<strong>from rest_framework import viewsets, generics, views</strong>
<strong>from rest_framework.response import Response</strong>
<strong>from rest_framework.permissions import AllowAny</strong>
<strong>from rest_framework.pagination import PageNumberPagination</strong>
<strong>from addressesapp.serializers import AddressesSerializer</strong>
<strong>from addressesapp.models import Person</strong>

<strong>class LargeResultsSetPagination(PageNumberPagination):</strong>
<strong>    page_size = 1000</strong>
<strong>    page_size_query_param = 'page_size'</strong>
<strong>    max_page_size = 10000</strong>
<strong>    </strong>
<strong>class AddressesList(generics.ListAPIView):</strong>

<strong>    serializer_class = AddressesSerializer</strong>
<strong>    permission_classes = (AllowAny,)</strong>
<strong>    pagination_class = LargeResultsSetPagination</strong>
<strong>    </strong>
<strong>    def get_queryset(self):</strong>
<strong>        query = self.request.query_params.get</strong>
<strong>        if query('name'):</strong>
<strong>           return Person.objects.filter(name=query('name')) </strong>
<strong>        else:</strong>
<strong>           return Person.objects.all()</strong>
</pre></div><p>我们已经使用了<a id="id542" class="indexterm"/>类来返回所有的<code class="literal">Person</code>对象，或者说<a id="id543" class="indexterm"/>只返回与<code class="literal">name</code>值匹配的对象。由于返回的列表可能太大，我们需要覆盖<code class="literal">PageNumberPagination</code>类以在同一页面上显示更多的对象；<code class="literal">LargeResultsSetPagination</code>类允许每页最多10，000个对象。这个API需要将<code class="literal">Person</code>对象转换成JSON格式的对象，这由<code class="literal">serializers.py</code>中实现的<code class="literal">AddressesSerializer serializer</code>来执行:</p><div><pre class="programlisting">
<strong>from addressesapp.models import Person</strong>
<strong>from rest_framework import serializers</strong>

<strong>class AddressesSerializer(serializers.HyperlinkedModelSerializer):</strong>
<strong>    </strong>
<strong>    class Meta:</strong>
<strong>        model = Person</strong>
<strong>        fields = ('id', 'name', 'mail')</strong>
</pre></div><p>现在可以使用<code class="literal">curl</code>命令检索地址簿:</p><div><pre class="programlisting"><strong>curl -X GET http://localhost:8000/addresses-list/</strong>
</pre></div><p>请注意URL末尾的正斜杠。同理，我们可以注意到URL末尾的正斜杠。同样，我们可以指定一个名称值来获取他们的电子邮件:</p><div><pre class="programlisting"><strong>curl -X GET http://localhost:8000/addresses-st/?name=name_value</strong></pre></div><p>注意，我们总是可以指定页面查询参数，以防联系人的数量太大(或者更改分页大小值)。在<code class="literal">urls.py</code>文件中，我们还将docs URL定义为我们的Swagger RESTful API，它允许用户使用<a id="id544" class="indexterm"/>浏览器来探索和测试API:</p><div><img src="img/B05143_06_05.jpg" alt="RESTful application programming interfaces (APIs)"/></div><p>这是一种用户友好的方式来验证API是否按预期工作，数据是否以正确的格式显示。</p></div></div>





<title>Summary</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/><div><div><div><div><h1 class="title"><a id="ch06lvl1sec42"/>总结</h1></div></div></div><p>在本章中，我们已经讨论了如何使用Django框架创建一个web应用程序。已经描述了Django的主要特性，比如<code class="literal">models</code>、<code class="literal">admin</code>、<code class="literal">views</code>、<code class="literal"> commands</code>、<code class="literal">shell</code>和<code class="literal">RESTful API</code>，因此读者现在应该具备了在现实场景中开发web应用程序的必要知识。</p><p>在接下来的两章中，我们将使用这些知识，以及我们在前面章节中学到的知识，来构建我们的电影推荐引擎和电影情感分析应用程序。</p></div>
</body></html>