<html><head/><body>
<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>Phishing Domain Detection</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="1JFUC0-49a67f1d6e7843d3b2296f38e3fe05f5" class="calibre">
        

                            
                    <h1 class="header-title" id="calibre_pb_0">网络钓鱼域检测</h1>
                
            
            
                
<p class="calibre2">社会工程是每个个人和现代组织面临的最危险的威胁之一。网络钓鱼是一种众所周知的基于计算机的社会工程技术。攻击者使用伪装的电子邮件地址作为武器来攻击大公司。由于每天都会收到大量的网络钓鱼电子邮件，公司无法检测出所有的邮件。这就是为什么需要新的技术和安全措施来防范网络钓鱼。本章将介绍使用先进的Python机器学习库构建三个不同的基于机器学习的项目来检测网络钓鱼企图所需的步骤。</p>
<p class="calibre2">在本章中，我们将介绍:</p>
<ul class="calibre9">
<li class="calibre10">社会工程概述</li>
<li class="calibre10">社会工程渗透测试的步骤</li>
<li class="calibre10">使用不同的机器学习模型构建实时网络钓鱼攻击检测器:  <ul class="calibre53">
<li class="calibre10">基于逻辑回归的网络钓鱼检测</li>
<li class="calibre10">基于决策树的网络钓鱼检测</li>
<li class="calibre10">用<strong class="calibre1">自然语言处理</strong> ( <strong class="calibre1"> NLP </strong>)检测垃圾邮件</li>
</ul>
</li>
</ul>


            

            
        
    </body></html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>Technical requirements</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="1KEEU0-49a67f1d6e7843d3b2296f38e3fe05f5" class="calibre">
        

                            
                    <h1 class="header-title" id="calibre_pb_0">技术要求</h1>
                
            
            
                
<p class="calibre2">在本章中，我们将使用以下Python库:</p>
<ul class="calibre9">
<li class="calibre10">sci kit-学习Python (≥ 2.7或≥ 3.3)</li>
<li class="calibre10">数值(≥ 1.8.2)</li>
<li class="calibre10">NLTK</li>
</ul>
<p class="calibre2">如果您尚未安装它们，请确保在继续本章之前安装它们。你可以在<a href="https://github.com/PacktPublishing/Mastering-Machine-Learning-for-Penetration-Testing/tree/master/Chapter02" class="calibre8">https://github . com/packt publishing/Mastering-Machine-Learning-for-Penetration-Testing/tree/master/chapter 02</a>找到代码文件。</p>


            

            
        
    </body></html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>Social engineering overview</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="1LCVG0-49a67f1d6e7843d3b2296f38e3fe05f5" class="calibre">
        

                            
                    <h1 class="header-title" id="calibre_pb_0">社会工程概述</h1>
                
            
            
                
<p class="calibre2">根据定义，社会工程是对一个人的心理操纵，以从他们那里获得有用和敏感的信息，这些信息随后可用于危及系统。换句话说，犯罪分子利用人类的行为，利用社会工程从人们那里获取机密信息。</p>


            

            
        
    </body></html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>Social Engineering Engagement Framework</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="1MBG20-49a67f1d6e7843d3b2296f38e3fe05f5" class="calibre">
        

                            
                    <h1 class="header-title" id="calibre_pb_0">社会工程参与框架</h1>
                
            
            
                
<p class="calibre2"><strong class="calibre4">社会工程参与框架</strong> ( <strong class="calibre4"> SEEF </strong>)是由Dominique C. Brack和Alexander Bahmram开发的框架。它总结了多年来在信息安全和防御社会工程方面的经验。该框架的利益相关者包括组织、政府和个人。社会工程参与管理经历三个步骤:</p>
<ol class="calibre13">
<li value="1" class="calibre10"><strong class="calibre1">预约流程</strong>:社会工程作业准备</li>
<li value="2" class="calibre10"><strong class="calibre1">接合过程中</strong>:接合发生</li>
<li value="3" class="calibre10"><strong class="calibre1">聘任后流程</strong> : <strong class="calibre1"> </strong>提交报告</li>
</ol>
<p class="calibre2">罪犯使用许多社会工程技术:</p>
<ul class="calibre9">
<li class="calibre10"><strong class="calibre1">诱饵</strong>:说服受害者透露信息，许诺给他报酬或礼物。</li>
<li class="calibre10">冒充:冒充别人。</li>
<li class="calibre10">翻垃圾箱:从垃圾箱里收集有价值的信息(有地址的文件、电子邮件等等)。</li>
<li class="calibre10">肩窥:在别人打字的时候，从他们背后偷窥他们的机器。</li>
<li class="calibre10">网络钓鱼:这是最常用的技术；当攻击者伪装成受信任的实体，欺骗受害者打开电子邮件、即时消息或文本消息时，就会发生这种情况。</li>
</ul>


            

            
        
    </body></html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>Steps of social engineering penetration testing</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="1NA0K0-49a67f1d6e7843d3b2296f38e3fe05f5" class="calibre">
        

                            
                    <h1 class="header-title" id="calibre_pb_0">社会工程渗透测试的步骤</h1>
                
            
            
                
<p class="calibre2">渗透测试模拟黑帽黑客攻击，以评估公司部署所需安全措施的安全状况。渗透测试是一个方法论的过程，它经历了明确定义的步骤。渗透测试有多种类型:</p>
<ul class="calibre9">
<li class="calibre10">白盒测试</li>
<li class="calibre10">黑盒测试</li>
<li class="calibre10">灰盒测试</li>
</ul>
<p class="calibre2">要执行社会工程渗透测试，您需要遵循以下步骤:</p>
<div><img src="img/00049.jpeg" class="calibre57"/></div>


            

            
        
    </body></html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>Building real-time phishing attack detectors using different machine learning models</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="1O8H60-49a67f1d6e7843d3b2296f38e3fe05f5" class="calibre">
        

                            
                    <h1 class="header-title" id="calibre_pb_0">使用不同的机器学习模型构建实时网络钓鱼攻击检测器</h1>
                
            
            
                
<p class="calibre2">在接下来的部分中，我们将学习如何构建机器学习网络钓鱼检测器。我们将介绍以下两种方法:</p>
<ul class="calibre9">
<li class="calibre10">基于逻辑回归的网络钓鱼检测</li>
<li class="calibre10">基于决策树的网络钓鱼检测</li>
</ul>


            

            
        
    </body></html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>Phishing detection with logistic regression</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="1P71O0-49a67f1d6e7843d3b2296f38e3fe05f5" class="calibre">
        

                            
                    <h1 class="header-title" id="calibre_pb_0">基于逻辑回归的网络钓鱼检测</h1>
                
            
            
                
<p class="calibre2">在本节中，我们将使用逻辑回归算法从头开始构建一个网络钓鱼检测器。逻辑回归是一种众所周知的统计技术，用于进行二项式预测(两类)。</p>
<p class="calibre2">就像在每个机器学习项目中一样，我们需要数据来支持我们的机器学习模型。对于我们的模型，我们将使用UCI机器学习库(钓鱼网站数据集)。你可以在https://archive.ics.uci.edu/ml/datasets/Phishing+Websites查看一下:</p>
<div><img src="img/00050.jpeg" class="calibre58"/></div>
<p class="calibre2">数据集以一个<kbd class="calibre12">arff</kbd>文件的形式提供:</p>
<div><img src="img/00051.jpeg" class="calibre59"/></div>
<p class="calibre2">以下是数据集的快照:</p>
<div><img src="img/00052.gif" class="calibre60"/></div>
<p class="calibre2">为了更好地操作，我们将数据集组织成一个<kbd class="calibre12">csv</kbd>文件:</p>
<div><img src="img/00053.jpeg" class="calibre54"/></div>
<p class="calibre2">您可能从属性中注意到，数据集的每一行都以下面的格式表示—<em class="calibre16">{ 30个属性(having_IP_Address URL_Length，abnormal _ URL等)} + {1个属性(Result)} </em>:</p>
<div><img src="img/00054.jpeg" class="calibre61"/></div>
<p class="calibre2">对于我们的模型，我们将导入两个机器学习库，NumPy和scikit-learn，我们已经在<a href="part0021.html#K0RQ0-49a67f1d6e7843d3b2296f38e3fe05f5" class="calibre8">第1章</a>和<em class="calibre16">Pentesting</em>中安装了它们。</p>
<p class="calibre2">让我们打开Python环境并加载所需的库:</p>
<pre class="calibre17"><strong class="calibre1">&gt;&gt;&gt; import numpy as np</strong><br class="title-page-name"/><strong class="calibre1">&gt;&gt;&gt; from sklearn import *<br class="title-page-name"/>&gt;&gt;&gt; from sklearn.linear_model import LogisticRegression<br class="title-page-name"/>&gt;&gt;&gt; from sklearn.metrics import accuracy_score</strong></pre>
<p class="calibre2">接下来，加载数据:</p>
<pre class="calibre17"><strong class="calibre1">training_data = np.genfromtxt('dataset.csv', delimiter=',', dtype=np.int32)</strong></pre>
<p class="calibre2">识别<kbd class="calibre12">inputs</kbd>(所有属性，除了最后一个属性)和<kbd class="calibre12">outputs</kbd>(最后一个属性):</p>
<pre class="calibre17"><strong class="calibre1">&gt;&gt;&gt; inputs = training_data[:,:-1]</strong><br class="title-page-name"/><strong class="calibre1">&gt;&gt;&gt; outputs = training_data[:, -1]</strong></pre>
<p class="calibre2">在前一章中，我们讨论了如何将数据集划分为训练数据和测试数据:</p>
<pre class="calibre17"><strong class="calibre1">training_inputs = inputs[:2000]</strong><br class="title-page-name"/><strong class="calibre1">training_outputs = outputs[:2000] </strong><br class="title-page-name"/><strong class="calibre1">testing_inputs = inputs[2000:]</strong><br class="title-page-name"/><strong class="calibre1">testing_outputs = outputs[2000:]</strong></pre>
<div><img src="img/00055.gif" class="calibre62"/></div>
<p class="calibre2">创建scikit-learn逻辑回归分类器:</p>
<pre class="calibre17"><strong class="calibre1">classifier = LogisticRegression()</strong></pre>
<p class="calibre2">训练分类器:</p>
<pre class="calibre17"><strong class="calibre1">classifier.fit(training_inputs, training_outputs)</strong></pre>
<p class="calibre2">进行预测:</p>
<pre class="calibre17"><strong class="calibre1">predictions = classifier.predict(testing_inputs)</strong></pre>
<p class="calibre2">让我们打印出我们的网络钓鱼检测器模型的准确性:</p>
<pre class="calibre17"><strong class="calibre1">accuracy = 100.0 * accuracy_score(testing_outputs, predictions)<br class="title-page-name"/></strong><br class="title-page-name"/><strong class="calibre1">print ("The accuracy of your Logistic Regression on testing data is: " + str(accuracy))</strong></pre>
<div><img src="img/00056.gif" class="calibre63"/></div>
<div><p class="calibre2">我们模型的准确率大约是85%。这是一个很好的准确性，因为我们的模型检测出100个钓鱼网址中的85个。但是让我们试着用决策树做一个更好的模型，用同样的数据。</p>
</div>


            

            
        
    </body></html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>Phishing detection with decision trees</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="1Q5IA0-49a67f1d6e7843d3b2296f38e3fe05f5" class="calibre">
        

                            
                    <h1 class="header-title" id="calibre_pb_0">基于决策树的网络钓鱼检测</h1>
                
            
            
                
<p class="calibre2">为了构建第二个模型，我们将使用相同的机器学习库，因此没有必要再次导入它们。然而，我们将从<kbd class="calibre12">sklearn</kbd>导入决策树分类器:</p>
<pre class="calibre17"><strong class="calibre1">&gt;&gt;&gt; from sklearn import tree</strong></pre>
<p class="calibre2">创建<kbd class="calibre12">tree.DecisionTreeClassifier()</kbd> scikit-learn分类器:</p>
<pre class="calibre17"><strong class="calibre1">classifier = tree.DecisionTreeClassifier()</strong></pre>
<p class="calibre2">训练模型:</p>
<pre class="calibre17"><strong class="calibre1">classifier.fit(training_inputs, training_outputs)</strong></pre>
<p class="calibre2">计算预测值:</p>
<pre class="calibre17"><strong class="calibre1">predictions = classifier.predict(testing_inputs)</strong></pre>
<p class="calibre2">计算准确度:</p>
<pre class="calibre17"><strong class="calibre1">accuracy = 100.0 * accuracy_score(testing_outputs, predictions)</strong></pre>
<p class="calibre2">然后，打印出结果:</p>
<pre class="calibre17"><strong class="calibre1">print ("The accuracy of your decision tree on testing data is: " + str(accuracy))</strong></pre>
<div><img src="img/00057.gif" class="calibre64"/></div>
<div><p class="calibre2">与第一个模型相比，第二个模型的准确度约为90.4%，这是一个很好的结果。我们现在已经学习了如何使用两种机器学习技术来构建两个网络钓鱼检测器。</p>
</div>


            

            
        
    </body></html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>NLP in-depth overview</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="1R42S0-49a67f1d6e7843d3b2296f38e3fe05f5" class="calibre">
        

                            
                    <h1 class="header-title" id="calibre_pb_0">NLP深入概述</h1>
                
            
            
                
<p class="calibre2">NLP是机器分析和理解人类语言的艺术。根据许多研究，超过75%的使用数据是非结构化的。非结构化数据没有预定义的数据模型，或者不是以预定义的方式组织的。电子邮件、推文、日常信息甚至我们的录音讲话都是非结构化数据的形式。NLP是机器分析、理解和从自然语言中获取意义的一种方式。NLP被广泛用于许多领域和应用，例如:</p>
<ul class="calibre9">
<li class="calibre25">实时翻译</li>
<li class="calibre25">自动摘要</li>
<li class="calibre25">情感分析</li>
<li class="calibre25">语音识别</li>
<li class="calibre25">构建聊天机器人</li>
</ul>
<p class="calibre2">通常，NLP有两个不同的组成部分:</p>
<ul class="calibre9">
<li class="calibre25"><strong class="calibre1">自然语言理解(NLU) </strong>:这是指将输入映射成有用的表示。</li>
<li class="calibre25"><strong class="calibre1">自然语言生成(NLG) </strong>:这是指将内部表示转化为有用的表示。换句话说，它将数据转化为书面或口头叙述。商业智能仪表板的书面分析是NLG应用程序之一。</li>
</ul>
<p class="calibre2">每个NLP项目都要经过五个步骤。构建NLP项目的第一步是识别和分析单词的结构。这一步包括将数据分成段落、句子和单词。稍后我们分析句子中的单词以及它们之间的关系。第三步涉及检查文本的意义。然后，分析连句的意义。最后，通过语用分析来完成项目。</p>
<div><img src="img/00058.jpeg" class="calibre65"/></div>


            

            
        
    </body></html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>Open source NLP libraries</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="1S2JE0-49a67f1d6e7843d3b2296f38e3fe05f5" class="calibre">
        

                            
                    <h1 class="header-title" id="calibre_pb_0">开源NLP库</h1>
                
            
            
                
<p class="calibre2">有许多开源Python库提供了构建真实世界的NLP应用程序所需的结构，例如:</p>
<ul class="calibre9">
<li class="calibre10">Apache OpenNLP</li>
<li class="calibre10">GATE NLP图书馆</li>
<li class="calibre10">斯坦福NLP</li>
<li class="calibre10">当然，还有<strong class="calibre1">自然语言工具包</strong> ( <strong class="calibre1"> NLTK </strong>)</li>
</ul>
<p class="calibre2">在前一章中，我们学习了如何安装许多开源机器学习Python库，包括NLTK。让我们启动我们的Linux机器，尝试一些实践技巧。</p>
<p class="calibre2">打开Python终端，导入<kbd class="calibre12">nltk</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">&gt;&gt;&gt; import nltk</strong></pre>
<p class="calibre2">下载图书类型，如下所示:</p>
<pre class="calibre17"><strong class="calibre1">&gt;&gt;&gt; nltk.download()</strong></pre>
<div><img src="img/00059.jpeg" class="calibre66"/></div>
<p class="calibre2">如果您想列出我们在上一章已经下载的可用资源，请键入<kbd class="calibre12">l</kbd>:</p>
<div><img src="img/00060.gif" class="calibre67"/></div>
<p class="calibre2">您也可以键入:</p>
<pre class="calibre17"><strong class="calibre1">&gt;&gt; from nltk.book import *</strong></pre>
<div><img src="img/00061.gif" class="calibre68"/></div>
<p class="calibre2">要从链接中获取文本，建议使用<kbd class="calibre12">urllib</kbd>模块抓取网站:</p>
<pre class="calibre17"><strong class="calibre1">&gt;&gt;&gt; from urllib import urlopen</strong><br class="title-page-name"/><strong class="calibre1">&gt;&gt;&gt; url = "http://www.URL_HERE/file.txt"</strong></pre>
<p class="calibre2">作为演示，我们将加载一个名为<kbd class="calibre12">Security.in.Wireless.Ad.Hoc.and.Sensor.Networks</kbd>的文本:</p>
<div><img src="img/00062.jpeg" class="calibre69"/></div>
<div><p class="calibre2">我们抓取了文本文件，并使用<kbd class="calibre12">len</kbd>来检查它的长度，使用<kbd class="calibre12">raw[:50]</kbd>来显示一些内容。从截图中可以看到，文字中包含了大量对我们项目毫无用处的符号。为了只得到我们需要的，我们使用了<strong class="calibre4">记号化</strong>:</p>
<pre class="calibre17"><strong class="calibre1">&gt;&gt;&gt; tokens = nltk.word_tokenize(raw)</strong><br class="title-page-name"/><strong class="calibre1">&gt;&gt;&gt; len(tokens)</strong><br class="title-page-name"/><strong class="calibre1">&gt; tokens[:10]</strong></pre></div>
<p class="calibre2">为了总结我们在上一节中学到的内容，我们看到了如何下载一个web页面、标记文本和规范化单词。</p>


            

            
        
    </body></html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>Spam detection with NLTK</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="1T1400-49a67f1d6e7843d3b2296f38e3fe05f5" class="calibre">
        

                            
                    <h1 class="header-title" id="calibre_pb_0">使用NLTK检测垃圾邮件</h1>
                
            
            
                
<p class="calibre2">现在是时候使用NLTK构建我们的垃圾邮件检测器了。这种分类器的原理很简单；我们需要检测垃圾邮件发送者使用的单词。我们将使用Python和<kbd class="calibre12">nltk</kbd>库构建一个垃圾邮件/非垃圾邮件二元分类器，来检测一封电子邮件是否是垃圾邮件。首先，我们需要像往常一样导入库:</p>
<pre class="calibre17"><strong class="calibre1">&gt;&gt;&gt; import nltk</strong></pre>
<p class="calibre2">我们需要加载数据，并用电子邮件数据集填充我们的模型。为了实现这一点，我们可以使用互联网内容过滤组织提供的数据集。您可以访问https://labs-repos.iit.demokritos.gr/skel/i-config/<a href="https://labs-repos.iit.demokritos.gr/skel/i-config/" class="calibre8">的网站</a>:</p>
<div><img src="img/00063.jpeg" class="calibre54"/></div>
<p class="calibre2">基本上，该网站提供了四个数据集:</p>
<ul class="calibre9">
<li class="calibre10">凌垃圾邮件</li>
<li class="calibre10">PU1</li>
<li class="calibre10">PU123A</li>
<li class="calibre10">安然-垃圾邮件</li>
</ul>
<p class="calibre2">对于我们的项目，我们将使用安然垃圾邮件数据集:</p>
<div><img src="img/00064.jpeg" class="calibre70"/></div>
<p class="calibre2">让我们使用<kbd class="calibre12">wget</kbd>命令下载数据集:</p>
<div><img src="img/00065.jpeg" class="calibre71"/></div>
<p class="calibre2">使用<kbd class="calibre12">tar -xzf enron1.tar.gz</kbd>命令提取<kbd class="calibre12">tar.gz</kbd>文件:</p>
<div><img src="img/00066.jpeg" class="calibre72"/></div>
<p class="calibre2">随机播放<kbd class="calibre12">cp spam/* emails &amp;&amp; cp ham/* emails</kbd>对象:</p>
<div><img src="img/00067.jpeg" class="calibre73"/></div>
<p class="calibre2">为了打乱电子邮件，让我们编写一个小的Python脚本<kbd class="calibre12">Shuffle.py</kbd>来完成这项工作:</p>
<pre class="calibre17">import os<br class="title-page-name"/>import random<br class="title-page-name"/>#initiate a list called emails_list<br class="title-page-name"/>emails_list = []<br class="title-page-name"/>Directory = '/home/azureuser/spam_filter/enron1/emails/'<br class="title-page-name"/>Dir_list  = os.listdir(Directory)<br class="title-page-name"/>for file in Dir_list:<br class="title-page-name"/>    f = open(Directory + file, 'r')<br class="title-page-name"/>    emails_list.append(f.read())<br class="title-page-name"/>f.close()</pre>
<p class="calibre2">只需更改目录变量，它就会打乱文件:</p>
<div><img src="img/00068.jpeg" class="calibre74"/></div>
<p class="calibre2">准备好数据集后，您应该知道，正如我们之前了解到的，我们需要<kbd class="calibre12">tokenize</kbd>电子邮件:</p>
<pre class="calibre17"><strong class="calibre1">&gt;&gt; from nltk import word_tokenize</strong></pre>
<div><img src="img/00069.jpeg" class="calibre75"/></div>
<p class="calibre2">此外，我们需要执行另一个步骤，称为lemmatizing。词汇化连接不同形式的单词，如hacker/黑客和is/are。我们需要导入<kbd class="calibre12">WordNetLemmatizer</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">&gt;&gt;&gt; from nltk import WordNetLemmatizer</strong></pre>
<p class="calibre2">为演示创建一个句子，并打印出lemmatizer的结果:</p>
<pre class="calibre17"><strong class="calibre1">&gt;&gt;&gt; [lemmatizer.lemmatize(word.lower()) for word in word_tokenize(unicode(sentence, errors='ignore'))]</strong></pre>
<div><img src="img/00070.gif" class="calibre76"/></div>
<p class="calibre2">然后，我们需要去掉<kbd class="calibre12">stopwords</kbd>，比如<kbd class="calibre12">of</kbd>、<kbd class="calibre12">is</kbd>、<kbd class="calibre12">the</kbd>等等:</p>
<pre class="calibre17"><strong class="calibre1">from nltk.corpus import stopwords</strong><br class="title-page-name"/><strong class="calibre1">stop = stopwords.words('english')</strong></pre>
<p class="calibre2">要处理电子邮件，必须创建一个名为<kbd class="calibre12">Process</kbd>的函数，以<kbd class="calibre12">lemmatize</kbd>和<kbd class="calibre12">tokenize</kbd>我们的数据集:</p>
<pre class="calibre17"><strong class="calibre1">def Process(data):</strong><br class="title-page-name"/><strong class="calibre1">   lemmatizer = WordNetLemmatizer()</strong><br class="title-page-name"/><strong class="calibre1">   return [lemmatizer.lemmatize(word.lower()) for word in word_tokenize(unicode(sentence,   errors='ignore'))]</strong></pre>
<p class="calibre2">第二步是特征提取，通过阅读电子邮件的文字:</p>
<pre class="calibre17"><strong class="calibre1">from collections import Counter</strong><br class="title-page-name"/><strong class="calibre1">def Features_Extraction(text, setting):</strong><br class="title-page-name"/><strong class="calibre1">   if setting=='bow':</strong><br class="title-page-name"/><strong class="calibre1"># Bow means  bag-of-words</strong><br class="title-page-name"/><strong class="calibre1">       return {word: count for word, count in Counter(Process(text)).items() if not word in stop}</strong><br class="title-page-name"/><strong class="calibre1">   else:</strong><br class="title-page-name"/><strong class="calibre1">       return {word: True for word in Process(text) if not word in stop}</strong></pre>
<p class="calibre2">提取特征:</p>
<pre class="calibre17"><strong class="calibre1">features = [(Features_Extraction(email, 'bow'), label) for (email, label) in emails]</strong></pre>
<p class="calibre2">现在，让我们定义训练模型Python函数:</p>
<pre class="calibre17"><strong class="calibre1">def training_Model (Features, samples):</strong><br class="title-page-name"/><strong class="calibre1">   Size = int(len(Features) * samples)</strong><br class="title-page-name"/><strong class="calibre1">   training , testing = Features[:Size], Features[Size:]</strong><br class="title-page-name"/><strong class="calibre1">   print ('Training = ' + str(len(training)) + ' emails')</strong><br class="title-page-name"/><strong class="calibre1">   print ('Testing = ' + str(len(testing)) + ' emails')</strong></pre>
<p class="calibre2">作为分类算法，我们将使用<kbd class="calibre12">NaiveBayesClassifier</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">from nltk import NaiveBayesClassifier, classify</strong><br class="title-page-name"/><strong class="calibre1">classifier = NaiveBayesClassifier.train(training)</strong></pre>
<p class="calibre2">最后，我们定义评估Python函数:</p>
<pre class="calibre17"><strong class="calibre1">def evaluate(training, tesing, classifier):</strong><br class="title-page-name"/><strong class="calibre1">   print ('Training Accuracy is ' + str(classify.accuracy(classifier, train_set)))</strong><br class="title-page-name"/><strong class="calibre1">   print ('Testing Accuracy i ' + str(classify.accuracy(classifier, test_set)))</strong></pre>
<div><img src="img/00071.gif" class="calibre77"/></div>


            

            
        
    </body></html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>Summary</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="1TVKI0-49a67f1d6e7843d3b2296f38e3fe05f5" class="calibre">
        

                            
                    <h1 class="header-title" id="calibre_pb_0">摘要</h1>
                
            
            
                
<p class="calibre2">在本章中，我们学习了如何通过从头构建三个不同的项目来检测网络钓鱼企图。首先，我们发现了如何使用两种不同的机器学习技术开发一种网络钓鱼检测器，这要归功于尖端的Python机器学习库。第三个项目是基于NLP和朴素贝叶斯分类的垃圾邮件过滤器。在下一章中，我们将构建各种项目来检测恶意软件，使用不同的技术和Python机器学习库。</p>


            

            
        
    </body></html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>Questions</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="1UU540-49a67f1d6e7843d3b2296f38e3fe05f5" class="calibre">
        

                            
                    <h1 class="header-title" id="calibre_pb_0">问题</h1>
                
            
            
                
<p class="calibre2">我们希望这一章很容易看完。现在，像往常一样，是练习时间。你的工作是尝试建立自己的垃圾邮件检测系统。我们将引导您完成这些问题。</p>
<p class="calibre2">在本章的GitHub知识库中，您将找到一个数据集，该数据集是从Androutsopoulos、J. Koutsias、K.V. Chandrinos、George Paliouras和C.D .斯皮罗普洛斯的研究中收集的:<em class="calibre16">对朴素贝叶斯反垃圾邮件过滤的评估</em>。<em class="calibre16">新信息时代机器学习研讨会论文集，G. Potamias，V. Moustakis和</em> <em class="calibre16"> M. van Someren(编辑。)，第11届欧洲机器学习会议，西班牙巴塞罗那，2000年9-17页</em>。</p>
<p class="calibre2">您现在可以准备数据了:</p>
<ol class="calibre13">
<li value="1" class="calibre10">以下是一些要执行的文本清理任务:  <ul class="calibre53">
<li class="calibre10">清除文本中的停用词、数字和标点符号。</li>
<li class="calibre10">执行词汇化。</li>
</ul>
</li>
<li value="2" class="calibre10">创建一个单词字典，包括它们的频率。</li>
</ol>
<p>在邮件文本中，你会注意到第一行是邮件的主题，第三行是邮件的正文(我们只需要邮件正文)。</p>
<ol start="3" class="calibre13">
<li value="3" class="calibre10">从字典中删除非单词。</li>
<li value="4" class="calibre10">从数据中提取特征。</li>
<li value="5" class="calibre10">准备特征向量及其标签。</li>
<li value="6" class="calibre10">用线性支持向量机分类器训练模型。</li>
<li value="7" class="calibre10">打印出你的模型的混淆矩阵。</li>
</ol>


            

            
        
    </body></html>
</body></html>