<html><head/><body>
<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>Botnet Detection with Machine Learning</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="2SG6I0-49a67f1d6e7843d3b2296f38e3fe05f5" class="calibre">
        

                            
                    <h1 class="header-title" id="calibre_pb_0">基于机器学习的僵尸网络检测</h1>
                
            
            
                
<p class="calibre2">如今，互联设备在现代生活中扮演着重要角色。从智能家电、电脑、咖啡机和相机，到联网汽车，我们生活方式的这一巨大转变让我们的生活变得更加轻松。不幸的是，这些暴露的设备可能会受到攻击者和网络罪犯的攻击和访问，他们以后可能会使用它们来实施更大规模的攻击。安全供应商提供了许多解决方案和产品来防御僵尸网络，但在本章中，正如我们在前面章节中所做的那样，我们将学习如何使用 Python 和机器学习技术来构建新颖的僵尸网络检测系统。</p>
<p class="calibre2">在本章中，我们将看到:</p>
<ul class="calibre9">
<li class="calibre25">僵尸网络概述</li>
<li class="calibre25">如何用不同的机器学习算法构建僵尸网络检测器</li>
<li class="calibre25">如何构建一个 Twitter 机器人检测器</li>
</ul>


            

            
        
    </body></html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>Technical requirements</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="2TEN40-49a67f1d6e7843d3b2296f38e3fe05f5" class="calibre">
        

                            
                    <h1 class="header-title" id="calibre_pb_0">技术要求</h1>
                
            
            
                
<p class="calibre2">除了一些其他有用的脚本之外，您可以在下面的资源库中找到所有讨论的代码:<a href="https://github.com/PacktPublishing/Mastering-Machine-Learning-for-Penetration-Testing/tree/master/Chapter5" class="calibre8">https://github . com/packt publishing/Mastering-Machine-Learning-for-Penetration-Testing/tree/master/chapter 5</a>。</p>


            

            
        
    </body></html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>Botnet overview</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="2UD7M0-49a67f1d6e7843d3b2296f38e3fe05f5" class="calibre">
        

                            
                    <h1 class="header-title" id="calibre_pb_0">僵尸网络概述</h1>
                
            
            
                
<p class="calibre2">僵尸网络是两个术语<strong class="calibre4">僵尸</strong>和<strong class="calibre4">网络</strong>的组合。bot 部分代表了这种恶意软件像机器人一样自动完成事情和任务的事实。第二部分指的是一个网络，换句话说，是一个被入侵设备的网络。因此，根据定义，僵尸网络是一种恶意软件，它攻击互联网上的计算机，并用命令和控制服务器控制它们执行各种各样的自动化任务，包括发送垃圾邮件和执行<strong class="calibre4">分布式拒绝服务</strong> ( <strong class="calibre4"> DDoS </strong>)攻击。被攻击的机器加入了一个巨大的被入侵机器网络。前几年最著名的僵尸网络之一是 Mirai 未来组合僵尸网络。Mirai 未来组合在日语中是未来的意思。这个僵尸网络通过扫描和识别易受攻击的机器，攻击了数百万台在线设备，特别是<strong class="calibre4">物联网</strong> ( <strong class="calibre4">物联网</strong>)设备，利用了大多数设备都是使用默认登录凭据访问的事实。僵尸网络执行的一些任务是:</p>
<ul class="calibre9">
<li class="calibre10">广告欺诈和发送垃圾邮件</li>
<li class="calibre25">加密货币挖掘</li>
<li class="calibre25">窃取个人数据和敏感信息</li>
<li class="calibre25">执行 DDoS 攻击</li>
<li class="calibre25">执行暴力攻击</li>
</ul>
<p class="calibre2">下图描述了僵尸网络生态系统的不同参与者:</p>
<div><img src="img/00116.jpeg" class="calibre124"/></div>
<p class="calibre2">黑客是一项方法论任务。罪犯和网络攻击者通常使用相同的定义步骤。作为渗透测试人员和信息安全专业人员，您知道黑客攻击的各个阶段，即信息收集，或者我们称之为侦察；扫描；获得访问权；维护访问权；最后清理铁轨。因此，僵尸网络通常遵循一些定义好的步骤。僵尸网络基于四个不同的阶段工作:</p>
<ul class="calibre9">
<li class="calibre10"><strong class="calibre1">感染</strong>:在这个阶段，攻击者通过发送恶意软件来感染目标机器。</li>
<li class="calibre10"><strong class="calibre1">连接</strong>:在这个阶段，僵尸网络启动与控制和命令服务器的互联网连接，以接收命令和自动化任务。</li>
<li class="calibre10"><strong class="calibre1">控制</strong>:在这个阶段，攻击发生，比如发送垃圾邮件。</li>
<li class="calibre10"><strong class="calibre1">倍增</strong>:在这一阶段，僵尸网络会试图让更多的机器加入网络，成为我们所说的<strong class="calibre1">僵尸</strong>:</li>
</ul>
<div><img src="img/00117.jpeg" class="calibre125"/></div>


            

            
        
    </body></html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>Building a botnet detector model with multiple machine learning techniques</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="2VBO80-49a67f1d6e7843d3b2296f38e3fe05f5" class="calibre">
        

                            
                    <h1 class="header-title" id="calibre_pb_0">利用多种机器学习技术构建僵尸网络检测器模型</h1>
                
            
            
                
<p class="calibre2">在本节中，我们将学习如何使用许多机器学习算法来构建不同的僵尸网络检测系统。作为第一个实际实验室的开始，让我们从使用不同的分类器构建一个基于机器学习的僵尸网络检测器开始。到目前为止，我希望您已经清楚地了解了构建机器学习系统的主要步骤。所以，我相信你已经知道，作为第一步，我们需要寻找一个数据集。许多教育机构和组织得到了一组从内部实验室收集的数据集。最著名的僵尸网络数据集之一被称为<strong class="calibre4"> CTU-13 </strong>数据集。这是一个由捷克共和国 CTU 大学提供的标记数据集，包含僵尸网络、正常流量和后台流量。在他们的工作中，他们试图捕捉真实的僵尸网络流量与正常流量和背景流量的混合。要下载数据集并查看有关它的更多信息，可以访问以下链接:<a href="https://mcfp.weebly.com/the-ctu-13-dataset-a-labeled-dataset-with-botnet-normal-and-background-traffic.html" class="calibre8">https://mcfp . wee bly . com/the-CTU-13-dataset-a-labelled-dataset-with-botnet-normal-and-background-traffic . html</a>。</p>
<p class="calibre2">数据集是双向网络流文件。但是什么是双向网流文件呢？Netflow 是由 Cisco 开发的互联网协议。该协议的目标是收集 IP 流量信息并监控网络流量，以便更清楚地了解网络流量。网络流架构的主要组件是一个<strong class="calibre4">网络流导出器</strong>、一个<strong class="calibre4">网络流收集器</strong>和一个<strong class="calibre4">流存储器</strong>。下图说明了 NetFlow 基础架构的不同组件:</p>
<div><img src="img/00118.jpeg" class="calibre126"/></div>
<p class="calibre2">对于 NetFlow 一般来说，当主机 A 向<strong class="calibre4">主机 B </strong>发送一个信息，并从<strong class="calibre4">主机 B </strong>向<strong class="calibre4">主机 A </strong>发送一个信息作为回复时，这种操作称为单向 NetFlow。发送和回复被认为是不同的操作。在双向网络流中，我们将来自<strong class="calibre4">主机 A </strong>和<strong class="calibre4">主机 B </strong>的流视为一个流。让我们使用以下命令下载数据集:</p>
<pre class="calibre17"><strong class="calibre1">$ wget --no-check-certificate https://mcfp.felk.cvut.cz/publicDatasets/CTU-13-Dataset/CTU-13-Dataset.tar.bz2</strong></pre>
<div><img src="img/00119.jpeg" class="calibre127"/></div>
<p class="calibre2">使用以下命令提取下载的<kbd class="calibre12">tar.bz2</kbd>文件:</p>
<pre class="calibre17"><strong class="calibre1"># tar xvjf  CTU-13-Dataset.tar.bz2</strong></pre>
<div><img src="img/00120.jpeg" class="calibre128"/></div>
<p class="calibre2">该文件包含所有不同场景的数据集。在演示中，我们将使用数据集 8(场景 8)。您可以选择任何场景，也可以使用您自己收集的数据，或者其他机构提供的任何其他<kbd class="calibre12">.binetflow</kbd>文件:</p>
<div><img src="img/00121.jpeg" class="calibre129"/></div>
<p class="calibre2">像往常一样使用 pandas 加载数据:</p>
<pre class="calibre17"><strong class="calibre1">&gt;&gt;&gt; import pandas as pd<br class="title-page-name"/>&gt;&gt;&gt; data = pd.read_csv("capture20110816-3.binetflow")</strong><br class="title-page-name"/><strong class="calibre1">&gt;&gt;&gt; data['Label'] = data.Label.str.contains("Botnet")</strong></pre>
<p class="calibre2">在任何以数据为中心的项目中，探索数据都是必不可少的。例如，您可以从检查特征或列的名称开始:</p>
<pre class="calibre17"><strong class="calibre1">&gt;&gt; data.columns</strong></pre>
<p class="calibre2">该命令产生数据集的列:<kbd class="calibre12">StartTime</kbd>、<kbd class="calibre12">Dur</kbd>、<kbd class="calibre12">Proto</kbd>、<kbd class="calibre12">SrcAddr</kbd>、<kbd class="calibre12">Sport</kbd>、<kbd class="calibre12">Dir</kbd>、<kbd class="calibre12">DstAddr</kbd>、<kbd class="calibre12">Dport</kbd>、<kbd class="calibre12">State</kbd>、<kbd class="calibre12">sTos</kbd>、<kbd class="calibre12">dTos</kbd>、<kbd class="calibre12">TotPkts</kbd>、<kbd class="calibre12">TotBytes</kbd>、<kbd class="calibre12">SrcBytes</kbd>和<kbd class="calibre12">Label</kbd>。列表示数据集中使用的要素；例如，<kbd class="calibre12">Dur</kbd>代表持续时间，<kbd class="calibre12">Sport</kbd>代表源端口，依此类推。你可以在本章的 GitHub 资源库中找到完整的特性列表。</p>
<p class="calibre2">在训练模型之前，我们需要构建一些脚本来准备数据。这一次，我们将构建一个单独的 Python 脚本来准备数据，稍后我们可以将其导入到主脚本中。</p>
<p class="calibre2">我将调用第一个脚本<kbd class="calibre12">DataPreparation.py</kbd>。有许多建议用来帮助提取特征和准备数据，以使用机器学习来构建僵尸网络检测器。在我们的例子中，我定制了两个新的脚本，灵感来自<em class="calibre16"> NagabhushanS </em>构建的数据加载脚本:</p>
<pre class="calibre17"><strong class="calibre1">from __future__ import division</strong><br class="title-page-name"/><strong class="calibre1">import os, sys</strong><br class="title-page-name"/><strong class="calibre1">import threading</strong></pre>
<p class="calibre2">在导入所需的 Python 包之后，我们创建了一个名为<kbd class="calibre12">Prepare</kbd>的类来选择训练和测试数据:</p>
<pre class="calibre17"><strong class="calibre1">class Prepare(threading.Thread):   </strong><br class="title-page-name"/><strong class="calibre1">def __init__(self, X, Y, XT, YT, accLabel=None):</strong><br class="title-page-name"/><strong class="calibre1">    threading.Thread.__init__(self)</strong><br class="title-page-name"/><strong class="calibre1">    self.X = X</strong><br class="title-page-name"/><strong class="calibre1">    self.Y = Y</strong><br class="title-page-name"/><strong class="calibre1">    self.XT=XT</strong><br class="title-page-name"/><strong class="calibre1">    self.YT=YT</strong><br class="title-page-name"/><strong class="calibre1">    self.accLabel= accLabel</strong><br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">def run(self):</strong><br class="title-page-name"/><strong class="calibre1">    X = np.zeros(self.X.shape)</strong><br class="title-page-name"/><strong class="calibre1">    Y = np.zeros(self.Y.shape)</strong><br class="title-page-name"/><strong class="calibre1">    XT = np.zeros(self.XT.shape)</strong><br class="title-page-name"/><strong class="calibre1">    YT = np.zeros(self.YT.shape)</strong><br class="title-page-name"/><strong class="calibre1">    np.copyto(X, self.X)</strong><br class="title-page-name"/><strong class="calibre1">    np.copyto(Y, self.Y)</strong><br class="title-page-name"/><strong class="calibre1">    np.copyto(XT, self.XT)</strong><br class="title-page-name"/><strong class="calibre1">    np.copyto(YT, self.YT)</strong><br class="title-page-name"/><strong class="calibre1">    for i in range(9):</strong><br class="title-page-name"/><strong class="calibre1">        X[:, i] = (X[:, i] - X[:, i].mean()) / (X[:, i].std())</strong><br class="title-page-name"/><strong class="calibre1">    for i in range(9):</strong><br class="title-page-name"/><strong class="calibre1">        XT[:, i] = (XT[:, i] - XT[:, i].mean()) / (XT[:, i].std())</strong></pre>
<p class="calibre2">第二个剧本叫<kbd class="calibre12">LoadData.py</kbd>。你可以在 GitHub 上找到它，并在你的项目中直接使用它从<kbd class="calibre12">.binetflow</kbd>文件中加载数据并生成一个<kbd class="calibre12">pickle</kbd>文件。</p>
<p class="calibre2">让我们使用之前开发的工具来训练模型。在构建数据加载器并准备好我们将要使用的机器学习算法之后，是时候训练和测试模型了。</p>
<p class="calibre2">首先，从<kbd class="calibre12">pickle</kbd>文件加载数据，这就是为什么我们需要导入<kbd class="calibre12">pickle</kbd> Python 库。不要忘记使用以下命令导入前面的脚本:</p>
<pre class="calibre17"><strong class="calibre1">import LoadData</strong><br class="title-page-name"/><strong class="calibre1">import DataPreparation</strong><br class="title-page-name"/><strong class="calibre1">import pickle</strong><br class="title-page-name"/><strong class="calibre1">file = open('flowdata.pickle', 'rb')</strong><br class="title-page-name"/><strong class="calibre1">data  = pickle.load(file)</strong></pre>
<p class="calibre2">选择数据节:</p>
<pre class="calibre17"><strong class="calibre1">Xdata = data[0]</strong><br class="title-page-name"/><strong class="calibre1">Ydata =  data[1]</strong><br class="title-page-name"/><strong class="calibre1">XdataT = data[2]</strong><br class="title-page-name"/><strong class="calibre1">YdataT = data[3]</strong></pre>
<div><img src="img/00122.gif" class="calibre130"/></div>
<p class="calibre2">作为机器学习分类器，我们将尝试许多不同的算法，以便稍后我们可以为我们的模型选择最佳算法。导入所需的模块以使用来自<kbd class="calibre12">sklearn</kbd>的四种机器学习算法:</p>
<pre class="calibre17"><strong class="calibre1">from sklearn.linear_model import *</strong><br class="title-page-name"/><strong class="calibre1">from sklearn.tree import *</strong><br class="title-page-name"/><strong class="calibre1">from sklearn.naive_bayes import *</strong><br class="title-page-name"/><strong class="calibre1">from sklearn.neighbors import *</strong></pre>
<p class="calibre2">通过使用先前的模块构建来准备数据。不要忘记通过键入<kbd class="calibre12">import DataPreparation</kbd>来导入<kbd class="calibre12">DataPreparation</kbd>:</p>
<pre class="calibre17"><strong class="calibre1">&gt;&gt;&gt; DataPreparation.Prepare(Xdata,Ydata,XdataT,YdataT)</strong></pre>
<p class="calibre2">现在，我们可以训练模型；为此，我们将使用不同的技术来训练模型，以便稍后我们可以为我们的项目选择最合适的机器学习技术。步骤就像我们在之前的项目中学到的:准备好数据，选择好特征后，定义机器学习算法，拟合模型，定义好它的变量后打印出分数。</p>
<p class="calibre2">作为机器学习分类器，我们将测试其中的许多分类器。让我们从决策树开始:</p>
<ul class="calibre9">
<li class="calibre10"><strong class="calibre1">决策树模型</strong>:</li>
</ul>
<pre class="calibre131"><strong class="calibre1">&gt;&gt;&gt; clf = DecisionTreeClassifier()</strong><br class="title-page-name"/><strong class="calibre1">&gt;&gt;&gt; clf.fit(Xdata,Ydata)</strong><br class="title-page-name"/><strong class="calibre1">&gt;&gt;&gt; Prediction = clf.predict(XdataT)</strong><br class="title-page-name"/><strong class="calibre1">&gt;&gt;&gt; Score = clf.score(XdataT,YdataT)</strong><br class="title-page-name"/><strong class="calibre1">&gt;&gt;&gt; print (“The Score of the Decision Tree Classifier is”, Score * 100)</strong></pre>
<div><img src="img/00123.gif" class="calibre132"/></div>
<p class="calibre79">决策树分类器的得分是 99%</p>
<ul class="calibre9">
<li class="calibre10"><strong class="calibre1">逻辑回归模型</strong>:</li>
</ul>
<pre class="calibre131"><strong class="calibre1">&gt;&gt;&gt; clf = LogisticRegression(C=10000)</strong><br class="title-page-name"/><strong class="calibre1">&gt;&gt;&gt; clf.fit(Xdata,Ydata)</strong><br class="title-page-name"/><strong class="calibre1">&gt;&gt;&gt; Prediction = clf.predict(XdataT)<br class="title-page-name"/></strong><strong class="calibre1">&gt;&gt;&gt; Score = clf.score(XdataT,YdataT)</strong></pre>
<pre class="calibre131"><strong class="calibre1">&gt;&gt;&gt; print ("The Score of the Logistic Regression Classifier is", Score * 100)</strong></pre>
<div><img src="img/00124.gif" class="calibre133"/></div>
<p class="calibre56">逻辑回归分类器的得分是 96%</p>
<ul class="calibre9">
<li class="calibre10"><strong class="calibre1">高斯朴素贝叶斯模型</strong>:</li>
</ul>
<pre class="calibre131"><strong class="calibre1">&gt;&gt;&gt; clf = GaussianNB()</strong><br class="title-page-name"/><strong class="calibre1">&gt;&gt;&gt; clf.fit(Xdata,Ydata)</strong><br class="title-page-name"/><strong class="calibre1">&gt;&gt;&gt; Prediction = clf.predict(XdataT)</strong><br class="title-page-name"/><strong class="calibre1">&gt;&gt;&gt; Score = clf.score(XdataT,YdataT)</strong><br class="title-page-name"/><strong class="calibre1">&gt;&gt;&gt; print("The Score of the Gaussian Naive Bayes classifier is", Score * 100)</strong></pre>
<div><img src="img/00125.gif" class="calibre134"/></div>
<p class="calibre56">高斯朴素贝叶斯分类器的得分是 72%</p>
<ul class="calibre9">
<li class="calibre10"><strong class="calibre1">k-最近邻模型</strong>:</li>
</ul>
<pre class="calibre131"><strong class="calibre1">&gt;&gt;&gt; clf = KNeighborsClassifier()</strong><br class="title-page-name"/><strong class="calibre1">&gt;&gt;&gt; clf.fit(Xdata,Ydata)</strong><br class="title-page-name"/><strong class="calibre1">&gt;&gt;&gt; Prediction = clf.predict(XdataT)</strong><br class="title-page-name"/><strong class="calibre1">&gt;&gt;&gt; Score = clf.score(XdataT,YdataT)</strong><br class="title-page-name"/><strong class="calibre1">&gt;&gt;&gt; print("The Score of the K-Nearest Neighbours classifier is", Score * 100)</strong></pre>
<div><img src="img/00126.gif" class="calibre135"/></div>
<p class="calibre56">k-最近邻分类器的得分是 96%</p>
<ul class="calibre9">
<li class="calibre10"><strong class="calibre1">神经网络模型</strong>:</li>
</ul>
<p class="calibre56">若要建立神经网络模型，请使用以下代码:</p>
<pre class="calibre131"><strong class="calibre1">&gt;&gt;&gt; from keras.models import *</strong><br class="title-page-name"/><strong class="calibre1">&gt;&gt;&gt; from keras.layers import Dense, Activation</strong><br class="title-page-name"/><strong class="calibre1">&gt;&gt;&gt; from keras.optimizers import *</strong><br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">model = Sequential()</strong><br class="title-page-name"/><strong class="calibre1">model.add(Dense(10, input_dim=9, activation="sigmoid")) model.add(Dense(10, activation='sigmoid'))</strong><br class="title-page-name"/><strong class="calibre1">model.add(Dense(1))</strong><br class="title-page-name"/><strong class="calibre1">sgd = SGD(lr=0.01, decay=0.000001, momentum=0.9, nesterov=True) </strong><br class="title-page-name"/><strong class="calibre1">model.compile(optimizer=sgd, loss='mse')</strong><br class="title-page-name"/><strong class="calibre1">model.fit(Xdata, Ydata, nb_epoch=200, batch_size=100)</strong><br class="title-page-name"/><strong class="calibre1">Score = model.evaluate(XdataT, YdataT, verbose=0)</strong><br class="title-page-name"/><strong class="calibre1">Print(“The Score of the Neural Network is”, Score * 100  )</strong></pre>
<p class="calibre2">使用这段代码，我们导入了所需的 Keras 模块，构建了各个层，用 SGD 优化器编译了模型，拟合了模型，并打印出了模型的分数。</p>


            

            
        
    </body></html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>How to build a Twitter bot detector</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="30A8Q0-49a67f1d6e7843d3b2296f38e3fe05f5" class="calibre">
        

                            
                    <h1 class="header-title" id="calibre_pb_0">如何构建一个 Twitter 机器人检测器</h1>
                
            
            
                
<p class="calibre2">在前面的章节中，我们看到了如何构建基于机器学习的僵尸网络检测器。在这个新项目中，我们将处理一个不同的问题，而不是防御僵尸网络恶意软件。我们将检测 Twitter 机器人，因为它们也很危险，可以执行恶意操作。对于模型，我们将使用<em class="calibre16">NYU·坦登 2017 年春季机器学习竞赛:Twitter Bot 分类</em>数据集。你可以从这个链接下载:<a href="https://www.kaggle.com/c/twitter-bot-classification/data" class="calibre8">https://www.kaggle.com/c/twitter-bot-classification/data</a>。导入所需的 Python 包:</p>
<pre class="calibre17"><strong class="calibre1">&gt;&gt;&gt; import pandas as pd</strong><br class="title-page-name"/><strong class="calibre1">&gt;&gt;&gt; import numpy as np</strong><br class="title-page-name"/><strong class="calibre1">&gt;&gt;&gt; import seaborn</strong></pre>
<p class="calibre2">让我们使用 pandas 加载数据，并突出显示机器人和非机器人数据:</p>
<pre class="calibre17"><strong class="calibre1">&gt;&gt;&gt; data = pd.read_csv('training_data_2_csv_UTF.csv')</strong><br class="title-page-name"/><strong class="calibre1">&gt;&gt;&gt; Bots = data[data.bot==1]</strong><br class="title-page-name"/><strong class="calibre1">&gt;&gt; NonBots = data[data.bot==0]</strong></pre>
<div><img src="img/00127.gif" class="calibre136"/></div>


            

            
        
    </body></html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>Visualization with seaborn</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="318PC0-49a67f1d6e7843d3b2296f38e3fe05f5" class="calibre">
        

                            
                    <h1 class="header-title" id="calibre_pb_0">seaborn 可视化</h1>
                
            
            
                
<p class="calibre2">在每个项目中，我都想帮助您发现新的数据可视化 Python 库，因为正如您所见，数据工程和可视化对于每个以数据为中心的现代项目都是必不可少的。这一次，我选择了 seaborn 来可视化数据，并在开始训练阶段之前进行探索。Seaborn 是一个用于制作统计可视化的 Python 库。以下是使用 seaborn 生成图的示例:</p>
<pre class="calibre17"><strong class="calibre1">&gt;&gt;&gt; data = np.random.multivariate_normal([0, 0], [[5, 2], [2, 2]], size=2000)</strong><br class="title-page-name"/><strong class="calibre1">&gt;&gt;&gt; data = pd.DataFrame(data, columns=['x', 'y'])</strong><br class="title-page-name"/><strong class="calibre1">&gt;&gt;&gt; for col in 'xy':</strong><br class="title-page-name"/><strong class="calibre1">... seaborn.kdeplot(data[col], shade=True)</strong></pre>
<div><img src="img/00128.jpeg" class="calibre137"/></div>
<p class="calibre2">例如，在我们的例子中，如果我们想要识别丢失的数据:</p>
<pre class="calibre17">matplotlib.pyplot.figure(figsize=(10,6))<br class="title-page-name"/> seaborn.heatmap(data.isnull(), yticklabels=False, cbar=False, cmap='viridis')<br class="title-page-name"/> matplotlib.pyplot.tight_layout()</pre>
<div><img src="img/00129.jpeg" class="calibre138"/></div>
<p class="calibre2">前面的两个代码片段是学习如何可视化数据的一些例子。可视化有助于数据科学家探索和了解更多数据。现在，让我们回去继续构建我们的模型。</p>
<p class="calibre2">通过选择 Twitter 机器人使用的一些不良单词来识别单词包。下面是一个机器人使用脏话的例子。当然，你可以添加更多的单词:</p>
<pre class="calibre17">bag_of_words_bot = r'bot|b0t|cannabis|tweet me|mishear|follow me|updates every|gorilla|yes_ofc|forget' \<br class="title-page-name"/>r'expos|kill|bbb|truthe|fake|anony|free|virus|funky|RNA|jargon' \                 r'nerd|swag|jack|chick|prison|paper|pokem|xx|freak|ffd|dunia|clone|genie|bbb' \                r'ffd|onlyman|emoji|joke|troll|droop|free|every|wow|cheese|yeah|bio|magic|wizard|face'</pre>
<ul class="calibre9">
<li class="calibre10">现在，是时候确定培训功能了:</li>
</ul>
<pre class="calibre17">data['screen_name_binary'] = data.screen_name.str.contains(bag_of_words_bot, case=False, na=False)<br class="title-page-name"/>data['name_binary'] = data.name.str.contains(bag_of_words_bot, case=False, na=False)<br class="title-page-name"/>data['description_binary'] = data.description.str.contains(bag_of_words_bot, case=False, na=False)<br class="title-page-name"/>data['status_binary'] = data.status.str.contains(bag_of_words_bot, case=False, na=False)</pre>
<ul class="calibre9">
<li class="calibre10">特征提取:让我们选择<kbd class="calibre12">features</kbd>用于我们的模型:</li>
</ul>
<pre class="calibre81">data['listed_count_binary'] = (data.listed_count&gt;20000)==False<br class="title-page-name"/> features = ['screen_name_binary', 'name_binary', 'description_binary', 'status_binary', 'verified', 'followers_count', 'friends_count', 'statuses_count', 'listed_count_binary', 'bot']</pre>
<ul class="calibre9">
<li class="calibre10">现在，用决策树分类器训练模型:</li>
</ul>
<pre class="calibre81">from sklearn.tree import DecisionTreeClassifier<br class="title-page-name"/>from sklearn.metrics import accuracy_score, roc_curve, auc<br class="title-page-name"/>from sklearn.model_selection import train_test_split</pre>
<ul class="calibre9">
<li class="calibre10">我们导入了一些之前讨论过的模块:</li>
</ul>
<pre class="calibre81"> X = data[features].iloc[:,:-1]<br class="title-page-name"/> y = data[features].iloc[:,-1]</pre>
<ul class="calibre9">
<li class="calibre10">我们定义分类器:</li>
</ul>
<pre class="calibre81">clf = DecisionTreeClassifier(criterion='entropy', min_samples_leaf=50, min_samples_split=10)</pre>
<ul class="calibre9">
<li class="calibre10">我们拆分分类器:</li>
</ul>
<pre class="calibre81">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=101)</pre>
<ul class="calibre9">
<li class="calibre10">我们符合这个模型:</li>
</ul>
<pre class="calibre81"><strong class="calibre1">clf.fit(X_train, y_train)</strong><br class="title-page-name"/><strong class="calibre1">y_pred_train = clf.predict(X_train)</strong><br class="title-page-name"/><strong class="calibre1">y_pred_test = clf.predict(X_test)</strong></pre>
<ul class="calibre9">
<li class="calibre10">我们打印出准确度分数:</li>
</ul>
<pre class="calibre81"><strong class="calibre1">print("Training Accuracy: %.5f" %accuracy_score(y_train, y_pred_train))</strong><br class="title-page-name"/><strong class="calibre1">print("Test Accuracy: %.5f" %accuracy_score(y_test, y_pred_test))</strong></pre>
<p class="calibre2">我们的模型以 88%的检测率检测 Twitter 机器人，这是一个很好的准确率。</p>
<p class="calibre2">这种技术并不是检测僵尸网络的唯一可能的方法。研究人员基于不同的机器学习算法提出了许多其他模型，如线性 SVM 和决策树。所有这些技术都有 90%的准确率。大多数研究表明，特征工程是改进机器学习模型的关键因素。</p>
<p>为了研究一个真实世界的案例，请查看一篇名为<em class="calibre139">我们从学习中学到了什么——理解机器学习在僵尸网络攻击中的能力和局限性</em>(<a href="https://arxiv.org/pdf/1805.01333.pdf" class="calibre140">https://arxiv.org/pdf/1805.01333.pdf</a>)的论文，该论文由大卫·桑塔纳、尚·苏塔哈兰和索米亚·莫汉蒂主持。</p>


            

            
        
    </body></html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>Summary</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="3279U0-49a67f1d6e7843d3b2296f38e3fe05f5" class="calibre">
        

                            
                    <h1 class="header-title" id="calibre_pb_0">摘要</h1>
                
            
            
                
<p class="calibre2">本章是学习僵尸网络基础知识以及如何使用不同技术构建基于机器学习的检测器的轻量级指南。此外，我们还讨论了如何识别 Twitter 机器人。下一章将深入异常，以及如何构建许多项目来使用新颖的方法识别异常。</p>


            

            
        
    </body></html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>Questions</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="335QG0-49a67f1d6e7843d3b2296f38e3fe05f5" class="calibre">
        

                            
                    <h1 class="header-title" id="calibre_pb_0">问题</h1>
                
            
            
                
<p class="calibre2">正如我们在每一章之后所做的那样，我们将会给你机会来练习你所学的知识和评估你的技能。本章的 GitHub 存储库包含一个链接，指向<kbd class="calibre12">Practice</kbd>文件夹中的僵尸网络流量数据集:</p>
<ol class="calibre13">
<li value="1" class="calibre10">下载数据集并用 pandas 库加载它</li>
<li value="2" class="calibre10">选择合适的功能</li>
<li value="3" class="calibre10">识别训练集和测试集，然后将它们导出到 pickle 文件中</li>
<li value="4" class="calibre10">加载 pickle 文件</li>
<li value="5" class="calibre10">导入支持向量机分类器并拟合模型</li>
<li value="6" class="calibre10">训练 SVM 模型</li>
<li value="7" class="calibre10">打印出所建模型的精确度</li>
</ol>


            

            
        
    </body></html>


<html xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <title>Further reading</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="344B20-49a67f1d6e7843d3b2296f38e3fe05f5" class="calibre">
        

                            
                    <h1 class="header-title" id="calibre_pb_0">进一步阅读</h1>
                
            
            
                
<p class="calibre2">要了解更多关于僵尸网络以及如何使用机器学习来检测它们的信息，我强烈建议您查看这些有用的外部链接:</p>
<ul class="calibre9">
<li class="calibre10"><strong class="calibre1">僵尸网络如何扩张，如何防范:</strong><a href="https://bitninja.io/blog/2016/01/11/how-botnets-expand-and-how-protect-against-them" class="calibre8">https://bit ninja . io/blog/2016/01/11/How-botnets-expand-How-protect-against-them</a></li>
<li class="calibre10"><strong class="calibre1">僵尸网络基础——不要变成僵尸！</strong>:【https://blog.trendmicro.com/botnet-basics/】T2</li>
<li class="calibre10">用于僵尸检测的深度神经网络:<a href="https://arxiv.org/abs/1802.04289" class="calibre8">https://arxiv.org/abs/1802.04289</a></li>
<li class="calibre10"><strong class="calibre1">使用深度自动编码器对物联网僵尸网络攻击(N-BaIoT)进行基于网络的检测</strong>:<a href="https://arxiv.org/abs/1805.03409" class="calibre8">https://arxiv.org/abs/1805.03409</a></li>
</ul>
<ul class="calibre9">
<li class="calibre25"><strong class="calibre1">一种用于传感器网络入侵检测的混合谱聚类和深度神经网络集成算法</strong>(<a href="http://www.covert.io/research-papers/deep-learning-security/A%20Hybrid%20Spectral%20Clustering%20and%20Deep%20Neural%20Network%20Ensemble%20Algorithm%20for%20Intrusion%20Detection%20in%20Sensor%20Networks.pdf" class="calibre8">http://www . covert . io/research-papers/Deep-learning-security/A % 20 Hybrid % 20 Spectral % 20 Clustering % 20 and % 20 Deep % 20 Neural % 20 Network % 20 Ensemble % 20 Algorithm % 20 for % 20 Intrusion % 20 Detection % 20 in % 20 Sensor % 20 Networks . pdf</a></li>
<li class="calibre25"><strong class="calibre1">针对僵尸网络检测行为的递归神经网络分析</strong>(<a href="http://www.covert.io/research-papers/deep-learning-security/An%20Analysis%20of%20Recurrent%20Neural%20Networks%20for%20Botnet%20Detection%20Behavior.pdf" class="calibre8">http://www . covert . io/research-papers/deep-learning-security/An % 20 Analysis % 20 of % 20 Recurrent % 20 Neural % 20 Networks % 20 for % 20 Botnet % 20 Detection % 20 Behavior . pdf</a></li>
</ul>


            

            
        
    </body></html>
</body></html>