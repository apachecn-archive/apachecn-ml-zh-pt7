<html><head/><body>
<html>
  <head>
    <title>Chapter 9. Clustering</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div/><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09" class="calibre1"/>第九章。使聚集</h1></div></div></div><p class="calibre7">在本章中，我们将讨论以下主题:</p><div><ul class="itemizedlist"><li class="listitem">使用分层聚类对数据进行聚类</li><li class="listitem">将树切成一簇簇</li><li class="listitem">用k-means方法聚类数据</li><li class="listitem">绘制二元聚类图</li><li class="listitem">比较聚类方法</li><li class="listitem">从聚类中提取轮廓信息</li><li class="listitem">获得k-means的最佳聚类</li><li class="listitem">使用基于密度的方法聚类数据</li><li class="listitem">使用基于模型的方法对数据进行聚类</li><li class="listitem">可视化相异矩阵</li><li class="listitem">从外部验证集群</li></ul></div></div></body></html>


<html>
  <head>
    <title>Chapter 9. Clustering</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch09lvl1sec100" class="calibre1"/>简介</h1></div></div></div><p class="calibre7">聚类是<a id="id720" class="calibre1"/>一种用于将相似的对象(在距离上接近)分组在同一组(簇)中的技术。与前面章节中介绍的监督学习方法(例如，分类和回归)不同，聚类分析不使用任何标签信息，而是简单地使用数据特征之间的相似性来将它们分组到聚类中。</p><p class="calibre7">聚类可以广泛应用于商业分析。例如，营销部门可以使用聚类按个人属性对客户进行细分。因此，可以针对不同类型的客户设计不同的营销活动。</p><p class="calibre7">四种最常见的<a id="id721" class="calibre1"/>聚类方法<a id="id722" class="calibre1"/>是<a id="id723" class="calibre1"/>分层<a id="id724" class="calibre1"/>聚类、k-means聚类、基于模型的聚类和基于密度的聚类:</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre2">层次聚类</strong>:创建聚类的层次结构，并在<a id="id725" class="calibre1"/>树状图中呈现该层次结构。这种方法不需要在开始时指定簇的数量。</li><li class="listitem"><strong class="calibre2"> k-means聚类</strong>:也称平面聚类。与分层<a id="id726" class="calibre1"/>聚类不同，它不创建聚类的层次结构，并且它需要聚类的数量作为输入。但是，它的性能比层次聚类更快。</li><li class="listitem"><strong class="calibre2">基于模型的聚类</strong>:层次聚类和k-means聚类<a id="id727" class="calibre1"/>都使用启发式方法来构建聚类，并且不依赖于正式的模型。基于模型的分类假设一个数据模型，并应用EM算法来查找最可能的模型组件和分类数。</li><li class="listitem"><strong class="calibre2">基于密度的聚类</strong>:根据密度测量构建聚类。该方法中的聚类比数据集的剩余部分<a id="id728" class="calibre1"/>具有更高的密度。</li></ul></div><p class="calibre7">在下面的食谱中，我们将讨论如何使用这四种聚类技术对数据进行聚类。我们讨论如何在内部验证聚类，在聚类内使用平方和、平均轮廓宽度，在外部使用地面事实。</p></div></div></body></html>


<html>
  <head>
    <title>Clustering data with hierarchical clustering</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div/><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec101" class="calibre1"/>用层次聚类对数据进行聚类</h1></div></div></div><p class="calibre7">层次聚类采用凝聚或分割的方法来构建聚类的层次结构<a id="id729" class="calibre1"/>。无论采用哪种方法，都首先使用距离相似性度量来合并或分裂聚类。递归过程会继续，直到只剩下一个集群，或者无法再拆分更多的集群。最后，我们可以使用一个树状图来表示集群的层次结构。在本菜谱中，我们将演示如何使用分层聚类对客户进行聚类。</p></div></body></html>


<html>
  <head>
    <title>Clustering data with hierarchical clustering</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec345" class="calibre1"/>准备就绪</h2></div></div></div><p class="calibre7">在这个菜谱中，我们将对客户数据执行层次聚类，这涉及到将客户分成不同的组。你可以从这个Github页面下载数据:<a class="calibre1" href="https://github.com/ywchiu/ml_R_cookbook/tree/master/CH9">https://github.com/ywchiu/ml_R_cookbook/tree/master/CH9</a>。</p></div></div></body></html>


<html>
  <head>
    <title>Clustering data with hierarchical clustering</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec346" class="calibre1"/>怎么做...</h2></div></div></div><p class="calibre7">执行以下步骤将客户数据聚类到一个聚类层次结构中:</p><div><ol class="orderedlist"><li class="listitem" value="1">首先，你需要从<code class="email">customer.csv</code>加载数据并保存到<code class="email">customer</code> : <div> <pre class="programlisting"> <strong class="calibre2">&gt; customer= read.csv('customer.csv', header=TRUE)</strong> <strong class="calibre2">&gt; head(customer)</strong> <strong class="calibre2">  ID Visit.Time Average.Expense Sex Age</strong> <strong class="calibre2">1  1          3             5.7   0  10</strong> <strong class="calibre2">2  2          5            14.5   0  27</strong> <strong class="calibre2">3  3         16            33.5   0  32</strong> <strong class="calibre2">4  4          5            15.9   0  30</strong> <strong class="calibre2">5  5         16            24.9   0  23</strong> <strong class="calibre2">6  6          3            12.0   0  15</strong> </pre> </div></li><li class="listitem" value="2">然后您<a id="id730" class="calibre1"/>可以检查数据集结构:<div> <pre class="programlisting"> <strong class="calibre2">&gt; str(customer)</strong> <strong class="calibre2">'data.frame':  60 obs. of  5 variables:</strong> <strong class="calibre2"> $ ID             : int  1 2 3 4 5 6 7 8 9 10 ...</strong> <strong class="calibre2"> $ Visit.Time     : int  3 5 16 5 16 3 12 14 6 3 ...</strong> <strong class="calibre2"> $ Average.Expense: num  5.7 14.5 33.5 15.9 24.9 12 28.5 18.8 23.8 5.3 ...</strong> <strong class="calibre2"> $ Sex            : int  0 0 0 0 0 0 0 0 0 0 ...</strong> <strong class="calibre2"> $ Age            : int  10 27 32 30 23 15 33 27 16 11 ...</strong> </pre> </div></li><li class="listitem" value="3">接下来，您应该将客户数据归一化为相同的尺度:<div> <pre class="programlisting"> <strong class="calibre2">&gt; customer = scale(customer[,-1])</strong> </pre> </div></li><li class="listitem" value="4">然后，您可以使用聚合层次聚类对客户数据进行聚类:<div> <pre class="programlisting"> <strong class="calibre2">&gt; hc = hclust(dist(customer, method="euclidean"), method="ward.D2")</strong> <strong class="calibre2">&gt; hc</strong>  <strong class="calibre2">Call:</strong> <strong class="calibre2">hclust(d = dist(customer, method = "euclidean"), method = "ward.D2")</strong>  <strong class="calibre2">Cluster method   : ward.D2 </strong> <strong class="calibre2">Distance         : euclidean </strong> <strong class="calibre2">Number of objects: 60</strong> </pre> </div></li><li class="listitem" value="5">Lastly, you <a id="id731" class="calibre1"/>can use the <code class="email">plot</code> function to plot the dendrogram:<div><pre class="programlisting">
<strong class="calibre2">&gt; plot(hc, hang = -0.01, cex = 0.7)</strong>
</pre></div><div><img src="img/00150.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12">使用“ward”的系统聚类的树状图。D2”</p></div></div><p class="calibre13"> </p></li><li class="listitem" value="6">Additionally, you can use the single method to perform hierarchical clustering and see how the generated dendrogram differs from the previous:<div><pre class="programlisting">
<strong class="calibre2">&gt; hc2 = hclust(dist(customer), method="single")</strong>
<strong class="calibre2">&gt; plot(hc2, hang = -0.01, cex = 0.7)</strong>
</pre></div><div><img src="img/00151.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12">用“单”进行系统聚类的树状图</p></div></div><p class="calibre13"> </p></li></ol><div/></div></div></div></body></html>


<html>
  <head>
    <title>Clustering data with hierarchical clustering</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec347" class="calibre1"/>工作原理...</h2></div></div></div><p class="calibre7">分层<a id="id732" class="calibre1"/>聚类是一种聚类技术，它试图迭代地构建聚类的层次结构。一般来说，有两种方法可以构建分层集群:</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre2">凝聚层次聚类</strong>:这是一种自底向上的方法。每个观察<a id="id733" class="calibre1"/>在其自己的集群中开始<a id="id734" class="calibre1"/>。然后，我们可以计算每个聚类之间的相似性(或距离),然后在每次迭代中合并两个最相似的聚类，直到只剩下一个聚类。</li><li class="listitem"><strong class="calibre2">Divisive hierarchical clustering</strong>: This is a top-down approach. All observations <a id="id735" class="calibre1"/>start in <a id="id736" class="calibre1"/>one cluster, and then we split the cluster into the two least dissimilar clusters recursively until there is one cluster for each observation:<div><img src="img/00152.jpeg" alt="How it works..." class="calibre9"/><div><p class="calibre12">分层聚类的一个例子</p></div></div><p class="calibre13"> </p></li></ul></div><p class="calibre7">在执行层次聚类之前，我们需要确定这两个聚类有多相似。这里，我们列出了一些用于相似性度量的常见距离函数:</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre2">Single linkage</strong>: This <a id="id738" class="calibre1"/>refers to the shortest distance between two points in each cluster:<div><img src="img/00153.jpeg" alt="How it works..." class="calibre9"/></div><p class="calibre13"> </p></li><li class="listitem"><strong class="calibre2">Complete linkage</strong>: This<a id="id739" class="calibre1"/> refers to the longest distance between two points in each cluster:<div><img src="img/00154.jpeg" alt="How it works..." class="calibre9"/></div><p class="calibre13"> </p></li><li class="listitem"><strong class="calibre2">Average linkage</strong>: This<a id="id740" class="calibre1"/> refer to the average distance between two points in each cluster (where <img src="img/00155.jpeg" alt="How it works..." class="calibre24"/> is the size of cluster <img src="img/00156.jpeg" alt="How it works..." class="calibre24"/> and <img src="img/00157.jpeg" alt="How it works..." class="calibre24"/> is the size of cluster <img src="img/00158.jpeg" alt="How it works..." class="calibre24"/>):
<div><img src="img/00159.jpeg" alt="How it works..." class="calibre9"/></div><p class="calibre13"> </p></li><li class="listitem"><strong class="calibre2">Ward method</strong>: This<a id="id741" class="calibre1"/> refers to the sum of the squared distance from each point to the mean of the merged clusters (where <img src="img/00160.jpeg" alt="How it works..." class="calibre24"/> is the mean vector of <img src="img/00161.jpeg" alt="How it works..." class="calibre24"/>):
<div><img src="img/00162.jpeg" alt="How it works..." class="calibre9"/></div><p class="calibre13"> </p></li></ul></div><p class="calibre7">在这个方法中，我们对客户数据执行层次聚类。首先，我们从<code class="email">customer.csv</code>加载数据，然后将其加载到客户数据框中。在数据中，我们发现客户账户信息的五个<a id="id742" class="calibre1"/>变量，分别是ID、访问次数、平均费用、性别和年龄。由于每个变量的标度不同，我们使用标度函数来标准化标度。</p><p class="calibre7">在所有属性的尺度被标准化之后，我们使用<code class="email">hclust</code>函数执行层次聚类。我们使用欧几里德距离作为距离度量，并使用沃德最小方差法进行凝聚聚类。</p><p class="calibre7">最后，我们使用<code class="email">plot</code>函数来绘制层次聚类的树状图。我们指定<code class="email">hang</code>在树状图的底部显示标签，并使用<code class="email">cex</code>将标签缩小到正常大小的70%。为了比较使用<code class="email">ward.D2</code>和<code class="email">single</code>方法生成集群层次结构的差异，我们使用上图中的<code class="email">single</code>绘制了另一个树状图(步骤6)。</p></div></div></body></html>


<html>
  <head>
    <title>Clustering data with hierarchical clustering</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch09lvl2sec348" class="calibre1"/>还有更多...</h2></div></div></div><p class="calibre7">执行等级聚类时，您可以选择不同的距离度量和方法。更多详情，可参考<code class="email">dist</code>和<code class="email">hclust</code>的文档:</p><div><pre class="programlisting">
<strong class="calibre2">&gt; ? dist</strong>
<strong class="calibre2">&gt; ? hclust</strong>
</pre></div><p class="calibre7">在这个菜谱中，我们使用<code class="email">hclust</code>来执行凝聚层次聚类；如果您想执行分裂层次聚类，您可以使用<code class="email">diana</code>函数:</p><div><ol class="orderedlist"><li class="listitem" value="1">首先，您可以使用<code class="email">diana</code>来执行分裂式层次聚类:<div> <pre class="programlisting"> <strong class="calibre2">&gt; dv = diana(customer, metric = "euclidean")</strong> </pre> </div></li><li class="listitem" value="2">然后，您可以使用<code class="email">summary</code>获取汇总信息:<div> <pre class="programlisting"> <strong class="calibre2">&gt; summary(dv)</strong> </pre> </div></li><li class="listitem" value="3">最后，您可以使用<code class="email">plot</code>功能:<div> <pre class="programlisting"> <strong class="calibre2">&gt; plot(dv)</strong> </pre> </div>绘制树状图和横幅</li></ol><div/></div><p class="calibre7">如果你对绘制水平树状图感兴趣，你可以使用<code class="email">dendextend</code>包。使用以下程序生成水平树状图:</p><div><ol class="orderedlist"><li class="listitem" value="1">首先安装加载<code class="email">dendextend</code>和<code class="email">magrittr</code>包(如果你的R版本是3.1及以上，就不用安装加载<code class="email">magrittr</code>包):<div> <pre class="programlisting"> <strong class="calibre2">&gt; install.packages("dendextend")</strong> <strong class="calibre2">&gt; library(dendextend)</strong> <strong class="calibre2">&gt; install.packages("margrittr")</strong> <strong class="calibre2">&gt; library(magrittr)</strong> </pre> </div></li><li class="listitem" value="2">设置树状图:<div> <pre class="programlisting"> <strong class="calibre2">&gt; dend = customer %&gt;% dist %&gt;% hclust %&gt;% as.dendrogram</strong> </pre> </div></li><li class="listitem" value="3">Finally, plot the horizontal dendrogram:<div><pre class="programlisting">
<strong class="calibre2">dend %&gt;% plot(horiz=TRUE, main = "Horizontal Dendrogram")</strong>
</pre></div><div><img src="img/00163.jpeg" alt="There's more..." class="calibre9"/><div><p class="calibre12">水平树状图</p></div></div><p class="calibre13"> </p></li></ol><div/></div></div></div></body></html>


<html>
  <head>
    <title>Cutting trees into clusters</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div/><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec102" class="calibre1"/>将树木切割成簇</h1></div></div></div><p class="calibre7">在树状图中，我们可以看到聚类的层次结构，但是我们还没有将数据分组到不同的聚类中。但是，我们可以确定树状图中有多少个聚类，并在特定树高处切割树状图，以将数据分成不同的<a id="id744" class="calibre1"/>组。在这个配方中，我们演示了如何使用<code class="email">cutree</code>函数将数据分成给定数量的簇。</p></div></body></html>


<html>
  <head>
    <title>Cutting trees into clusters</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_1">准备就绪</h2></div></div></div><p class="calibre7">为了执行<code class="email">cutree</code>功能，您需要通过生成hclust对象<code class="email">hc</code>来完成之前的配方。</p></div></div></body></html>


<html>
  <head>
    <title>Cutting trees into clusters</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec350" class="calibre1"/>怎么做...</h2></div></div></div><p class="calibre7">执行以下步骤，将集群的层次结构分割成给定数量的集群:</p><div><ol class="orderedlist"><li class="listitem" value="1">首先，将数据分为四组:<div> <pre class="programlisting"> <strong class="calibre2">&gt; fit = cutree(hc, k = 4)</strong> </pre> </div></li><li class="listitem" value="2">然后，您可以检查数据的分类标签:<div> <pre class="programlisting"> <strong class="calibre2">&gt; fit</strong> <strong class="calibre2"> [1] 1 1 2 1 2 1 2 2 1 1 1 2 2 1 1 1 2 1 2 3 4 3 4 3 3 4 4 3 4</strong> <strong class="calibre2">[30] 4 4 3 3 3 4 4 3 4 4 4 4 4 4 4 3 3 4 4 4 3 4 3 3 4 4 4 3 4</strong> <strong class="calibre2">[59] 4 3</strong> </pre> </div></li><li class="listitem" value="3">统计每个聚类内的数据数量:<div> <pre class="programlisting"> <strong class="calibre2">&gt; table(fit)</strong> <strong class="calibre2">fit</strong> <strong class="calibre2"> 1  2  3  4 </strong> <strong class="calibre2">11  8 16 25 </strong> </pre> </div></li><li class="listitem" value="4">Finally, you can visualize how data is clustered with the red rectangle border:<div><pre class="programlisting">
<strong class="calibre2">&gt; plot(hc)</strong>
<strong class="calibre2">&gt; rect.hclust(hc, k = 4 , border="red")</strong>
</pre></div><div><img src="img/00164.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12">使用红色矩形边界来区分树状图中的不同聚类</p></div></div><p class="calibre13"> </p></li></ol><div/></div></div></div></body></html>


<html>
  <head>
    <title>Cutting trees into clusters</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec351" class="calibre1"/>工作原理...</h2></div></div></div><p class="calibre7">我们<a id="id745" class="calibre1"/>可以从上图的树状图中确定集群的数量。在这个配方中，我们确定树中应该有四个集群。因此，我们在<code class="email">cutree</code>函数中将聚类数指定为<code class="email">4</code>。除了使用簇的数量来切割树之外，您还可以将<code class="email">height</code>指定为切割树参数。</p><p class="calibre7">接下来，我们可以输出数据的分类标签，并使用<code class="email">table</code>函数来计算每个分类中的数据数量。从计数表中，我们发现大部分数据都在簇4中。最后，我们可以在聚类周围绘制红色矩形，以显示如何使用<code class="email">rect.hclust</code>函数将数据分类到四个聚类中。</p></div></div></body></html>


<html>
  <head>
    <title>Cutting trees into clusters</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_4">还有更多...</h2></div></div></div><p class="calibre7">除了在所有分层分类周围绘制矩形之外，您还可以在某个分类周围放置一个红色矩形:</p><div><pre class="programlisting">
<strong class="calibre2">&gt; rect.hclust(hc, k = 4 , which =2, border="red")</strong>
</pre></div><div><img src="img/00165.jpeg" alt="There's more..." class="calibre9"/><div><p class="calibre12">在某个集群周围绘制一个红色矩形。</p></div></div><p class="calibre10"> </p><p class="calibre7">此外，您可以通过使用<code class="email">dendextend</code>包，用红色矩形包围集群，从而用不同的颜色给集群着色。你必须完成前一个配方的<em class="calibre8">还有更多</em>部分中概述的说明，并执行以下步骤:</p><div><ol class="orderedlist"><li class="listitem" value="1">根据树枝所属的簇给树枝上色:<div> <pre class="programlisting"> <strong class="calibre2">&gt; dend %&gt;% color_branches(k=4) %&gt;% plot(horiz=TRUE, main = "Horizontal Dendrogram")</strong> </pre> </div></li><li class="listitem" value="2">You can then add a red rectangle around the clusters:<div><pre class="programlisting">
<strong class="calibre2">&gt; dend %&gt;% rect.dendrogram(k=4,horiz=TRUE)</strong>
</pre></div><div><img src="img/00166.jpeg" alt="There's more..." class="calibre9"/><div><p class="calibre12">在水平树状图中围绕聚类绘制红色矩形</p></div></div><p class="calibre13"> </p></li><li class="listitem" value="3">Finally, you<a id="id747" class="calibre1"/> can add a line to show the tree cutting location:<div><pre class="programlisting">
<strong class="calibre2">&gt; abline(v = heights_per_k.dendrogram(dend)["4"] + .1, lwd = 2, lty = 2, col = "blue")</strong>
</pre></div><div><img src="img/00167.jpeg" alt="There's more..." class="calibre9"/><div><p class="calibre12">在水平树状图中画一条切割线</p></div></div><p class="calibre13"> </p></li></ol><div/></div></div></div></body></html>


<html>
  <head>
    <title>Clustering data with the k-means method</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div/><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec103" class="calibre1"/>用k-means方法对数据进行聚类</h1></div></div></div><p class="calibre7">k-means聚类是一种平面聚类技术，它只产生一个具有<em class="calibre8"> k </em>个聚类的分区。与不要求用户在开始时确定聚类数目<a id="id748" class="calibre1"/>的分层聚类不同，k-means方法要求首先确定这个数目。然而，k-means聚类比层次聚类快得多，因为层次树的构建非常耗时。在这个菜谱中，我们将演示如何对客户数据集执行k-means聚类。</p></div></body></html>


<html>
  <head>
    <title>Clustering data with the k-means method</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_1">准备就绪</h2></div></div></div><p class="calibre7">在这个菜谱中，我们将继续使用客户数据集作为输入数据源来执行k-means聚类。</p></div></div></body></html>


<html>
  <head>
    <title>Clustering data with the k-means method</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec354" class="calibre1"/>怎么做...</h2></div></div></div><p class="calibre7">执行<a id="id749" class="calibre1"/>以下步骤，使用k-means方法对<code class="email">customer</code>数据集进行聚类:</p><div><ol class="orderedlist"><li class="listitem" value="1">首先，可以使用<code class="email">kmeans</code>对客户数据进行聚类:<div> <pre class="programlisting"> <strong class="calibre2">&gt; set.seed(22)</strong> <strong class="calibre2">&gt; fit = kmeans(customer, 4)</strong> <strong class="calibre2">&gt; fit</strong> <strong class="calibre2">K-means clustering with 4 clusters of sizes 8, 11, 16, 25</strong>  <strong class="calibre2">Cluster means:</strong> <strong class="calibre2">  Visit.Time Average.Expense        Sex        Age</strong> <strong class="calibre2">1  1.3302016       1.0155226 -1.4566845  0.5591307</strong> <strong class="calibre2">2 -0.7771737      -0.5178412 -1.4566845 -0.4774599</strong> <strong class="calibre2">3  0.8571173       0.9887331  0.6750489  1.0505015</strong> <strong class="calibre2">4 -0.6322632      -0.7299063  0.6750489 -0.6411604</strong>  <strong class="calibre2">Clustering vector:</strong> <strong class="calibre2"> [1] 2 2 1 2 1 2 1 1 2 2 2 1 1 2 2 2 1 2 1 3 4 3 4 3 3 4 4 3</strong> <strong class="calibre2">[29] 4 4 4 3 3 3 4 4 3 4 4 4 4 4 4 4 3 3 4 4 4 3 4 3 3 4 4 4</strong> <strong class="calibre2">[57] 3 4 4 3</strong>  <strong class="calibre2">Within cluster sum of squares by cluster:</strong> <strong class="calibre2">[1]  5.90040 11.97454 22.58236 20.89159</strong> <strong class="calibre2"> (between_SS / total_SS =  74.0 %)</strong>  <strong class="calibre2">Available components:</strong>  <strong class="calibre2">[1] "cluster"      "centers"      "totss"       </strong> <strong class="calibre2">[4] "withinss"     "tot.withinss" "betweenss"   </strong> <strong class="calibre2">[7] "size"         "iter"         "ifault</strong> </pre> </div></li><li class="listitem" value="2">You can then inspect the center of each cluster using <code class="email">barplot</code>:<div><pre class="programlisting">
<strong class="calibre2">&gt; barplot(t(fit$centers), beside = TRUE,xlab="cluster", ylab="value")</strong>
</pre></div><div><img src="img/00168.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12">四个聚类中不同属性中心的柱状图</p></div></div><p class="calibre13"> </p></li><li class="listitem" value="3">Lastly, you<a id="id750" class="calibre1"/> can draw a scatter plot of the data and color the points according to the clusters:<div><pre class="programlisting">
<strong class="calibre2">&gt; plot(customer, col = fit$cluster)</strong>
</pre></div><div><img src="img/00169.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12">散点图显示根据其分类标签着色的数据</p></div></div><p class="calibre13"> </p></li></ol><div/></div></div></div></body></html>


<html>
  <head>
    <title>Clustering data with the k-means method</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec355" class="calibre1"/>工作原理...</h2></div></div></div><p class="calibre7">k-means聚类是一种划分聚类的方法。该算法的目标是将n个<a id="id751" class="calibre1"/>对象划分成<em class="calibre8">个</em>簇，其中每个对象属于具有最近平均值的簇。该算法的目标是最小化<strong class="calibre2">类内平方和</strong> ( <strong class="calibre2"> WCSS </strong>)。假设<em class="calibre8"> x </em>是给定的一组<a id="id752" class="calibre1"/>观察值，S = <img src="img/00170.jpeg" alt="How it works..." class="calibre24"/>表示<em class="calibre8"> k </em>分区，而<img src="img/00171.jpeg" alt="How it works..." class="calibre24"/>是<img src="img/00172.jpeg" alt="How it works..." class="calibre24"/>的平均值，那么我们可以将WCSS函数公式化如下:</p><div><img src="img/00173.jpeg" alt="How it works..." class="calibre9"/></div><p class="calibre10"> </p><p class="calibre7">k均值聚类的过程可以通过以下五个步骤来说明:</p><div><ol class="orderedlist"><li class="listitem" value="1">指定<em class="calibre8"> k </em>簇的数量。</li><li class="listitem" value="2">随机创建k个分区。</li><li class="listitem" value="3">计算分区的中心。</li><li class="listitem" value="4">关联离聚类中心最近的对象。</li><li class="listitem" value="5">重复步骤2、3和4，直到WCSS变化很小(或最小化)。</li></ol><div/></div><p class="calibre7">在这个菜谱中，我们演示了如何使用k-means聚类对客户数据进行聚类。与层次聚类相比，k-means聚类需要用户输入K 的数量。在这个例子中，我们使用<em class="calibre8"> K=4 </em>。然后，拟合模型的输出显示了每个聚类的大小、四个生成的聚类的聚类平均值、关于每个数据点的聚类向量、聚类的类内平方和以及其他可用分量。</p><p class="calibre7">此外，您可以在条形图中绘制每个聚类的中心，这将提供关于每个属性如何影响聚类的更多详细信息。最后，我们在散点图中绘制数据点，并使用拟合的聚类标签来分配与聚类标签相关的颜色。</p></div></div></body></html>


<html>
  <head>
    <title>Clustering data with the k-means method</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch09lvl2sec356" class="calibre1"/>亦见</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">在k-means聚类分析中，可以指定用于执行聚类分析的算法。您可以指定Hartigan-Wong、Lloyd、Forgy或MacQueen作为聚类分析算法。更多详情请使用<code class="email">help</code>功能<a id="id753" class="calibre1"/>查阅<code class="email">kmeans</code>功能文档:<div> <pre class="programlisting"> <strong class="calibre2">&gt;help(kmeans)</strong> </pre> </div></li></ul></div></div></div></body></html>


<html>
  <head>
    <title>Drawing a bivariate cluster plot</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div/><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec104" class="calibre1"/>绘制二元聚类图</h1></div></div></div><p class="calibre7">在前面的配方中，我们采用了k-means方法来将数据归入聚类。但是，如果有两个以上的变量，就不可能显示数据是如何在二维空间中聚集的。因此，您可以使用二元聚类图，首先将变量缩减为两个分量，然后使用分量(如轴和圆)作为聚类，以显示<a id="id754" class="calibre1"/>数据是如何聚类的。在本食谱中，我们将说明如何创建二元聚类图。</p></div></body></html>


<html>
  <head>
    <title>Drawing a bivariate cluster plot</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_1">准备就绪</h2></div></div></div><p class="calibre7">在这个菜谱中，我们将继续使用<code class="email">customer</code>数据集作为输入数据源来绘制二元聚类图。</p></div></div></body></html>


<html>
  <head>
    <title>Drawing a bivariate cluster plot</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec358" class="calibre1"/>怎么做...</h2></div></div></div><p class="calibre7">执行以下步骤绘制二元聚类图:</p><div><ol class="orderedlist"><li class="listitem" value="1">安装并加载集群包:<div> <pre class="programlisting"> <strong class="calibre2">&gt; install.packages("cluster")</strong> <strong class="calibre2">&gt; library(cluster)</strong> </pre> </div></li><li class="listitem" value="2">You can then draw a bivariate cluster plot:<div><pre class="programlisting">
<strong class="calibre2">&gt; clusplot(customer, fit$cluster, color=TRUE, shade=TRUE)</strong>
</pre></div><div><img src="img/00174.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12">客户数据集的二元聚类图</p></div></div><p class="calibre13"> </p></li><li class="listitem" value="3">You can<a id="id755" class="calibre1"/> also zoom into the bivariate cluster plot:<div><pre class="programlisting">
<strong class="calibre2">&gt; par(mfrow= c(1,2))</strong>
<strong class="calibre2">&gt; clusplot(customer, fit$cluster, color=TRUE, shade=TRUE)</strong>
<strong class="calibre2">&gt; rect(-0.7,-1.7, 2.2,-1.2, border = "orange", lwd=2)</strong>
<strong class="calibre2">&gt; clusplot(customer, fit$cluster, color = TRUE, xlim = c(-0.7,2.2), ylim = c(-1.7,-1.2))</strong>
</pre></div><div><img src="img/00175.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12">二元聚类图的放大</p></div></div><p class="calibre13"> </p></li></ol><div/></div></div></div></body></html>


<html>
  <head>
    <title>Drawing a bivariate cluster plot</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec359" class="calibre1"/>工作原理...</h2></div></div></div><p class="calibre7">在这个配方中，我们绘制了一个二元聚类图来显示数据是如何聚类的。要绘制二元聚类图，我们首先需要安装<code class="email">cluster</code>包并将其加载到r中。然后我们使用<code class="email">clusplot</code>函数从客户数据集中绘制二元聚类图。在<code class="email">clustplot</code>功能中，我们可以设置<code class="email">shade</code>到<code class="email">TRUE</code>和<code class="email">color</code>到<code class="email">TRUE</code>来显示带有颜色和阴影的聚类。根据上图(步骤2 ),我们发现双变量使用两个分量作为x轴和y轴，这解释了85.01%的点可变性。然后<a id="id756" class="calibre1"/>数据点根据组件1和组件2散布在图上。同一聚类内的数据用相同的颜色和阴影圈出。</p><p class="calibre7">除了在单个图中绘制四个集群，您还可以使用<code class="email">rect</code>在给定的x轴和y轴范围内的特定区域周围添加一个矩形。然后，您可以通过使用<code class="email">clusplot</code>函数中的<code class="email">xlim</code>和<code class="email">ylim</code>来放大图表，以检查每个聚类中的数据。</p></div></div></body></html>


<html>
  <head>
    <title>Drawing a bivariate cluster plot</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_4">还有更多</h2></div></div></div><p class="calibre7"><code class="email">clusplot</code>功能使用<code class="email">princomp</code>和<code class="email">cmdscale</code>将原始特征尺寸减少到主成分。因此，我们可以看到数据如何聚集在一个图中，这两个分量分别为x轴和y轴。要了解更多关于<code class="email">princomp</code>和<code class="email">cmdscale</code>的信息，可以使用<code class="email">help</code>功能查看相关文档:</p><div><pre class="programlisting">
<strong class="calibre2">&gt; help(cmdscale)</strong>
<strong class="calibre2">&gt; help(princomp)</strong>
</pre></div><p class="calibre7">对于那些对如何使用<code class="email">cmdscale</code>减少尺寸感兴趣的人，请执行以下步骤:</p><div><pre class="programlisting">
<strong class="calibre2">&gt; mds = cmdscale(dist(customer), k = 2)</strong>
<strong class="calibre2">&gt; plot(mds, col = fit$cluster)</strong>
</pre></div><div><img src="img/00176.jpeg" alt="There's more" class="calibre9"/><div><p class="calibre12">关于缩放维度的数据散点图</p></div></div><p class="calibre10"> </p></div></div></body></html>


<html>
  <head>
    <title>Comparing clustering methods</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div/><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec105" class="calibre1"/>比较聚类方法</h1></div></div></div><p class="calibre7">在使用不同的聚类方法将数据归入聚类之后，您可能希望测量<a id="id757" class="calibre1"/>聚类的准确性。在大多数情况下，您可以使用集群内或集群间指标作为度量。我们现在介绍如何使用<code class="email">fpc</code>包中的<code class="email">cluster.stat</code>来比较不同的聚类方法。</p></div></body></html>


<html>
  <head>
    <title>Comparing clustering methods</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_1">做好准备</h2></div></div></div><p class="calibre7">为了执行聚类方法比较，需要通过生成<code class="email">customer</code>数据集来完成之前的配方。</p></div></div></body></html>


<html>
  <head>
    <title>Comparing clustering methods</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec362" class="calibre1"/>怎么做...</h2></div></div></div><p class="calibre7">执行以下步骤来比较聚类方法:</p><div><ol class="orderedlist"><li class="listitem" value="1">首先安装并加载<code class="email">fpc</code>包:<div> <pre class="programlisting"> <strong class="calibre2">&gt; install.packages("fpc")</strong> <strong class="calibre2">&gt; library(fpc)</strong> </pre> </div></li><li class="listitem" value="2">然后，您需要使用带有<code class="email">single</code>方法的层次聚类来对客户数据进行聚类，并生成对象<code class="email">hc_single</code> : <div> <pre class="programlisting"> <strong class="calibre2">&gt; single_c =  hclust(dist(customer), method="single")</strong> <strong class="calibre2">&gt; hc_single = cutree(single_c, k = 4)</strong> </pre> </div></li><li class="listitem" value="3">使用层次聚类和<code class="email">complete</code>方法对客户数据进行聚类，生成对象<code class="email">hc_complete</code> : <div> <pre class="programlisting"> <strong class="calibre2">&gt; complete_c =  hclust(dist(customer), method="complete")</strong> <strong class="calibre2">&gt; hc_complete =  cutree(complete_c, k = 4)</strong> </pre> </div></li><li class="listitem" value="4">然后您<a id="id758" class="calibre1"/>可以使用k-means聚类对客户数据进行聚类，并生成对象<code class="email">km</code> : <div> <pre class="programlisting"> <strong class="calibre2">&gt; set.seed(22)</strong> <strong class="calibre2">&gt; km = kmeans(customer, 4)</strong> </pre> </div></li><li class="listitem" value="5">接下来，检索任一聚类方法的聚类验证统计信息:<div> <pre class="programlisting"> <strong class="calibre2">&gt; cs = cluster.stats(dist(customer), km$cluster)</strong> </pre> </div></li><li class="listitem" value="6">大多数情况下，我们着重使用<code class="email">within.cluster.ss</code>和<code class="email">avg.silwidth</code>来验证聚类方法:<div> <pre class="programlisting"> <strong class="calibre2">&gt; cs[c("within.cluster.ss","avg.silwidth")]</strong> <strong class="calibre2">$within.cluster.ss</strong> <strong class="calibre2">[1] 61.3489</strong>  <strong class="calibre2">$avg.silwidth</strong> <strong class="calibre2">[1] 0.4640587</strong> </pre> </div></li><li class="listitem" value="7">最后，我们可以生成每种聚类方法的聚类统计信息，并以表格形式列出:<div> <pre class="programlisting"> <strong class="calibre2">&gt; sapply(list(kmeans = km$cluster, hc_single = hc_single, hc_complete = hc_complete), function(c) cluster.stats(dist(customer), c)[c("within.cluster.ss","avg.silwidth")])</strong> <strong class="calibre2">                  kmeans    hc_single hc_complete</strong> <strong class="calibre2">within.cluster.ss 61.3489   136.0092  65.94076</strong> <strong class="calibre2">avg.silwidth      0.4640587 0.2481926 0.4255961</strong> </pre> </div></li></ol><div/></div></div></div></body></html>


<html>
  <head>
    <title>Comparing clustering methods</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec363" class="calibre1"/>工作原理...</h2></div></div></div><p class="calibre7">在本菜谱中，我们将演示如何验证集群。为了验证聚类方法，我们通常采用两种技术:类间距离和类内距离。在这些技术中，簇间距离越高越好，簇内距离越低越好。为了计算相关的统计数据，我们可以将fpc包中的<code class="email">cluster.stat</code>应用到合适的聚类对象上。</p><p class="calibre7">从<a id="id759" class="calibre1"/>输出中，<code class="email">within.cluster.ss</code>测量值代表组内平方和，avg.silwidth代表平均轮廓宽度。<code class="email">within.cluster.ss</code>测量显示了集群中相关对象的紧密程度；该值越小，聚类中的相关对象越紧密。另一方面，轮廓是一种度量，它考虑了聚类中相关对象的紧密程度以及聚类之间的分离程度。数学上，我们可以定义每个点<em class="calibre8"> x </em>的轮廓宽度如下:</p><div><img src="img/00177.jpeg" alt="How it works..." class="calibre9"/></div><p class="calibre10"> </p><p class="calibre7">在前面的等式中，<em class="calibre8"> a(x) </em>是<em class="calibre8"> x </em>和该簇中所有其他点之间的平均距离，而<em class="calibre8"> b(x) </em>是x和其他簇中的点之间的平均距离的最小值。轮廓值通常在<em class="calibre8"> 0 </em>到<em class="calibre8"> 1 </em>之间；越接近<em class="calibre8"> 1 </em>的值表示数据聚类越好。</p><p class="calibre7">上一步生成的汇总表显示，在<code class="email">within.cluster.ss</code>和<code class="email">avg.silwidth</code>中，完全层次聚类方法优于单一层次聚类方法和k-means聚类。</p></div></div></body></html>


<html>
  <head>
    <title>Comparing clustering methods</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch09lvl2sec364" class="calibre1"/>参见</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem"><code class="email">kmeans</code>函数还输出统计数据(例如<code class="email">withinss</code>和<code class="email">betweenss</code>)供用户验证聚类方法:<div> <pre class="programlisting"> <strong class="calibre2">&gt; set.seed(22)</strong> <strong class="calibre2">&gt; km = kmeans(customer, 4)</strong> <strong class="calibre2">&gt; km$withinss</strong> <strong class="calibre2">[1]  5.90040 11.97454 22.58236 20.89159</strong> <strong class="calibre2">&gt; km$betweenss</strong> <strong class="calibre2">[1] 174.6511</strong> </pre> </div></li></ul></div></div></div></body></html>


<html>
  <head>
    <title>Extracting silhouette information from clustering</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div/><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec106" class="calibre1"/>从聚类中提取轮廓信息</h1></div></div></div><p class="calibre7">剪影<a id="id760" class="calibre1"/>信息是用于验证<a id="id761" class="calibre1"/>数据簇的测量值。在之前的<a id="id762" class="calibre1"/>配方中，我们提到了聚类的测量涉及计算数据在每个聚类中的聚集程度，并测量不同聚类之间的距离。轮廓系数结合了对簇内和簇间距离的测量。输出值的范围通常从<em class="calibre8"> 0 </em>到<em class="calibre8">1</em>；越靠近<em class="calibre8"> 1 </em>，集群越好。在本食谱中，我们将介绍如何计算轮廓信息。</p></div></body></html>


<html>
  <head>
    <title>Extracting silhouette information from clustering</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_1">做好准备</h2></div></div></div><p class="calibre7">在<a id="id763" class="calibre1"/>中，为了从群集中提取轮廓<a id="id764" class="calibre1"/>信息，您需要通过生成<code class="email">customer</code>数据集来完成之前的配方。</p></div></div></body></html>


<html>
  <head>
    <title>Extracting silhouette information from clustering</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec366" class="calibre1"/>怎么做...</h2></div></div></div><p class="calibre7">执行以下步骤来计算轮廓信息:</p><div><ol class="orderedlist"><li class="listitem" value="1">使用<code class="email">kmeans</code>生成一个k-means对象，<code class="email">km</code> : <div> <pre class="programlisting"> <strong class="calibre2">&gt; set.seed(22)</strong> <strong class="calibre2">&gt; km = kmeans(customer, 4)</strong> </pre> </div></li><li class="listitem" value="2">然后你可以计算轮廓信息:<div> <pre class="programlisting"> <strong class="calibre2">&gt; kms = silhouette(km$cluster,dist(customer))</strong> <strong class="calibre2">&gt; summary(kms)</strong> <strong class="calibre2">Silhouette of 60 units in 4 clusters from silhouette.default(x = km$cluster, dist = dist(customer)) :</strong> <strong class="calibre2"> Cluster sizes and average silhouette widths:</strong> <strong class="calibre2">        8        11        16        25 </strong> <strong class="calibre2">0.5464597 0.4080823 0.3794910 0.5164434 </strong> <strong class="calibre2">Individual silhouette widths:</strong> <strong class="calibre2">   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. </strong> <strong class="calibre2"> 0.1931  0.4030  0.4890  0.4641  0.5422  0.6333 </strong> </pre> </div></li><li class="listitem" value="3">Next, you can plot the silhouette information:<div><pre class="programlisting">
<strong class="calibre2">&gt; plot(kms)</strong>
</pre></div><div><img src="img/00178.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12">k均值聚类结果的轮廓图</p></div></div><p class="calibre13"> </p></li></ol><div/></div></div></div></body></html>


<html>
  <head>
    <title>Extracting silhouette information from clustering</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec367" class="calibre1"/>工作原理...</h2></div></div></div><p class="calibre7">在这个<a id="id765" class="calibre1"/>配方中，我们演示了如何<a id="id766" class="calibre1"/>使用轮廓图来验证聚类。您可以首先检索轮廓信息，该信息显示聚类大小、平均轮廓宽度和单个轮廓宽度。轮廓系数是从<em class="calibre8"> 0 </em>到<em class="calibre8"> 1 </em>的一个值；越接近<em class="calibre8"> 1 </em>，群集的质量越好。</p><p class="calibre7">最后，我们使用<code class="email">plot</code>函数绘制一个轮廓图。该图的左侧显示了水平线的数量，代表了聚类的数量。右栏显示了其自身聚类的图的平均相似性减去下一个相似聚类的平均相似性。平均轮廓宽度显示在图的底部。</p></div></div></body></html>


<html>
  <head>
    <title>Extracting silhouette information from clustering</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch09lvl2sec368" class="calibre1"/>参见</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">对于那些对如何计算轮廓感兴趣的人，请参考维基百科<a id="id767" class="calibre1"/>条目中的<strong class="calibre2">轮廓值</strong>:<a class="calibre1" href="http://en.wikipedia.org/wiki/Silhouette_%28clustering%29">http://en.wikipedia.org/wiki/Silhouette_%28clustering%29</a></li></ul></div></div></div></body></html>


<html>
  <head>
    <title>Obtaining the optimum number of clusters for k-means</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div/><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec107" class="calibre1"/>获得k-means的最佳聚类数</h1></div></div></div><p class="calibre7">虽然k-means聚类快速且易于使用，但它需要在开始时将<em class="calibre8"> k </em>作为输入。因此，我们可以使用平方和来确定哪个<em class="calibre8"> k </em>值最适合于找到k均值的最佳聚类数。在下面的食谱中，我们将讨论<a id="id768" class="calibre1"/>如何为k-means聚类方法找到最佳的聚类数。</p></div></body></html>


<html>
  <head>
    <title>Obtaining the optimum number of clusters for k-means</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_1">做好准备</h2></div></div></div><p class="calibre7">为了找到最佳的聚类数，您需要通过生成<code class="email">customer</code>数据集来完成之前的配方。</p></div></div></body></html>


<html>
  <head>
    <title>Obtaining the optimum number of clusters for k-means</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec370" class="calibre1"/>怎么做...</h2></div></div></div><p class="calibre7">执行以下步骤，找到k-means聚类的最佳聚类数:</p><div><ol class="orderedlist"><li class="listitem" value="1">首先，计算不同簇数的平方和(<code class="email">withinss</code>):<div><pre class="programlisting"> <strong class="calibre2">&gt; nk = 2:10</strong> <strong class="calibre2">&gt; set.seed(22)</strong> <strong class="calibre2">&gt; WSS = sapply(nk, function(k) {</strong> <strong class="calibre2">+     kmeans(customer, centers=k)$tot.withinss</strong> <strong class="calibre2">+ })</strong> <strong class="calibre2">&gt; WSS</strong> <strong class="calibre2">[1] 123.49224  88.07028  61.34890  48.76431  47.20813</strong> <strong class="calibre2">[6]  45.48114  29.58014  28.87519  23.21331</strong> </pre></div></li><li class="listitem" value="2">You can then use a line plot to plot the within sum of squares with a different number of <code class="email">k</code>:<div><pre class="programlisting">
<strong class="calibre2">&gt; plot(nk, WSS, type="l", xlab= "number of k", ylab="within sum of squares")</strong>
</pre></div><div><img src="img/00179.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12">不同k数的平方和内的线图</p></div></div><p class="calibre13"> </p></li><li class="listitem" value="3">接下来，您<a id="id769" class="calibre1"/>可以计算不同数量的簇的平均轮廓宽度(avg . sil width):<div><pre class="programlisting"> <strong class="calibre2">&gt; SW = sapply(nk, function(k) {</strong> <strong class="calibre2">+   cluster.stats(dist(customer), kmeans(customer, centers=k)$cluster)$avg.silwidth</strong> <strong class="calibre2">+ })</strong> <strong class="calibre2">&gt; SW</strong> <strong class="calibre2">[1] 0.4203896 0.4278904 0.4640587 0.4308448 0.3481157</strong> <strong class="calibre2">[6] 0.3320245 0.4396910 0.3417403 0.4070539</strong> </pre></div></li><li class="listitem" value="4">You can then use a line plot to plot the average silhouette width with a different number of <code class="email">k</code>:<div><pre class="programlisting">
<strong class="calibre2">&gt; plot(nk, SW, type="l", xlab="number of clusers", ylab="average silhouette width")</strong>
</pre></div><div><img src="img/00180.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12">关于不同k数的平均轮廓宽度的线图</p></div></div><p class="calibre13"> </p></li><li class="listitem" value="5">检索<a id="id770" class="calibre1"/>集群的最大数量:<div> <pre class="programlisting"> <strong class="calibre2">&gt; nk[which.max(SW)]</strong> <strong class="calibre2">[1] 4</strong> </pre> </div></li></ol><div/></div></div></div></body></html>


<html>
  <head>
    <title>Obtaining the optimum number of clusters for k-means</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec371" class="calibre1"/>工作原理...</h2></div></div></div><p class="calibre7">在这个配方中，我们演示了如何通过迭代获得平方和和平均轮廓值来找到最佳的聚类数。对于平方和，较低的值表示聚类质量较好。通过绘制不同数量的<code class="email">k</code>的平方和，我们发现曲线的拐点在<code class="email">k=4</code>。</p><p class="calibre7">另一方面，我们也使用<code class="email">cluster.stats</code>基于不同的聚类数计算平均轮廓宽度。此外，我们可以使用线形图来绘制关于不同数量的簇的平均轮廓宽度。上图(步骤4)显示最大平均轮廓宽度出现在<code class="email">k=4</code>。最后，我们使用<code class="email">which.max</code>来获得k的值，以确定最大平均轮廓宽度的位置。</p></div></div></body></html>


<html>
  <head>
    <title>Obtaining the optimum number of clusters for k-means</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch09lvl2sec372" class="calibre1"/>参见</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">对于那些对如何计算平方和感兴趣的人，请参考维基百科<strong class="calibre2"> K均值聚类</strong>的<a id="id772" class="calibre1"/>条目:<a class="calibre1" href="http://en.wikipedia.org/wiki/K-means_clustering">http://en.wikipedia.org/wiki/K-means_clustering</a></li></ul></div></div></div></body></html>


<html>
  <head>
    <title>Clustering data with the density-based method</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div/><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec108" class="calibre1"/>使用基于密度的方法对数据进行聚类</h1></div></div></div><p class="calibre7">作为距离测量的<a id="id773" class="calibre1"/>替代方法，您可以使用基于密度的测量对数据进行聚类。这种方法会找到比剩余区域密度更高的区域。最著名的方法之一就是<a id="id774" class="calibre1"/> DBSCAN。在下面的菜谱中，我们将演示<a id="id775" class="calibre1"/>如何使用DBSCAN来<a id="id776" class="calibre1"/>执行基于密度的聚类。</p></div></body></html>


<html>
  <head>
    <title>Clustering data with the density-based method</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_1">准备就绪</h2></div></div></div><p class="calibre7">在这个配方中，我们将使用从<code class="email">mlbench</code>包中生成的模拟数据。</p></div></div></body></html>


<html>
  <head>
    <title>Clustering data with the density-based method</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec374" class="calibre1"/>怎么做...</h2></div></div></div><p class="calibre7">执行以下步骤来执行基于密度的聚类:</p><div><ol class="orderedlist"><li class="listitem" value="1">首先安装并加载<code class="email">fpc</code>和<code class="email">mlbench</code>包:<div> <pre class="programlisting"> <strong class="calibre2">&gt; install.packages("mlbench")</strong> <strong class="calibre2">&gt; library(mlbench)</strong> <strong class="calibre2">&gt; install.packages("fpc")</strong> <strong class="calibre2">&gt; library(fpc)</strong> </pre> </div></li><li class="listitem" value="2">You can then use the <code class="email">mlbench</code> library to draw a Cassini problem graph:<div><pre class="programlisting">
<strong class="calibre2">&gt; set.seed(2)</strong>
<strong class="calibre2">&gt; p = mlbench.cassini(500)</strong>
<strong class="calibre2">&gt; plot(p$x)</strong>
</pre></div><div><img src="img/00181.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12">卡西尼问题图</p></div></div><p class="calibre13"> </p></li><li class="listitem" value="3">接下来，你可以用<a id="id777" class="calibre1"/>聚类<a id="id778" class="calibre1"/>数据对其进行<a id="id779" class="calibre1"/>密度测量:<div> <pre class="programlisting"> <strong class="calibre2">&gt; ds = dbscan(dist(p$x),0.2, 2, countmode=NULL, method="dist")</strong> <strong class="calibre2">&gt; ds</strong> <strong class="calibre2">dbscan Pts=500 MinPts=2 eps=0.2</strong> <strong class="calibre2">        1   2   3</strong> <strong class="calibre2">seed  200 200 100</strong> <strong class="calibre2">total 200 200 100</strong> </pre> </div></li><li class="listitem" value="4">Plot the data in a scatter plot with different cluster labels as the color:<div><pre class="programlisting">
<strong class="calibre2">&gt; plot(ds, p$x)</strong>
</pre></div><div><img src="img/00182.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12">数据散点图根据分类标签进行着色</p></div></div><p class="calibre13">你<a id="id780" class="calibre1"/>也可以用<code class="email">dbscan</code>到<a id="id781" class="calibre1"/>预测<a id="id782" class="calibre1"/>该数据点属于哪个聚类。在这个例子中，首先在矩阵<code class="email">p</code> : <div> <pre class="programlisting"> <strong class="calibre2">&gt; y = matrix(0,nrow=3,ncol=2)</strong> <strong class="calibre2">&gt; y[1,] = c(0,0)</strong> <strong class="calibre2">&gt; y[2,] = c(0,-1.5)</strong> <strong class="calibre2">&gt; y[3,] = c(1,1)</strong> <strong class="calibre2">&gt; y</strong> <strong class="calibre2">     [,1] [,2]</strong> <strong class="calibre2">[1,]    0  0.0</strong> <strong class="calibre2">[2,]    0 -1.5</strong> <strong class="calibre2">[3,]    1  1.0</strong> </pre> </div>中做三个输入</p></li><li class="listitem" value="5">然后，您可以预测数据属于哪个集群:<div> <pre class="programlisting"> <strong class="calibre2">&gt; predict(ds, p$x, y)</strong> <strong class="calibre2">[1] 3 1 2</strong> </pre> </div></li><li class="listitem" value="6">它是如何工作的...</li></ol><div/></div></div></div></body></html>


<html>
  <head>
    <title>Clustering data with the density-based method</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_3">基于密度的聚类使用密度可达性和密度连通性的思想，这使得它在发现非线性形状的聚类时非常有用。在讨论基于密度的聚类过程之前，必须解释一些重要的背景概念。基于密度的聚类考虑了两个参数:<code class="email">eps</code>和<code class="email">MinPts</code>。<code class="email">eps</code>代表邻域的最大半径；<code class="email">MinPts</code>表示<code class="email">eps</code>邻域内的最小点数。有了这两个参数，我们可以将核心点定义为在<code class="email">eps</code>内有多于<code class="email">MinPts</code>的点。此外，我们可以将板点定义为具有小于<code class="email">MinPts</code>的点，但是在核心点的附近。然后，我们可以定义核心对象，好像在<code class="email">p</code>的<code class="email">eps</code>-邻域中的点数多于<code class="email">MinPts</code>。</h2></div></div></div><p class="calibre7">此外，我们必须定义两点之间的可达性。如果q在<code class="email">p</code>的<code class="email">eps</code>邻域内并且<code class="email">p</code>是一个核心物体，我们可以说一个点<code class="email">p</code>是从另一个点<code class="email">q</code>直接密度可达的。然后，我们可以定义一个点<code class="email">p</code>是一般的，并且从该点<code class="email">q</code>密度可达，如果存在一个点链，p <sub class="calibre25"> 1 </sub>，p <sub class="calibre25"> 2 </sub>...，p <sub class="calibre25"> n </sub>，其中p <sub class="calibre25"> 1 </sub> = q，p <sub class="calibre25"> n </sub> = p，p <sub class="calibre25"> i </sub> +1是从pi到Eps的直接可达密度，对于1 &lt; = i &lt; = n:</p><p class="calibre7">点p和q是密度可达的</p><div><img src="img/00183.jpeg" alt="How it works..." class="calibre9"/><div><p class="calibre12">Point p and q is density reachable</p></div></div><p class="calibre10">有了<a id="id783" class="calibre1"/>基于密度的<a id="id784" class="calibre1"/>聚类的初步概念，我们就可以用<a id="id785" class="calibre1"/>来说明DBSCAN(最流行的基于密度的聚类)的过程，如以下步骤所示:</p><p class="calibre7">随机选择一个点，<code class="email">p</code>。</p><div><ol class="orderedlist"><li class="listitem" value="1">相对于<code class="email">Eps</code>和<code class="email">MinPts</code>，从<code class="email">p</code>检索所有密度可达的点。</li><li class="listitem" value="2">如果<code class="email">p</code>是一个核心点，那么就形成了一个集群。否则，如果它是一个板点，并且没有从<code class="email">p</code>密度可达的点，该过程将把该点标记为噪声，并继续访问下一个点。</li><li class="listitem" value="3">重复这个过程，直到所有的点都被访问过。</li><li class="listitem" value="4">在本菜谱中，我们将演示如何使用基于密度的DBSCAN方法对客户数据进行聚类。首先，我们必须安装并加载<code class="email">mlbench</code>和<code class="email">fpc</code>库。<code class="email">mlbench</code>包提供了多种方法来生成不同形状和大小的模拟数据。在这个例子中，我们生成了一个卡西尼问题图。</li></ol><div/></div><p class="calibre7">接下来，我们对Cassini数据集执行<code class="email">dbscan</code>来对数据进行聚类。我们指定可达性距离为0.2，到达<code class="email">2</code>的最小可达性点数，进度报告为空，并使用距离作为度量。该聚类方法成功地将数据分为大小为200、200和100的三个聚类。通过在图上绘制点和簇标签，我们看到卡西尼图的三个部分以不同的颜色分开。</p><p class="calibre7"><code class="email">fpc</code>包还提供了一个<code class="email">predict</code>函数，你可以用它来预测输入矩阵的集群<a id="id786" class="calibre1"/>标签。点c(0，0)被归入聚类3，点c(0，-1.5)被归入聚类1，点c(1，1)被归入聚类2。</p><p class="calibre7"><a id="ch09lvl2sec376" class="calibre1"/>参见</p></div></div></body></html>


<html>
  <head>
    <title>Clustering data with the density-based method</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><code class="email">fpc</code>包包含了灵活的聚类过程，并具有有用的聚类<a id="id787" class="calibre1"/>分析功能。对于<a id="id788" class="calibre1"/>示例，您可以使用<code class="email">plotcluster</code>函数生成一个判别投影图。更多信息，请参考以下文档:<div> <pre class="programlisting"> <strong class="calibre2">&gt; help(plotcluster)</strong> </pre> </div></h2></div></div></div><div><ul class="itemizedlist"><li class="listitem"><a id="ch09lvl1sec109" class="calibre1"/>用基于模型的方法对数据进行聚类</li></ul></div></div></div></body></html>


<html>
  <head>
    <title>Clustering data with the model-based method</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div/><div><div><div><div><h1 class="title" id="calibre_pb_0">与使用启发式方法<a id="id789" class="calibre1"/>且不依赖于正式模型的分层聚类和k-means聚类相反。基于模型的聚类技术假设各种数据模型，并应用EM算法来获得最可能的模型，并进一步使用该模型来推断最可能的聚类数。在本食谱中，我们将演示如何使用基于模型的方法来确定最可能的聚类数。</h1></div></div></div><p class="calibre7">准备就绪</p></div></body></html>


<html>
  <head>
    <title>Clustering data with the model-based method</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_1">为了执行基于模型的方法来对客户数据进行聚类，您需要通过生成客户数据集来完成前面的配方。</h2></div></div></div><p class="calibre7"><a id="ch09lvl2sec378" class="calibre1"/>怎么做...</p></div></div></body></html>


<html>
  <head>
    <title>Clustering data with the model-based method</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_2">执行以下步骤来执行基于模型的聚类:</h2></div></div></div><p class="calibre7">首先，请安装并加载库<code class="email">mclust</code> : <div> <pre class="programlisting"> <strong class="calibre2">&gt; install.packages("mclust")</strong> <strong class="calibre2">&gt; library(mclust)</strong> </pre> </div></p><div><ol class="orderedlist"><li class="listitem" value="1">然后，<a id="id790" class="calibre1"/>可以在<code class="email">customer</code>数据集上执行基于模型的聚类:<div> <pre class="programlisting"> <strong class="calibre2">&gt; mb = Mclust(customer)</strong> <strong class="calibre2">&gt; plot(mb)</strong> </pre> </div></li><li class="listitem" value="2">BIC与组件数量的关系图</li><li class="listitem" value="3">Then, you can press 1 to obtain the BIC against a number of components:<div><img src="img/00184.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12">Plot of BIC against number of components</p></div></div><p class="calibre13">显示不同特征组合分类的图</p></li><li class="listitem" value="4">Then, you can press 2 to show the classification with regard to different combinations of features:<div><img src="img/00185.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12">Plot showing classification with regard to different combinations of features</p></div></div><p class="calibre13">显示不同特征组合的分类不确定性的图</p></li><li class="listitem" value="5">Press 3 <a id="id791" class="calibre1"/>to show the classification uncertainty with regard to different combinations of features:<div><img src="img/00186.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12">Plot showing classification uncertainty with regard to different combinations of features</p></div></div><p class="calibre13">密度估计图</p></li><li class="listitem" value="6">Next, press 4 to plot the density estimation:<div><img src="img/00187.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12">A plot of density estimation</p></div></div><p class="calibre13">然后，你<a id="id792" class="calibre1"/>可以按0出图密度，退出出图菜单。</p></li><li class="listitem" value="7">最后，使用<code class="email">summary</code>函数获得最可能的模型和聚类数:<div> <pre class="programlisting"> <strong class="calibre2">&gt; summary(mb)</strong> <strong class="calibre2">----------------------------------------------------</strong> <strong class="calibre2">Gaussian finite mixture model fitted by EM algorithm </strong> <strong class="calibre2">----------------------------------------------------</strong>  <strong class="calibre2">Mclust VII (spherical, varying volume) model with 5 components:</strong>  <strong class="calibre2"> log.likelihood  n df       BIC       ICL</strong> <strong class="calibre2">      -218.6891 60 29 -556.1142 -557.2812</strong>  <strong class="calibre2">Clustering table:</strong> <strong class="calibre2"> 1  2  3  4  5</strong> <strong class="calibre2">11  8 17 14 10</strong> </pre> </div></li><li class="listitem" value="8"><a id="ch09lvl2sec379" class="calibre1"/>工作原理...</li></ol><div/></div></div></div></body></html>


<html>
  <head>
    <title>Clustering data with the model-based method</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_3">基于模型的聚类使用基于概率的方法，而不是采用启发式方法来构建聚类。基于模型的聚类假设数据是由一个<a id="id793" class="calibre1"/>潜在概率分布生成的，并试图从数据中恢复该分布。一种常见的基于模型的方法是使用有限混合模型，该模型为概率分布的分析提供了灵活的建模框架。有限混合模型是成分概率分布的线性加权和。假设数据<em class="calibre8"> y=(y <sub class="calibre25"> 1 </sub>，y <sub class="calibre25"> 2 </sub> …y <sub class="calibre25"> n </sub> ) </em>包含n个独立的多变量观测值；g是部件的数量；有限混合模型的可能性可以用公式表示为:</h2></div></div></div><p class="calibre7">Instead of taking a heuristic approach to build a cluster, model-based clustering uses a probability-based approach. Model-based clustering assumes that the data is generated by an <a id="id793" class="calibre1"/>underlying probability distribution and tries to recover the distribution from the data. One common model-based approach is using finite mixture models, which provide a flexible modeling framework for the analysis of the probability distribution. Finite mixture models are a linearly weighted sum of component probability distribution. Assume the data <em class="calibre8">y=(y<sub class="calibre25">1</sub>,y<sub class="calibre25">2</sub>…y<sub class="calibre25">n</sub>)</em> contains n independent and multivariable observations; G is the number of components; the likelihood of finite mixture models can be formulated as:</p><div><img src="img/00188.jpeg" alt="How it works..." class="calibre9"/></div><p class="calibre10">其中<img src="img/00189.jpeg" alt="How it works..." class="calibre24"/>和<img src="img/00190.jpeg" alt="How it works..." class="calibre24"/>是混合物中第<em class="calibre8"> k </em>个成分的密度和参数，<img src="img/00191.jpeg" alt="How it works..." class="calibre24"/> ( <img src="img/00192.jpeg" alt="How it works..." class="calibre24"/>和<img src="img/00193.jpeg" alt="How it works..." class="calibre24"/>)是一个观测值属于第<em class="calibre8"> k </em>个成分的概率。</p><p class="calibre7">基于模型的聚类过程有几个步骤:首先，该过程选择组件概率分布的数量和类型。然后，它拟合一个有限混合模型，并计算一个组件成员的后验概率。最后，它将每个观察值的隶属度分配给具有最大概率的组件。</p><p class="calibre7">在这个菜谱中，我们演示了如何使用基于模型的聚类来对数据进行聚类。我们首先将<code class="email">Mclust</code>库安装并加载到r中。然后使用<code class="email">Mclust</code>函数将客户数据放入基于模型的方法中。</p><p class="calibre7">数据适合模型后，我们根据聚类结果绘制模型。有四种不同的图:BIC、分类、不确定性和密度图。BIC图显示了BIC值，人们可以使用这个值来选择集群的数量。分类图显示了数据如何根据不同的维度组合进行聚类。不确定性图显示了不同维度组合的分类不确定性。密度图显示等高线中的密度估计值。</p><p class="calibre7">你<a id="id794" class="calibre1"/>也可以使用<code class="email">summary</code>函数获得最可能的模型和最可能的聚类数。对于本例，最大可能的聚类数是5，BIC值等于-556.1142。</p><p class="calibre7"><a id="ch09lvl2sec380" class="calibre1"/>参见</p></div></div></body></html>


<html>
  <head>
    <title>Clustering data with the model-based method</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_4">对于那些对<code class="email">Mclust</code>如何工作的细节感兴趣的人，请参考以下来源:C. Fraley，A. E. Raftery，T. B. Murphy和L. Scrucca (2012)。<em class="calibre8"> mclust第4版R:基于模型的聚类、分类和密度估计的正态混合建模</em>。<em class="calibre8">华盛顿大学统计系第597号技术报告</em>。</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem"><a id="ch09lvl1sec110" class="calibre1"/>可视化相异矩阵</li></ul></div></div></div></body></html>


<html>
  <head>
    <title>Visualizing a dissimilarity matrix</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div/><div><div><div><div><h1 class="title" id="calibre_pb_0">相异度矩阵<a id="id795" class="calibre1"/>可以用作群集质量<a id="id796" class="calibre1"/>的度量。为了可视化矩阵，我们可以在距离矩阵上使用热图。在图中，不相似性低(或相似性高)的条目绘制得较暗，这有助于识别数据中的隐藏结构。在这份食谱中，我们将讨论一些有用的可视化相异矩阵的技术。</h1></div></div></div><p class="calibre7">准备就绪</p></div></body></html>


<html>
  <head>
    <title>Visualizing a dissimilarity matrix</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_1">为了可视化差异矩阵，您需要通过生成客户数据集来完成之前的配方。除此之外，还需要生成一个k-means对象并存储在变量<code class="email">km</code>中。</h2></div></div></div><p class="calibre7"><a id="ch09lvl2sec382" class="calibre1"/>怎么做...</p></div></div></body></html>


<html>
  <head>
    <title>Visualizing a dissimilarity matrix</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_2">执行以下步骤来可视化相异度矩阵:</h2></div></div></div><p class="calibre7">首先安装并加载<code class="email">seriation</code>包:<div> <pre class="programlisting"> <strong class="calibre2">&gt; install.packages("seriation")</strong> <strong class="calibre2">&gt; library(seriation)</strong> </pre> </div></p><div><ol class="orderedlist"><li class="listitem" value="1">k-均值聚类的相异度图</li><li class="listitem" value="2">You can then use <code class="email">dissplot</code> to visualize the dissimilarity matrix in a heat map:<div><pre class="programlisting">
<strong class="calibre2">&gt; dissplot(dist(customer), labels=km$cluster, options=list(main="Kmeans Clustering With k=4"))</strong>
</pre></div><div><img src="img/00194.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12">A dissimilarity plot of k-means clustering</p></div></div><p class="calibre13">层次聚类的相异度图</p></li><li class="listitem" value="3">Next, apply <code class="email">dissplot</code> on<a id="id797" class="calibre1"/> hierarchical clustering in the heat map:<div><pre class="programlisting">
<strong class="calibre2">&gt; complete_c =  hclust(dist(customer), method="complete")</strong>
<strong class="calibre2">&gt; hc_complete =  cutree(complete_c, k = 4)</strong>
<strong class="calibre2">&gt; dissplot(dist(customer), labels=hc_complete, options=list(main="Hierarchical Clustering"))</strong>
</pre></div><div><img src="img/00195.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12">A dissimilarity plot of hierarchical clustering</p></div></div><p class="calibre13">它是如何工作的...</p></li></ol><div/></div></div></div></body></html>


<html>
  <head>
    <title>Visualizing a dissimilarity matrix</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_3">在这个配方中，我们使用相异度图来可视化相异度矩阵。我们首先安装<a id="id798" class="calibre1"/>并加载包<code class="email">seriation</code>，然后对k-means聚类输出应用<code class="email">dissplot</code>函数，生成前面的图(步骤2)。</h2></div></div></div><p class="calibre7">它显示了彼此相似的聚类被绘制得较暗，而不相似的组合被绘制得较亮。因此，我们可以看到聚类相对于它们对应的聚类(例如聚类4到聚类4)被绘制成对角线并且更暗。另一方面，彼此不相似的聚类被绘制得更亮并且远离对角线。</p><p class="calibre7">同样，我们可以对层次聚类的输出应用<code class="email">dissplot</code>函数。图中生成的图(步骤3)显示了单个热图中每个聚类的相似性。</p><p class="calibre7">还有更多...</p></div></div></body></html>


<html>
  <head>
    <title>Visualizing a dissimilarity matrix</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_4">除了使用<code class="email">dissplot</code>来可视化相异度矩阵，还可以使用<code class="email">dist</code>和<code class="email">image</code>函数来可视化距离矩阵。在结果图中，密切相关的条目用红色标出。不太相关的条目绘制成更接近白色:</h2></div></div></div><p class="calibre7">客户数据集的距离矩阵图</p><div><pre class="programlisting">
<strong class="calibre2">&gt; image(as.matrix(dist(customer)))</strong>
</pre></div><div><img src="img/00196.jpeg" alt="There's more..." class="calibre9"/><div><p class="calibre12">A distance matrix plot of customer dataset</p></div></div><p class="calibre10">为了绘制树状图和热图来显示数据是如何聚集的，您可以使用<a id="id799" class="calibre1"/>函数<code class="email">heatmap</code>:</p><p class="calibre7">列和行侧都有树状图的热图</p><div><pre class="programlisting">
<strong class="calibre2">&gt; cd=dist(customer)</strong>
<strong class="calibre2">&gt; hc=hclust(cd)</strong>
<strong class="calibre2">&gt; cdt=dist(t(customer))</strong>
<strong class="calibre2">&gt; hcc=hclust(cdt)</strong>
<strong class="calibre2">&gt; heatmap(customer, Rowv=as.dendrogram(hc), Colv=as.dendrogram(hcc))</strong>
</pre></div><div><img src="img/00197.jpeg" alt="There's more..." class="calibre9"/><div><p class="calibre12">A heat map with dendrogram on the column and row side</p></div></div><p class="calibre10"><a id="ch09lvl1sec111" class="calibre1"/>从外部验证集群</p></div></div></body></html>


<html>
  <head>
    <title>Validating clusters externally</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div/><div><div><div><div><h1 class="title" id="calibre_pb_0">除了生成统计数据来验证生成的聚类的质量之外，您还可以使用已知的数据聚类作为基础事实来比较不同的聚类方法。在这份食谱中，我们<a id="id800" class="calibre1"/>将展示聚类方法对于具有已知聚类的数据有何不同。</h1></div></div></div><p class="calibre7"><a id="ch09lvl2sec385" class="calibre1"/>准备就绪</p></div></body></html>


<html>
  <head>
    <title>Validating clusters externally</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_1">在这个菜谱中，我们将继续使用手写数字作为聚类输入；你可以在作者的Github页面上找到图:<a class="calibre1" href="https://github.com/ywchiu/ml_R_cookbook/tree/master/CH9">https://github.com/ywchiu/ml_R_cookbook/tree/master/CH9</a>。</h2></div></div></div><p class="calibre7"><a id="ch09lvl2sec386" class="calibre1"/>怎么做...</p></div></div></body></html>


<html>
  <head>
    <title>Validating clusters externally</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_2">执行以下步骤，使用不同的聚类技术对数字进行聚类:</h2></div></div></div><p class="calibre7">首先，你需要安装并加载软件包<code class="email">png</code> : <div> <pre class="programlisting"> <strong class="calibre2">&gt; install.packages("png")</strong> <strong class="calibre2">&gt; library(png)</strong> </pre> </div></p><div><ol class="orderedlist"><li class="listitem" value="1">手写数字的散点图</li><li class="listitem" value="2">Then, please <a id="id801" class="calibre1"/>read images from <code class="email">handwriting.png</code> and transform the read data into a scatter plot:<div><pre class="programlisting">
<strong class="calibre2">&gt; img2 = readPNG("handwriting.png", TRUE)</strong>
<strong class="calibre2">&gt; img3 = img2[,nrow(img2):1]</strong>
<strong class="calibre2">&gt; b = cbind(as.integer(which(img3 &lt; -1) %% 28), which(img3 &lt; -1) / 28)</strong>
<strong class="calibre2">&gt; plot(b, xlim=c(1,28), ylim=c(1,28))</strong>
</pre></div><div><img src="img/00198.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12">A scatter plot of handwriting digits</p></div></div><p class="calibre13">手写数字的k-means聚类结果</p></li><li class="listitem" value="3">Perform a k-means clustering method on the handwriting digits:<div><pre class="programlisting">
<strong class="calibre2">&gt; set.seed(18)</strong>
<strong class="calibre2">&gt; fit = kmeans(b, 2)</strong>
<strong class="calibre2">&gt; plot(b, col=fit$cluster)</strong>
<strong class="calibre2">&gt; plot(b, col=fit$cluster,  xlim=c(1,28), ylim=c(1,28))</strong>
</pre></div><div><img src="img/00199.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12">k-means clustering result on handwriting digits</p></div></div><p class="calibre13">接下来，对手写数字执行<code class="email">dbscan</code>聚类<a id="id802" class="calibre1"/>方法:<div> <pre class="programlisting"> <strong class="calibre2">&gt; ds = dbscan(b, 2)</strong> <strong class="calibre2">&gt; ds</strong> <strong class="calibre2">dbscan Pts=212 MinPts=5 eps=2</strong> <strong class="calibre2">       1   2</strong> <strong class="calibre2">seed  75 137</strong> <strong class="calibre2">total 75 137</strong> <strong class="calibre2">&gt; plot(ds, b,  xlim=c(1,28), ylim=c(1,28))</strong> </pre> </div></p></li><li class="listitem" value="4">手写数字的DBSCAN聚类结果</li></ol><div/></div><div><img src="img/00200.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12">DBSCAN clustering result on handwriting digits</p></div></div><p class="calibre10"><a id="ch09lvl2sec387" class="calibre1"/>工作原理...</p></div></div></body></html>


<html>
  <head>
    <title>Validating clusters externally</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_3">在这个食谱中，我们演示了不同的聚类方法如何对手写数据集起作用。聚类的目的是将1和7分成不同的聚类。我们<a id="id803" class="calibre1"/>使用不同的技术来观察k-means和DBSCAN方法是如何对数据进行聚类的。</h2></div></div></div><p class="calibre7">为了生成数据，我们使用Windows应用程序<code class="email">paint.exe</code>创建一个尺寸为28 x 28像素的PNG文件。然后，我们使用<code class="email">readPNG</code>函数读取PNG数据，并将读取的PNG数据点转换成散点图，散点图显示17中的手写数字。</p><p class="calibre7">读取数据后，我们对手写数字执行聚类技术。首先，我们执行k-means聚类，其中<code class="email">k=2</code>在数据集上。由于k-均值聚类使用距离度量，因此构建的聚类覆盖了1位和7位数字的区域。然后，我们对数据集执行DBSCAN。由于DBSCAN是一种基于密度的聚类技术，它成功地将数字1和数字7分成不同的聚类。</p><p class="calibre7"><a id="ch09lvl2sec388" class="calibre1"/>参见</p></div></div></body></html>


<html>
  <head>
    <title>Validating clusters externally</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_4">如果你对如何阅读R中的各种图形格式感兴趣，可以参考下面的文档:<div> <pre class="programlisting"> <strong class="calibre2">&gt; help(package="png")</strong> </pre> </div></h2></div></div></div><div><ul class="itemizedlist"><li class="listitem"><a id="ch10" class="calibre1"/>第十章。关联分析和序列挖掘</li></ul></div></div></div></body></html>


<html>
  <head>
    <title>Chapter 10. Association Analysis and Sequence Mining</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div/><div><div><div><div><h1 class="title" id="calibre_pb_0">在本章中，我们将讨论以下主题:</h1></div></div></div><p class="calibre7">将数据转换为事务</p><div><ul class="itemizedlist"><li class="listitem">显示交易和关联</li><li class="listitem">利用先验规则挖掘关联</li><li class="listitem">删除多余的规则</li><li class="listitem">可视化关联规则</li><li class="listitem">用Eclat挖掘频繁项集</li><li class="listitem">使用时态信息创建事务</li><li class="listitem">用cSPADE挖掘频繁序列模式</li><li class="listitem"><a id="ch10lvl1sec112" class="calibre1"/>简介</li></ul></div></div></body></html>


<html>
  <head>
    <title>Chapter 10. Association Analysis and Sequence Mining</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h1 class="title" id="calibre_pb_1">企业在日常运营中积累了大量的交易数据(例如，零售商的销售订单、发票和货运单据)。在数据中寻找隐藏的关系可能很有用，例如，“什么产品经常一起购买？”或者“买手机之后的后续购买有哪些？”为了回答这两个问题，我们需要对事务数据集执行关联分析和频繁序列模式挖掘。</h1></div></div></div><p class="calibre7">关联分析<a id="id804" class="calibre1"/>是一种在交易数据集中发现有趣关系的方法。产品之间的一个著名关联是<em class="calibre8">买尿布的顾客也买啤酒</em>。虽然这种关联听起来可能不寻常，但如果零售商能够利用这种信息或规则向他们的客户交叉销售产品，他们就很有可能增加销售额。</p><p class="calibre7">关联分析是用来找出<strong class="calibre2">项集</strong>之间的关联关系，但是如果你想找出<a id="id805" class="calibre1"/>项被频繁购买的顺序呢？为此，您可以采用<a id="id806" class="calibre1"/>频繁序列模式挖掘从具有时态信息的事务数据集中发现频繁子序列。然后，您可以使用挖掘出的频繁子序列来预测客户购物序列订单、web点击流、生物序列以及在其他应用程序中的使用。</p><p class="calibre7">在本章中，我们将介绍创建和检查事务数据集的方法，使用Apriori算法执行关联分析，以各种图形格式可视化关联，以及使用Eclat算法查找频繁项集。最后，我们将使用时态信息创建事务，并使用cSPADE算法来发现频繁的序列模式。</p><p class="calibre7"><a id="ch10lvl1sec113" class="calibre1"/>将数据转换成交易</p></div></div></body></html>


<html>
  <head>
    <title>Transforming data into transactions</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div/><div><div><div><div><h1 class="title" id="calibre_pb_0">在<a id="id807" class="calibre1"/>创建挖掘关联规则之前，您需要<a id="id808" class="calibre1"/>将数据转换成事务。在下面的菜谱中，我们将介绍如何将列表、矩阵或数据框转换成事务。</h1></div></div></div><p class="calibre7">准备就绪</p></div></body></html>


<html>
  <head>
    <title>Transforming data into transactions</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_1">在这个方法中，我们将在列表、矩阵或数据框中生成三个不同的数据集。然后，我们可以将生成的数据集转换成事务。</h2></div></div></div><p class="calibre7"><a id="ch10lvl2sec390" class="calibre1"/>怎么做...</p></div></div></body></html>


<html>
  <head>
    <title>Transforming data into transactions</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_2">执行以下步骤将不同格式的数据转换为事务:</h2></div></div></div><p class="calibre7">首先，你必须安装并加载软件包<code class="email">arule</code> : <div> <pre class="programlisting"> <strong class="calibre2">&gt; install.packages("arules")</strong> <strong class="calibre2">&gt; library(arules)</strong> </pre> </div></p><div><ol class="orderedlist"><li class="listitem" value="1">然后你可以用三个包含购买记录的向量做一个列表:<div> <pre class="programlisting"> <strong class="calibre2">&gt; tr_list = list(c("Apple", "Bread", "Cake"),</strong> <strong class="calibre2">+                c("Apple", "Bread", "Milk"),</strong> <strong class="calibre2">+                c("Bread", "Cake", "Milk"))</strong> <strong class="calibre2">&gt; names(tr_list) = paste("Tr",c(1:3), sep = "")</strong> </pre> </div></li><li class="listitem" value="2">接下来，您可以使用<code class="email">as</code>函数将数据帧转换为事务:<div> <pre class="programlisting"> <strong class="calibre2">&gt; trans = as(tr_list, "transactions")</strong> <strong class="calibre2">&gt; trans</strong> <strong class="calibre2">transactions in sparse format with</strong> <strong class="calibre2"> 3 transactions (rows) and</strong> <strong class="calibre2"> 4 items (columns)</strong> </pre> </div></li><li class="listitem" value="3">你<a id="id809" class="calibre1"/>也可以将矩阵<a id="id810" class="calibre1"/>格式的数据转换成事务:<div> <pre class="programlisting"> <strong class="calibre2">&gt; tr_matrix = matrix(</strong> <strong class="calibre2">+   c(1,1,1,0,</strong> <strong class="calibre2">+     1,1,0,1,</strong> <strong class="calibre2">+     0,1,1,1), ncol = 4)</strong> <strong class="calibre2">&gt; dimnames(tr_matrix) =  list(</strong> <strong class="calibre2">+   paste("Tr",c(1:3), sep = ""),</strong> <strong class="calibre2">+   c("Apple","Bread","Cake", "Milk")</strong> <strong class="calibre2">+   )</strong> <strong class="calibre2">&gt; trans2 =  as(tr_matrix, "transactions")</strong> <strong class="calibre2">&gt; trans2</strong> <strong class="calibre2">transactions in sparse format with</strong> <strong class="calibre2"> 3 transactions (rows) and</strong> <strong class="calibre2"> 4 items (columns)</strong> </pre> </div></li><li class="listitem" value="4">最后，您可以将数据框格式的数据集转换为事务:<div> <pre class="programlisting"> <strong class="calibre2">&gt; Tr_df = data.frame(</strong> <strong class="calibre2">+   TrID= as.factor(c(1,2,1,1,2,3,2,3,2,3)),</strong> <strong class="calibre2">+   Item = as.factor(c("Apple","Milk","Cake","Bread",</strong> <strong class="calibre2">+                      "Cake","Milk","Apple","Cake",</strong> <strong class="calibre2">+                      "Bread","Bread"))  </strong> <strong class="calibre2">+ )</strong> <strong class="calibre2">&gt; trans3 = as(split(Tr_df[,"Item"], Tr_df[,"TrID"]), "transactions")</strong> <strong class="calibre2">&gt; trans3</strong> <strong class="calibre2">transactions in sparse format with</strong> <strong class="calibre2"> 3 transactions (rows) and</strong> <strong class="calibre2"> 4 items (columns)</strong> </pre> </div></li><li class="listitem" value="5"><a id="ch10lvl2sec391" class="calibre1"/>工作原理...</li></ol><div/></div></div></div></body></html>


<html>
  <head>
    <title>Transforming data into transactions</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_3">在挖掘频繁项集或使用关联规则之前，按事务类准备数据集是很重要的。在这个菜谱中，我们演示了如何将数据集从列表、矩阵和数据框格式转换为事务。在第一步中，我们以包含三个购买记录向量的列表格式生成数据集。然后，在我们为每个事务分配了一个事务ID之后，我们使用<code class="email">as</code>函数将数据转换成事务。</h2></div></div></div><p class="calibre7">接下来，我们<a id="id811" class="calibre1"/>演示如何将数据从<a id="id812" class="calibre1"/>矩阵格式转换成事务。为了表示物品是如何被购买的，人们应该使用二元关联矩阵来记录每笔交易中不同物品的购买行为。同样，我们可以使用一个<code class="email">as</code>函数将数据集从矩阵格式转换成事务。</p><p class="calibre7">最后，我们演示了如何将数据集从数据帧格式转换为事务。数据帧包含两个因子类型向量:一个是名为<code class="email">TrID</code>的交易ID，另一个显示与不同交易相关的购买项目(名为<code class="email">Item</code>)。此外，可以使用<code class="email">as</code>函数将数据帧格式的数据转换成事务。</p><p class="calibre7"><a id="ch10lvl2sec392" class="calibre1"/>参见</p></div></div></body></html>


<html>
  <head>
    <title>Transforming data into transactions</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><code class="email">transactions</code>类用于表示规则或频繁模式挖掘的事务数据。它是<code class="email">itemMatrix</code>类的扩展。如果您对如何使用这两个不同的类来表示交易数据感兴趣，请使用<code class="email">help</code>函数来参考以下文档:<div> <pre class="programlisting"> <strong class="calibre2">&gt; help(transactions)</strong> <strong class="calibre2">&gt; help(itemMatrix)</strong> </pre> </div></h2></div></div></div><div><ul class="itemizedlist"><li class="listitem"><a id="ch10lvl1sec114" class="calibre1"/>显示交易和关联</li></ul></div></div></div></body></html>


<html>
  <head>
    <title>Displaying transactions and associations</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div/><div><div><div><div><h1 class="title" id="calibre_pb_0"><code class="email">arule</code>包使用自己的<code class="email">transactions</code>类来存储事务数据。因此，我们必须<a id="id813" class="calibre1"/>使用<code class="email">arule</code>提供的通用函数来显示事务<a id="id814" class="calibre1"/>和关联规则。在这个菜谱中，我们将说明如何通过<code class="email">arule</code>包中的各种函数显示事务和关联规则。</h1></div></div></div><p class="calibre7">准备就绪</p></div></body></html>


<html>
  <head>
    <title>Displaying transactions and associations</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_1">通过生成交易并将其存储在变量<code class="email">trans</code>中，确保您已经完成了之前的配方。</h2></div></div></div><p class="calibre7">如何做到这一点...</p></div></div></body></html>


<html>
  <head>
    <title>Displaying transactions and associations</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_2">执行<a id="id815" class="calibre1"/>以下步骤来显示交易和关联:</h2></div></div></div><p class="calibre7">首先，您<a id="id816" class="calibre1"/>可以获得交易数据的列表表示:<div> <pre class="programlisting"> <strong class="calibre2">&gt; LIST(trans)</strong> <strong class="calibre2">$Tr1</strong> <strong class="calibre2">[1] "Apple" "Bread" "Cake" </strong>  <strong class="calibre2">$Tr2</strong> <strong class="calibre2">[1] "Apple" "Bread" "Milk" </strong>  <strong class="calibre2">$Tr3</strong> <strong class="calibre2">[1] "Bread" "Cake"  "Milk"</strong> </pre> </div></p><div><ol class="orderedlist"><li class="listitem" value="1">接下来，您可以使用<code class="email">summary</code>功能显示交易的统计汇总和详细信息:<div> <pre class="programlisting"> <strong class="calibre2">&gt; summary(trans)</strong> <strong class="calibre2">transactions as itemMatrix in sparse format with</strong> <strong class="calibre2"> 3 rows (elements/itemsets/transactions) and</strong> <strong class="calibre2"> 4 columns (items) and a density of 0.75 </strong>  <strong class="calibre2">most frequent items:</strong> <strong class="calibre2">  Bread   Apple    Cake    Milk (Other) </strong> <strong class="calibre2">      3       2       2       2       0 </strong>  <strong class="calibre2">element (itemset/transaction) length distribution:</strong> <strong class="calibre2">sizes</strong> <strong class="calibre2">3 </strong> <strong class="calibre2">3 </strong>  <strong class="calibre2">   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. </strong> <strong class="calibre2">      3       3       3       3       3       3 </strong>  <strong class="calibre2">includes extended item information - examples:</strong> <strong class="calibre2">  labels</strong> <strong class="calibre2">1  Apple</strong> <strong class="calibre2">2  Bread</strong> <strong class="calibre2">3   Cake</strong>  <strong class="calibre2">includes extended transaction information - examples:</strong> <strong class="calibre2">  transactionID</strong> <strong class="calibre2">1           Tr1</strong> <strong class="calibre2">2           Tr2</strong> <strong class="calibre2">3           Tr3</strong> </pre> </div></li><li class="listitem" value="2">您<a id="id817" class="calibre1"/>可以<a id="id818" class="calibre1"/>使用<code class="email">inspect</code>函数显示交易:<div> <pre class="programlisting"> <strong class="calibre2">&gt; inspect(trans)</strong> <strong class="calibre2">  items   transactionID</strong> <strong class="calibre2">1 {Apple,              </strong> <strong class="calibre2">   Bread,              </strong> <strong class="calibre2">   Cake}            Tr1</strong> <strong class="calibre2">2 {Apple,              </strong> <strong class="calibre2">   Bread,              </strong> <strong class="calibre2">   Milk}            Tr2</strong> <strong class="calibre2">3 {Bread,              </strong> <strong class="calibre2">   Cake,               </strong> <strong class="calibre2">   Milk}            Tr3</strong> </pre> </div></li><li class="listitem" value="3">除此之外，您还可以按大小过滤交易:<div> <pre class="programlisting"> <strong class="calibre2">&gt; filter_trains = trans[size(trans) &gt;=3]</strong> <strong class="calibre2">&gt; inspect(filter_trains)</strong> <strong class="calibre2">  items   transactionID</strong> <strong class="calibre2">1 {Apple,              </strong> <strong class="calibre2">   Bread,              </strong> <strong class="calibre2">   Cake}            Tr1</strong> <strong class="calibre2">2 {Apple,              </strong> <strong class="calibre2">   Bread,              </strong> <strong class="calibre2">   Milk}            Tr2</strong> <strong class="calibre2">3 {Bread,              </strong> <strong class="calibre2">   Cake,               </strong> <strong class="calibre2">   Milk}            Tr3</strong> </pre> </div></li><li class="listitem" value="4">交易的目视检查</li><li class="listitem" value="5">Also, you can use the image function to visually inspect the transactions:<div><pre class="programlisting">
<strong class="calibre2">&gt; image(trans)</strong>
</pre></div><div><img src="img/00201.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12">Visual inspection of transactions</p></div></div><p class="calibre13">交易记录的项目频率条形图</p></li><li class="listitem" value="6">To visually<a id="id819" class="calibre1"/> show the frequency/support bar plot, one <a id="id820" class="calibre1"/>can use <code class="email">itemFrequenctPlot</code>:<div><pre class="programlisting">
<strong class="calibre2">&gt; itemFrequencyPlot (trans)</strong>
</pre></div><div><img src="img/00202.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12">Item frequency bar plot of transactions</p></div></div><p class="calibre13"><a id="ch10lvl2sec395" class="calibre1"/>工作原理...</p></li></ol><div/></div></div></div></body></html>


<html>
  <head>
    <title>Displaying transactions and associations</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_3">由于<a id="id821" class="calibre1"/>事务数据是挖掘关联<a id="id822" class="calibre1"/>和频繁模式的基础，我们必须学习如何显示关联以获得洞察力并确定如何建立关联。<code class="email">arules</code>包提供了各种检查事务的方法。首先，我们使用<code class="email">LIST</code>函数获得事务数据的列表表示。然后，我们可以使用<code class="email">summary</code>函数来获取信息，比如基本描述、最常见的项目和事务长度分布。</h2></div></div></div><p class="calibre7">接下来，我们使用<code class="email">inspect</code>函数来显示交易。除了显示所有交易之外，用户还可以首先按大小过滤交易，然后使用<code class="email">inspect</code>功能显示关联。此外，我们可以使用<code class="email">image</code>功能直观地检查交易。最后，我们说明如何使用频率/支持条图来显示每个项目的相对项目频率。</p><p class="calibre7"><a id="ch10lvl2sec396" class="calibre1"/>参见</p></div></div></body></html>


<html>
  <head>
    <title>Displaying transactions and associations</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_4">除了使用<code class="email">itemFrequencyPlot</code>来显示频率/条形图，您还可以使用<code class="email">itemFrequency</code>功能来显示支持分布。更多详情，请使用<code class="email">help</code>功能查看以下文档:<div> <pre class="programlisting"> <strong class="calibre2">&gt; help(itemFrequency)</strong> </pre> </div></h2></div></div></div><div><ul class="itemizedlist"><li class="listitem"><a id="ch10lvl1sec115" class="calibre1"/>利用先验规则挖掘关联</li></ul></div></div></div></body></html>


<html>
  <head>
    <title>Mining associations with the Apriori rule</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div/><div><div><div><div><h1 class="title" id="calibre_pb_0">关联挖掘是一种能够发现隐藏在事务数据集中的有趣关系的技术。该方法首先发现所有频繁项集，然后从频繁项集生成强关联规则。Apriori是最著名的关联挖掘<a id="id823" class="calibre1"/>算法，它首先识别频繁<a id="id824" class="calibre1"/>单个项目，然后执行广度优先搜索策略，将单个项目扩展到更大的项目集，直到无法找到更大的频繁项目集。在这个菜谱中，我们将介绍如何使用Apriori规则执行关联分析。</h1></div></div></div><p class="calibre7">准备就绪</p></div></body></html>


<html>
  <head>
    <title>Mining associations with the Apriori rule</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_1">在这个菜谱中，我们将使用内置的事务数据集<code class="email">Groceries</code>，来演示如何使用<code class="email">arules</code>包中的Apriori算法执行关联分析。请确保首先安装并加载了<code class="email">arules</code>包。</h2></div></div></div><p class="calibre7"><a id="ch10lvl2sec398" class="calibre1"/>怎么做...</p></div></div></body></html>


<html>
  <head>
    <title>Mining associations with the Apriori rule</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_2">执行<a id="id825" class="calibre1"/>以下步骤分析关联<a id="id826" class="calibre1"/>规则:</h2></div></div></div><p class="calibre7">首先，你需要加载数据集<code class="email">Groceries</code> : <div> <pre class="programlisting"> <strong class="calibre2">&gt; data(Groceries)</strong> </pre> </div></p><div><ol class="orderedlist"><li class="listitem" value="1">然后您可以检查<code class="email">Groceries</code>数据集的摘要:<div> <pre class="programlisting"> <strong class="calibre2">&gt; summary(Groceries)</strong> </pre> </div></li><li class="listitem" value="2">杂货交易的前五项频率条形图</li><li class="listitem" value="3">Next, you can use <code class="email">itemFrequencyPlot</code> to examine the relative item frequency of itemsets:<div><pre class="programlisting">
<strong class="calibre2">&gt; itemFrequencyPlot(Groceries, support = 0.1, cex.names=0.8, topN=5)</strong>
</pre></div><div><img src="img/00203.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12">使用<code class="email">apriori</code>发现支持度超过0.001、置信度超过0.5的规则:<div> <pre class="programlisting"> <strong class="calibre2">&gt; rules = apriori(Groceries, parameter = list(supp = 0.001, conf = 0.5, target= "rules"))</strong> <strong class="calibre2">&gt; summary(rules)</strong> <strong class="calibre2">set of 5668 rules</strong>  <strong class="calibre2">rule length distribution (lhs + rhs):sizes</strong> <strong class="calibre2">   2    3    4    5    6 </strong> <strong class="calibre2">  11 1461 3211  939   46 </strong>  <strong class="calibre2">   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. </strong> <strong class="calibre2">   2.00    3.00    4.00    3.92    4.00    6.00 </strong>  <strong class="calibre2">summary of quality measures:</strong> <strong class="calibre2">    support           confidence          lift       </strong> <strong class="calibre2"> Min.   :0.001017   Min.   :0.5000   Min.   : 1.957  </strong> <strong class="calibre2"> 1st Qu.:0.001118   1st Qu.:0.5455   1st Qu.: 2.464  </strong> <strong class="calibre2"> Median :0.001322   Median :0.6000   Median : 2.899  </strong> <strong class="calibre2"> Mean   :0.001668   Mean   :0.6250   Mean   : 3.262  </strong> <strong class="calibre2"> 3rd Qu.:0.001729   3rd Qu.:0.6842   3rd Qu.: 3.691  </strong> <strong class="calibre2"> Max.   :0.022267   Max.   :1.0000   Max.   :18.996  </strong>  <strong class="calibre2">mining info:</strong> <strong class="calibre2">      data ntransactions support confidence</strong> <strong class="calibre2"> Groceries          9835   0.001        0.5</strong> </pre> </div></p></div></div><p class="calibre13">我们<a id="id827" class="calibre1"/>可以接着考察前几个<a id="id828" class="calibre1"/>规则:<div> <pre class="programlisting"> <strong class="calibre2">&gt; inspect(head(rules))</strong> <strong class="calibre2">  lhs                    rhs              support confidence     lift</strong> <strong class="calibre2">1 {honey}             =&gt; {whole milk} 0.001118454  0.7333333 2.870009</strong> <strong class="calibre2">2 {tidbits}           =&gt; {rolls/buns} 0.001220132  0.5217391 2.836542</strong> <strong class="calibre2">3 {cocoa drinks}      =&gt; {whole milk} 0.001321810  0.5909091 2.312611</strong> <strong class="calibre2">4 {pudding powder}    =&gt; {whole milk} 0.001321810  0.5652174 2.212062</strong> <strong class="calibre2">5 {cooking chocolate} =&gt; {whole milk} 0.001321810  0.5200000 2.035097</strong> <strong class="calibre2">6 {cereals}           =&gt; {whole milk} 0.003660397  0.6428571 2.515917</strong> </pre> </div></p></li><li class="listitem" value="4">可以按置信度排序规则，考察前几条规则:<div> <pre class="programlisting"> <strong class="calibre2">&gt; rules=sort(rules, by="confidence", decreasing=TRUE)</strong> <strong class="calibre2">&gt; inspect(head(rules))</strong> <strong class="calibre2">  lhs                     rhs                    support confidence     lift</strong> <strong class="calibre2">1 {rice,                                                                    </strong> <strong class="calibre2">   sugar}              =&gt; {whole milk}       0.001220132          1 3.913649</strong> <strong class="calibre2">2 {canned fish,                                                             </strong> <strong class="calibre2">   hygiene articles}   =&gt; {whole milk}       0.001118454          1 3.913649</strong> <strong class="calibre2">3 {root vegetables,                                                         </strong> <strong class="calibre2">   butter,                                                                  </strong> <strong class="calibre2">   rice}               =&gt; {whole milk}       0.001016777          1 3.913649</strong> <strong class="calibre2">4 {root vegetables,                                                         </strong> <strong class="calibre2">   whipped/sour cream,                                                      </strong> <strong class="calibre2">   flour}              =&gt; {whole milk}       0.001728521          1 3.913649</strong> <strong class="calibre2">5 {butter,                                                                  </strong> <strong class="calibre2">   soft cheese,                                                             </strong> <strong class="calibre2">   domestic eggs}      =&gt; {whole milk}       0.001016777          1 3.913649</strong> <strong class="calibre2">6 {citrus fruit,                                                            </strong> <strong class="calibre2">   root vegetables,                                                         </strong> <strong class="calibre2">   soft cheese}        =&gt; {other vegetables} 0.001016777          1 5.168156</strong> </pre> </div></li><li class="listitem" value="5"><a id="ch10lvl2sec399" class="calibre1"/>工作原理...</li><li class="listitem" value="6">关联挖掘的目的是从交易数据库中发现项目之间的<a id="id830" class="calibre1"/>关联。通常，关联挖掘过程通过查找支持度大于最小支持度的项集来进行。接下来，该过程使用频繁项目集来生成强规则(例如，<code class="email">milk =&gt; bread</code>；购买牛奶的顾客可能购买面包)的置信度大于最小置信度。根据定义，关联规则可以用<em class="calibre8"> X= &gt; Y </em>的形式表示，其中X和Y是不相连的项目集。我们可以衡量两个术语之间的关联强度:支持和信心。支持度表示在数据集中有多少百分比的规则适用，而置信度表示X和Y出现在同一事务中的概率:</li></ol><div/></div></div></div></body></html>


<html>
  <head>
    <title>Mining associations with the Apriori rule</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_3">支持= <img src="img/00204.jpeg" alt="How it works..." class="calibre24"/></h2></div></div></div><p class="calibre7">置信度= <img src="img/00205.jpeg" alt="How it works..." class="calibre24"/></p><div><ul class="itemizedlist"><li class="listitem">这里，<img src="img/00206.jpeg" alt="How it works..." class="calibre24"/>指的是特定项集的出现频率；N表示人口数量。</li><li class="listitem">由于<a id="id831" class="calibre1"/>支持度和置信度只是<a id="id832" class="calibre1"/>强度规则的度量，您可能仍然会获得许多具有高支持度和置信度的冗余规则。因此，我们可以使用第三个衡量标准lift来评估规则的质量(排名)。根据定义，提升表示对X和Y的随机共现的规则的强度，因此我们可以用下面的形式来表示提升:</li></ul></div><p class="calibre7">Lift = <img src="img/00207.jpeg" alt="How it works..." class="calibre24"/></p><p class="calibre7">Apriori是最著名的关联挖掘算法，它执行一种逐层、广度优先的算法来计算候选项集。Apriori过程从逐层查找频繁项集(一组具有最小支持度的项)开始。例如，该过程从查找频繁1-项集开始。然后，通过使用频繁1项集来寻找频繁2项集，该过程继续。该过程迭代地从频繁k项集发现新的频繁k+1项集，直到没有发现频繁项集。</p><p class="calibre7">最后，该过程利用频繁项目集来生成关联规则:</p><p class="calibre7">Apriori算法的示例(支持度= 2)</p><p class="calibre7">在这个菜谱中，我们使用Apriori算法来查找事务中的关联规则。我们使用内置的<code class="email">Groceries</code>数据集，它包含一个典型杂货店一个月的真实销售点交易数据。然后，我们使用<code class="email">summary</code>函数获得<code class="email">Groceries</code>数据集的<a id="id833" class="calibre1"/>汇总统计数据。汇总统计显示，数据集包含9，835个事务，这些事务被分为169个类别。除此之外，摘要还显示了一些信息，如数据集中最常见的项、项集分布和示例扩展项信息。然后，我们可以使用<code class="email">itemFrequencyPlot</code>来可视化支持度超过0.1的五个最常见的项目。</p><div><img src="img/00208.jpeg" alt="How it works..." class="calibre9"/><div><p class="calibre12">接下来，我们应用Apriori算法来搜索支持度超过0.001且置信度超过0.5的规则。然后我们使用<code class="email">summary</code>函数来检查生成的规则的详细信息。从输出摘要中，我们发现Apriori算法生成5668条规则，支持度超过0.001，置信度超过0.5。此外，我们可以找到规则长度分布、质量度量的汇总以及挖掘信息。在质量测量的总结中，我们发现了三个测量的描述性统计，即支持、信心和提升。支持度是包含某个项目集的事务的比例。置信度是规则的正确率。Lift是响应目标关联规则除以平均响应。</p></div></div><p class="calibre10">为了探究一些生成的规则，我们可以使用<code class="email">inspect</code>函数来查看5668个生成规则中的前六个规则。最后，我们可以根据可信度对规则进行排序，并列出可信度最高的规则。因此，我们发现与<code class="email">whole milk</code>关联的<code class="email">rich sugar</code>是最有信心的规则，支持度等于0.001220132，置信度等于1，提升度等于3.913649。</p><p class="calibre7"><a id="ch10lvl2sec400" class="calibre1"/>参见</p><p class="calibre7">对于那些对使用<a id="id836" class="calibre1"/>数据集的研究结果以及如何定义支持度、置信度和提升度量感兴趣的<a id="id835" class="calibre1"/>，您可以参考以下论文:</p><p class="calibre7">迈克尔·哈斯勒、库尔特·霍尼克和托马斯·罗伊特勒(2006) <em class="calibre8">概率数据建模对挖掘关联规则的影响</em>。<em class="calibre8">在M. Spiliopoulou，R. Kruse </em>，<em class="calibre8"> C. Borgelt </em>，<em class="calibre8"> A </em></p></div></div></body></html>


<html>
  <head>
    <title>Mining associations with the Apriori rule</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_4">Nuernberger和W. Gaul，编辑，<em class="calibre8">从数据和信息分析到知识工程，分类研究</em>，<em class="calibre8">数据分析和知识组织</em>，<em class="calibre8">第598–605页</em>。施普林格出版社</h2></div></div></div><p class="calibre7">此外，除了使用<code class="email">summary</code>和<code class="email">inspect</code>函数来检查关联规则，您还可以使用<code class="email">interestMeasure</code>来获得额外的兴趣度量:</p><div><ul class="itemizedlist"><li class="listitem"><a id="ch10lvl1sec116" class="calibre1"/>修剪冗余规则</li><li class="listitem">在生成的规则中，我们有时会发现重复或冗余的规则(例如，一个规则是<a id="id837" class="calibre1"/>另一个规则的超级规则或子集)。在这个食谱中，我们将向你展示如何删除重复或多余的规则。</li></ul></div><p class="calibre7">准备就绪</p><div><pre class="programlisting">
<strong class="calibre2">&gt; head(interestMeasure(rules, c("support", "chiSquare", "confidence", "conviction","cosine", "coverage", "leverage", "lift","oddsRatio"), Groceries))</strong>
</pre></div></div></div></body></html>


<html>
  <head>
    <title>Pruning redundant rules</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div/><div><div><div><div><h1 class="title" id="calibre_pb_0">在这个配方中，您必须通过生成规则来完成前面的配方，并将其存储在变量<code class="email">rules</code>中。</h1></div></div></div><p class="calibre7"><a id="ch10lvl2sec402" class="calibre1"/>怎么做...</p></div></body></html>


<html>
  <head>
    <title>Pruning redundant rules</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_1">执行以下步骤来删除多余的规则:</h2></div></div></div><p class="calibre7">首先，按照以下步骤查找冗余规则:<div> <pre class="programlisting"> <strong class="calibre2">&gt; rules.sorted = sort(rules, by="lift")</strong> <strong class="calibre2">&gt; subset.matrix = is.subset(rules.sorted, rules.sorted)</strong> <strong class="calibre2">&gt; subset.matrix[lower.tri(subset.matrix, diag=T)] = NA</strong> <strong class="calibre2">&gt; redundant = colSums(subset.matrix, na.rm=T) &gt;= 1</strong> </pre> </div></p></div></div></body></html>


<html>
  <head>
    <title>Pruning redundant rules</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_2">然后可以删除多余的规则:<div> <pre class="programlisting"> <strong class="calibre2">&gt; rules.pruned = rules.sorted[!redundant]</strong> <strong class="calibre2">&gt; inspect(head(rules.pruned))</strong> <strong class="calibre2">  lhs                        rhs                  support confidence     lift</strong> <strong class="calibre2">1 {Instant food products,                                                    </strong> <strong class="calibre2">   soda}                  =&gt; {hamburger meat} 0.001220132  0.6315789 18.99565</strong> <strong class="calibre2">2 {soda,                                                                     </strong> <strong class="calibre2">   popcorn}               =&gt; {salty snack}    0.001220132  0.6315789 16.69779</strong> <strong class="calibre2">3 {flour,                                                                    </strong> <strong class="calibre2">   baking powder}         =&gt; {sugar}          0.001016777  0.5555556 16.40807</strong> <strong class="calibre2">4 {ham,                                                                      </strong> <strong class="calibre2">   processed cheese}      =&gt; {white bread}    0.001931876  0.6333333 15.04549</strong> <strong class="calibre2">5 {whole milk,                                                               </strong> <strong class="calibre2">   Instant food products} =&gt; {hamburger meat} 0.001525165  0.5000000 15.03823</strong> <strong class="calibre2">6 {other vegetables,                                                         </strong> <strong class="calibre2">   curd,                                                                     </strong> <strong class="calibre2">   yogurt,                                                                   </strong> <strong class="calibre2">   whipped/sour cream}    =&gt; {cream cheese }  0.001016777  0.5882353 14.83409</strong> </pre> </div></h2></div></div></div><p class="calibre7"><a id="ch10lvl2sec403" class="calibre1"/>工作原理...</p><div><ol class="orderedlist"><li class="listitem" value="1">关联挖掘的两个<a id="id838" class="calibre1"/>主要约束是在支持度和置信度之间进行选择。例如，如果使用高支持阈值，则可能会删除稀有项目规则，而不考虑这些规则是否具有高可信度值。另一方面，如果选择使用低支持度阈值，关联挖掘会产生大量冗余的关联规则，使得这些规则难以利用和分析。因此，我们需要删除冗余的规则，以便从这些生成的规则中发现有意义的信息。</li><li class="listitem" value="2">在这个食谱中，我们演示了如何删除多余的规则。首先，我们搜索冗余规则。我们通过提升度量对规则进行排序，然后使用<code class="email">is.subset</code>函数找到排序规则的子集，这将生成一个<code class="email">itemMatrix</code>对象。然后我们可以将矩阵的下三角设为NA。最后，我们计算生成矩阵的<code class="email">colSums</code>，其中<code class="email">colSums &gt;=1</code>表示特定规则是冗余的。</li></ol><div/></div></div></div></body></html>


<html>
  <head>
    <title>Pruning redundant rules</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_3">在我们发现冗余规则后，我们可以从排序规则中删除这些规则。最后，我们可以使用<code class="email">inspect</code>函数来检查删减后的规则。</h2></div></div></div><p class="calibre7"><a id="ch10lvl2sec404" class="calibre1"/>参见</p><p class="calibre7">为了找到规则的子集或超集，你可以在关联规则上使用<code class="email">is.superset</code>和<code class="email">is.subset</code>函数。这两个方法可以生成一个<code class="email">itemMatrix</code>对象来显示哪个规则是其他规则的超集或子集。更多信息可以参考<code class="email">help</code>函数:<div> <pre class="programlisting"> <strong class="calibre2">&gt; help(is.superset)</strong> <strong class="calibre2">&gt; help(is.subset)</strong> </pre> </div></p><p class="calibre7"><a id="ch10lvl1sec117" class="calibre1"/>可视化关联规则</p></div></div></body></html>


<html>
  <head>
    <title>Pruning redundant rules</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_4">除了以文本形式列出规则之外，您还可以可视化关联规则，从而更容易找到项目集之间的关系。在下面的菜谱中，我们将介绍如何使用<code class="email">aruleViz</code>包来可视化关联规则。</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">做好准备</li></ul></div></div></div></body></html>


<html>
  <head>
    <title>Visualizing association rules</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div/><div><div><div><div><h1 class="title" id="calibre_pb_0">在这个配方中，我们将继续使用<code class="email">Groceries</code>数据集。您需要通过生成修剪规则<code class="email">rules.pruned</code>来完成之前的配方。</h1></div></div></div><p class="calibre7"><a id="ch10lvl2sec406" class="calibre1"/>怎么做...</p></div></body></html>


<html>
  <head>
    <title>Visualizing association rules</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_1">执行以下步骤来可视化关联规则:</h2></div></div></div><p class="calibre7">首先，您需要安装并加载软件包<code class="email">arulesViz</code> : <div> <pre class="programlisting"> <strong class="calibre2">&gt; install.packages("arulesViz")</strong> <strong class="calibre2">&gt; library(arulesViz)</strong> </pre> </div></p></div></div></body></html>


<html>
  <head>
    <title>Visualizing association rules</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch10lvl2sec406" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre7">修剪关联规则的散点图</p><div><ol class="orderedlist"><li class="listitem" value="1">First, you need to install and load the package <code class="email">arulesViz</code>:<div><pre class="programlisting">
<strong class="calibre2">&gt; install.packages("arulesViz")</strong>
<strong class="calibre2">&gt; library(arulesViz)</strong>
</pre></div></li><li class="listitem" value="2">You can then make a scatter plot from the pruned rules:<div><pre class="programlisting">
<strong class="calibre2">&gt; plot(rules.pruned)</strong>
</pre></div><p class="calibre26"> </p><div><img src="img/00209.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12">带有抖动的修剪关联规则散点图</p></div></div><p class="calibre13"> </p><p class="calibre26">然后我们<a id="id842" class="calibre1"/>使用Apriori算法产生新的规则，左边是<code class="email">soda</code>:<div><pre class="programlisting"> <strong class="calibre2">&gt; soda_rule=apriori(data=Groceries, parameter=list(supp=0.001,conf = 0.1, minlen=2), appearance = list(default="rhs",lhs="soda"))</strong> </pre></div></p></li><li class="listitem" value="3">Additionally, to <a id="id841" class="calibre1"/>prevent overplotting, you can add jitter to the scatter plot:<div><pre class="programlisting">
<strong class="calibre2">&gt; plot(rules.pruned, shading="order", control=list(jitter=6))</strong>
</pre></div><div><img src="img/00210.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12">关联规则的图表</p></div></div><p class="calibre13"> </p></li><li class="listitem" value="4">关联规则气球图</li><li class="listitem" value="5">Next, you can plot <code class="email">soda_rule</code> in a graph plot:<div><pre class="programlisting">
<strong class="calibre2">&gt; plot(sort(soda_rule, by="lift"), method="graph", control=list(type="items"))</strong>
</pre></div><div><img src="img/00211.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12">Graph plot of association rules</p></div></div><p class="calibre13"><a id="ch10lvl2sec407" class="calibre1"/>工作原理...</p></li><li class="listitem" value="6">Also, the association rules can be visualized in a balloon plot:<div><pre class="programlisting">
<strong class="calibre2">&gt; plot(soda_rule, method="grouped")</strong>
</pre></div><div><img src="img/00212.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12">除了以文本形式呈现关联规则之外，还可以使用<code class="email">arulesViz</code>来可视化关联规则。<code class="email">arulesViz</code>是一个<code class="email">arules</code>扩展包，它提供了许多可视化<a id="id843" class="calibre1"/>技术来探索关联规则。要开始使用<code class="email">arulesViz</code>，首先安装并加载软件包<code class="email">arulesViz</code>。然后，我们使用前一个配方中生成的删减规则来绘制散点图。根据步骤2中的图，我们发现规则显示为散点图中的点，x轴表示支持度，y轴表示置信度。颜色的深浅显示了规则的解除；阴影越暗，电梯越高。接下来，为了防止过度绘制点，我们可以将抖动作为一个参数包含在控制列表中。步骤3的图中提供了添加抖动后的曲线。</p></div></div><p class="calibre13">除了在散点图中绘制规则外，<code class="email">arulesViz</code>还允许您在图形和分组矩阵中绘制规则。我们选择在左侧使用<code class="email">soda</code>生成新的规则，而不是在一个图上打印所有的规则。然后，我们使用lift对规则进行排序，并在步骤4的图中可视化规则。从图中可以看出，每个项集都表示在一个顶点上，它们之间的关系表示在一条边上。该图(步骤4)清楚地显示了具有在左手边的<code class="email">soda</code>到在右手边的<code class="email">whole milk</code>的规则具有最大的支持，因为节点的大小是最大的。此外，该规则显示左侧的<code class="email">soda</code>到右侧的<code class="email">bottled water</code>具有最大提升，因为圆圈中的颜色阴影最深。然后，我们可以使用左侧带有<code class="email">soda</code>的相同数据来生成分组矩阵，这是步骤5中的图所示的气球图，左侧规则作为列标签，右侧作为行标签。类似于步骤4中图中的graph plot，步骤5中图中气球的大小表示规则的支持度，气球的颜色表示规则的提升度。</p></li></ol><div/></div></div></div></body></html>


<html>
  <head>
    <title>Visualizing association rules</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch10lvl2sec408" class="calibre1"/>参见</h2></div></div></div><p class="calibre7">在这个<a id="id844" class="calibre1"/>配方中，我们介绍了三种可视化方法来绘制关联规则。但是，<code class="email">arulesViz</code>还提供了绘制平行坐标图、双层图、镶嵌图以及其他相关图表的功能。对于那些对这些情节如何运作感兴趣的人，你可以参考:m .哈斯勒和S. (2011)。<em class="calibre8">可视化关联规则:R扩展包arulesViz介绍。r项目模块</em>。</p><p class="calibre7">交互式散点图</p></div></div></body></html>


<html>
  <head>
    <title>Visualizing association rules</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch10lvl1sec118" class="calibre1"/>用Eclat挖掘频繁项集</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">除了Apriori算法，您还可以使用Eclat算法来生成频繁项集。由于Apriori算法执行广度优先搜索来扫描整个数据库，支持计数相当耗时。或者，如果数据库适合内存，您可以使用Eclat算法，该算法执行深度优先搜索来计算支持数。因此，Eclat算法比Apriori算法执行得更快。在这个菜谱中，我们介绍如何使用Eclat算法来生成频繁项集。</li><li class="listitem">In addition to generating a static plot, you can generate an interactive plot by setting interactive equal to TRUE through the following steps:<div><pre class="programlisting">
<strong class="calibre2">&gt; plot(rules.pruned,interactive=TRUE)</strong>
</pre></div><div><img src="img/00213.jpeg" alt="See also" class="calibre9"/><div><p class="calibre12">准备就绪</p></div></div><p class="calibre13">在这个<a id="id846" class="calibre1"/>菜谱中，我们将继续使用数据集<code class="email">Groceries</code>作为输入数据源。</p></li></ul></div></div></div></body></html>


<html>
  <head>
    <title>Mining frequent itemsets with Eclat</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div/><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch10lvl2sec410" class="calibre1"/>怎么做...</h1></div></div></div><p class="calibre7">执行以下步骤，使用Eclat算法生成频繁项集:</p></div></body></html>


<html>
  <head>
    <title>Mining frequent itemsets with Eclat</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_1">类似于Apriori方法，我们可以使用<code class="email">eclat</code>函数生成频繁项集:<div> <pre class="programlisting"> <strong class="calibre2">&gt; frequentsets=eclat(Groceries,parameter=list(support=0.05,maxlen=10))</strong> </pre> </div></h2></div></div></div><p class="calibre7">然后我们可以从生成的频繁项集:<div> <pre class="programlisting"> <strong class="calibre2">&gt; summary(frequentsets)</strong> <strong class="calibre2">set of 31 itemsets</strong>  <strong class="calibre2">most frequent items:</strong> <strong class="calibre2">      whole milk other vegetables           yogurt </strong> <strong class="calibre2">               4                2                2 </strong> <strong class="calibre2">      rolls/buns      frankfurter          (Other) </strong> <strong class="calibre2">               2                1               23 </strong>  <strong class="calibre2">element (itemset/transaction) length distribution:sizes</strong> <strong class="calibre2"> 1  2 </strong> <strong class="calibre2">28  3 </strong>  <strong class="calibre2">   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. </strong> <strong class="calibre2">  1.000   1.000   1.000   1.097   1.000   2.000 </strong>  <strong class="calibre2">summary of quality measures:</strong> <strong class="calibre2">    support       </strong> <strong class="calibre2"> Min.   :0.05236  </strong> <strong class="calibre2"> 1st Qu.:0.05831  </strong> <strong class="calibre2"> Median :0.07565  </strong> <strong class="calibre2"> Mean   :0.09212  </strong> <strong class="calibre2"> 3rd Qu.:0.10173  </strong> <strong class="calibre2"> Max.   :0.25552  </strong>  <strong class="calibre2">includes transaction ID lists: FALSE </strong>  <strong class="calibre2">mining info:</strong> <strong class="calibre2">      data ntransactions support</strong> <strong class="calibre2"> Groceries          9835    0.05</strong> </pre> </div>中获取汇总信息</p></div></div></body></html>


<html>
  <head>
    <title>Mining frequent itemsets with Eclat</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_2">最后，我们<a id="id847" class="calibre1"/>可以考察十大支持频繁项集:<div> <pre class="programlisting"> <strong class="calibre2">&gt; inspect(sort(frequentsets,by="support")[1:10])</strong> <strong class="calibre2">   items                 support</strong> <strong class="calibre2">1  {whole milk}       0.25551601</strong> <strong class="calibre2">2  {other vegetables} 0.19349263</strong> <strong class="calibre2">3  {rolls/buns}       0.18393493</strong> <strong class="calibre2">4  {soda}             0.17437722</strong> <strong class="calibre2">5  {yogurt}           0.13950178</strong> <strong class="calibre2">6  {bottled water}    0.11052364</strong> <strong class="calibre2">7  {root vegetables}  0.10899847</strong> <strong class="calibre2">8  {tropical fruit}   0.10493137</strong> <strong class="calibre2">9  {shopping bags}    0.09852567</strong> <strong class="calibre2">10 {sausage}          0.09395018</strong> </pre> </div></h2></div></div></div><p class="calibre7"><a id="ch10lvl2sec411" class="calibre1"/>工作原理...</p><div><ol class="orderedlist"><li class="listitem" value="1">在这个菜谱中，我们引入了另一个算法Eclat来执行频繁项集生成。虽然Apriori是一种简单易懂的关联挖掘方法，但该算法的缺点是产生大量候选集，并且在支持计数方面效率低下，因为它需要多次扫描数据库。与Apriori相比，Eclat使用等价类、深度优先搜索和集合交集，这大大提高了支持计数的速度。</li><li class="listitem" value="2">在Apriori中，该算法使用水平数据布局来存储事务。另一方面，Eclat使用垂直数据布局来存储每个项目的事务id列表(<code class="email">tid</code>)。然后，Eclat通过交叉两个k-项集的tid列表来确定任何k+1-项集的支持度。最后，Eclat利用频繁项目集来生成关联规则:</li><li class="listitem" value="3">Eclat算法的一个例子</li></ol><div/></div></div></div></body></html>


<html>
  <head>
    <title>Mining frequent itemsets with Eclat</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch10lvl2sec411" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre7">与使用Apriori算法的方法类似，我们可以使用<code class="email">eclat</code>函数来生成一个具有给定支持度(在本例中假设支持度= 2)和最大长度的频繁项集。</p><p class="calibre7">生成频繁项目集</p><div><img src="img/00214.jpeg" alt="How it works..." class="calibre9"/><div><p class="calibre12">An illustration of Eclat algorithm</p></div></div><p class="calibre10">然后，我们可以使用<code class="email">summary</code>函数来获得汇总统计数据，其中包括:最频繁的项目、项目集长度分布、质量度量的汇总以及挖掘信息。最后，我们可以根据支持度对频繁项集进行排序，并检查前十个支持度频繁项集。</p><p class="calibre7"><a id="ch10lvl2sec412" class="calibre1"/>亦见</p><div><img src="img/00215.jpeg" alt="How it works..." class="calibre9"/><div><p class="calibre12">除了<a id="id849" class="calibre1"/> Apriori和Eclat，另一个流行的关联挖掘算法是<strong class="calibre2"> FP-Growth </strong>。与Eclat类似，这需要深度优先搜索来计算支持度。但是，现在还没有包含这个算法的R包可以从CRAN下载。然而，如果您有兴趣了解如何在您的交易数据集中应用FP-growth算法，您可以参考克里斯蒂安·博格特在http://www.borgelt.net/fpgrowth.html的页面了解更多信息。</p></div></div><p class="calibre10"><a id="ch10lvl1sec119" class="calibre1"/>使用时态信息创建交易</p><p class="calibre7">除了挖掘事务数据库中有趣的关联，我们还可以使用带有时态信息的事务来挖掘<a id="id851" class="calibre1"/>有趣的序列模式。在下面的食谱中，我们演示了如何用时态信息创建事务。</p></div></div></body></html>


<html>
  <head>
    <title>Mining frequent itemsets with Eclat</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch10lvl2sec413" class="calibre1"/>准备就绪</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">在这个菜谱中，我们将使用时态信息生成事务。我们可以使用生成的事务作为频繁序列模式挖掘的输入源。</li></ul></div></div></div></body></html>


<html>
  <head>
    <title>Creating transactions with temporal information</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div/><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch10lvl2sec414" class="calibre1"/>怎么做...</h1></div></div></div><p class="calibre7">执行以下步骤来创建带有时态信息的事务:</p></div></body></html>


<html>
  <head>
    <title>Creating transactions with temporal information</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_1">首先，您需要安装并加载软件包<code class="email">arulesSequences</code> : <div> <pre class="programlisting"> <strong class="calibre2">&gt; install.packages("arulesSequences")</strong> <strong class="calibre2">&gt; library(arulesSequences)</strong> </pre> </div></h2></div></div></div><p class="calibre7">您可以先创建一个有采购记录的列表:<div> <pre class="programlisting"> <strong class="calibre2">&gt; tmp_data=list(c("A"),</strong> <strong class="calibre2">+                c("A","B","C"),</strong> <strong class="calibre2">+                c("A","C"),</strong> <strong class="calibre2">+                c("D"),</strong> <strong class="calibre2">+                c("C","F"),</strong> <strong class="calibre2">+                c("A","D"),</strong> <strong class="calibre2">+                c("C"),</strong> <strong class="calibre2">+                c("B","C"),</strong> <strong class="calibre2">+                c("A","E"),</strong> <strong class="calibre2">+                c("E","F"),</strong> <strong class="calibre2">+                c("A","B"),</strong> <strong class="calibre2">+                c("D","F"),</strong> <strong class="calibre2">+                c("C"),</strong> <strong class="calibre2">+                c("B"),</strong> <strong class="calibre2">+                c("E"),</strong> <strong class="calibre2">+                c("G"),</strong> <strong class="calibre2">+                c("A","F"),</strong> <strong class="calibre2">+                c("C"),</strong> <strong class="calibre2">+                c("B"),</strong> <strong class="calibre2">+                c("C"))</strong> </pre> </div></p></div></div></body></html>


<html>
  <head>
    <title>Creating transactions with temporal information</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_2">然后您<a id="id852" class="calibre1"/>可以将列表转换成事务并添加时态信息:<div> <pre class="programlisting"> <strong class="calibre2">&gt;names(tmp_data) = paste("Tr",c(1:20), sep = "")</strong> <strong class="calibre2">&gt;trans =  as(tmp_data,"transactions")</strong> <strong class="calibre2">&gt;transactionInfo(trans)$sequenceID=c(1,1,1,1,1,2,2,2,2,3,3,3,3,3,4,4,4,4,4,4)</strong> <strong class="calibre2">&gt;transactionInfo(trans)$eventID=c(10,20,30,40,50,10,20,30,40,10,20,30,40,50,10,20,30,40,50,60)</strong> <strong class="calibre2">&gt; trans</strong> <strong class="calibre2">transactions in sparse format with</strong> <strong class="calibre2"> 20 transactions (rows) and</strong> <strong class="calibre2"> 7 items (columns)</strong> </pre> </div></h2></div></div></div><p class="calibre7">接下来，您可以使用<code class="email">inspect</code>函数来检查交易:<div> <pre class="programlisting"> <strong class="calibre2">&gt; inspect(head(trans))</strong> <strong class="calibre2">  items transactionID sequenceID eventID</strong> <strong class="calibre2">1 {A}             Tr1          1      10</strong> <strong class="calibre2">2 {A,                                   </strong> <strong class="calibre2">   B,                                   </strong> <strong class="calibre2">   C}             Tr2          1      20</strong> <strong class="calibre2">3 {A,                                   </strong> <strong class="calibre2">   C}             Tr3          1      30</strong> <strong class="calibre2">4 {D}             Tr4          1      40</strong> <strong class="calibre2">5 {C,                                   </strong> <strong class="calibre2">   F}             Tr5          1      50</strong> <strong class="calibre2">6 {A,                                   </strong> <strong class="calibre2">   D}             Tr6          2      10</strong> </pre> </div></p><div><ol class="orderedlist"><li class="listitem" value="1">然后，您可以获得带有时态信息的交易的汇总信息:<div> <pre class="programlisting"> <strong class="calibre2">&gt; summary(trans)</strong> <strong class="calibre2">transactions as itemMatrix in sparse format with</strong> <strong class="calibre2"> 20 rows (elements/itemsets/transactions) and</strong> <strong class="calibre2"> 7 columns (items) and a density of 0.2214286 </strong>  <strong class="calibre2">most frequent items:</strong> <strong class="calibre2">      C       A       B       F       D (Other) </strong> <strong class="calibre2">      8       7       5       4       3       4 </strong>  <strong class="calibre2">element (itemset/transaction) length distribution:</strong> <strong class="calibre2">sizes</strong> <strong class="calibre2"> 1  2  3 </strong> <strong class="calibre2">10  9  1 </strong>  <strong class="calibre2">   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. </strong> <strong class="calibre2">   1.00    1.00    1.50    1.55    2.00    3.00 </strong>  <strong class="calibre2">includes extended item information - examples:</strong> <strong class="calibre2">  labels</strong> <strong class="calibre2">1      A</strong> <strong class="calibre2">2      B</strong> <strong class="calibre2">3      C</strong>  <strong class="calibre2">includes extended transaction information - examples:</strong> <strong class="calibre2">  transactionID sequenceID eventID</strong> <strong class="calibre2">1           Tr1          1      10</strong> <strong class="calibre2">2           Tr2          1      20</strong> <strong class="calibre2">3           Tr3          1      30</strong> </pre> </div></li><li class="listitem" value="2">您<a id="id853" class="calibre1"/>也可以读取篮子格式的交易数据:<div> <pre class="programlisting"> <strong class="calibre2">&gt; zaki=read_baskets(con = system.file("misc", "zaki.txt", package = "arulesSequences"), info = c("sequenceID","eventID","SIZE"))</strong> <strong class="calibre2">&gt; as(zaki, "data.frame")</strong> <strong class="calibre2">   transactionID.sequenceID transactionID.eventID transactionID.SIZE     items</strong> <strong class="calibre2">1                         1                    10                  2     {C,D}</strong> <strong class="calibre2">2                         1                    15                  3   {A,B,C}</strong> <strong class="calibre2">3                         1                    20                  3   {A,B,F}</strong> <strong class="calibre2">4                         1                    25                  4 {A,C,D,F}</strong> <strong class="calibre2">5                         2                    15                  3   {A,B,F}</strong> <strong class="calibre2">6                         2                    20                  1       {E}</strong> <strong class="calibre2">7                         3                    10                  3   {A,B,F}</strong> <strong class="calibre2">8                         4                    10                  3   {D,G,H}</strong> <strong class="calibre2">9                         4                    20                  2     {B,F}</strong> <strong class="calibre2">10                        4                    25                  3   {A,G,H}</strong> </pre> </div></li><li class="listitem" value="3"><a id="ch10lvl2sec415" class="calibre1"/>工作原理...</li><li class="listitem" value="4">在挖掘频繁序列模式之前，需要用<a id="id854" class="calibre1"/>时态信息创建事务。在这个配方中，我们介绍两种方法来获得带有时态信息的事务。在第一种方法中，我们创建一个事务列表，并为每个事务分配一个事务ID。我们使用<code class="email">as</code>函数将列表数据转换成事务数据集。然后我们添加<code class="email">eventID</code>和<code class="email">sequenceID</code>作为时态信息；<code class="email">sequenceID</code>是事件所属的序列，<code class="email">eventID</code>表示事件发生的时间。在生成带有时态信息的事务后，可以使用这个数据集进行频繁的序列模式挖掘。</li><li class="listitem" value="5">除了使用时态信息创建您自己的事务，如果您已经将数据存储在文本文件中，您可以使用<code class="email">arulesSequences</code>中的<code class="email">read_basket</code>函数将事务数据读入购物篮格式。我们还可以读取事务数据集，以便进行更频繁的序列模式挖掘。</li><li class="listitem" value="6"><a id="ch10lvl2sec416" class="calibre1"/>参见</li></ol><div/></div></div></div></body></html>


<html>
  <head>
    <title>Creating transactions with temporal information</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><code class="email">arulesSequences</code>函数提供了两个额外的数据结构，<code class="email">sequences</code>和<code class="email">timedsequences</code>，用于呈现纯序列数据和带有时间信息的序列数据。对这两个集合感兴趣的朋友，请使用帮助功能查看以下文档:<div> <pre class="programlisting"> <strong class="calibre2">&gt; help("sequences-class")</strong> <strong class="calibre2">&gt; help("timedsequences-class")</strong> </pre> </div></h2></div></div></div><p class="calibre7">用cSPADE挖掘频繁序列模式</p><p class="calibre7">与仅发现项目集之间关系的关联挖掘相反，我们<a id="id855" class="calibre1"/>可能对探索一组项目集顺序出现的事务之间共享的模式感兴趣。</p></div></div></body></html>


<html>
  <head>
    <title>Creating transactions with temporal information</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_4">最著名的频繁序列模式挖掘算法之一是使用等价类的<strong class="calibre2">序列模式发现</strong> ( <strong class="calibre2"> SPADE </strong>)算法，该算法利用垂直数据库的特性<a id="id856" class="calibre1"/>通过有效的网格搜索在ID列表上执行交集，并允许我们对挖掘的序列进行约束。在这个菜谱中，我们将演示如何使用cSPADE来挖掘频繁序列模式。</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">准备就绪</li></ul></div></div></div></body></html>


<html>
  <head>
    <title>Mining frequent sequential patterns with cSPADE</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div/><div><div><div><div><h1 class="title" id="calibre_pb_0">在这个配方中，您必须通过生成带有时态信息的事务来完成前面的配方，并将它存储在变量<code class="email">trans</code>中。</h1></div></div></div><p class="calibre7"><a id="ch10lvl2sec418" class="calibre1"/>怎么做...</p><p class="calibre7">执行以下步骤来挖掘频繁的序列模式:</p></div></body></html>


<html>
  <head>
    <title>Mining frequent sequential patterns with cSPADE</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_1">首先，可以使用<code class="email">cspade</code>函数生成频繁序列模式:<div> <pre class="programlisting"> <strong class="calibre2">&gt; s_result=cspade(trans,parameter = list(support = 0.75),control = list(verbose = TRUE))</strong> </pre> </div></h2></div></div></div><p class="calibre7">然后可以查看频繁序列模式的摘要:<div> <pre class="programlisting"> <strong class="calibre2">&gt; summary(s_result)</strong> <strong class="calibre2">set of 14 sequences with</strong>  <strong class="calibre2">most frequent items:</strong> <strong class="calibre2">      C       A       B       D       E (Other) </strong> <strong class="calibre2">      8       5       5       2       1       1 </strong>  <strong class="calibre2">most frequent elements:</strong> <strong class="calibre2">    {C}     {A}     {B}     {D}     {E} (Other) </strong> <strong class="calibre2">      8       5       5       2       1       1 </strong>  <strong class="calibre2">element (sequence) size distribution:</strong> <strong class="calibre2">sizes</strong> <strong class="calibre2">1 2 3 </strong> <strong class="calibre2">6 6 2 </strong>  <strong class="calibre2">sequence length distribution:</strong> <strong class="calibre2">lengths</strong> <strong class="calibre2">1 2 3 </strong> <strong class="calibre2">6 6 2 </strong>  <strong class="calibre2">summary of quality measures:</strong> <strong class="calibre2">    support      </strong> <strong class="calibre2"> Min.   :0.7500  </strong> <strong class="calibre2"> 1st Qu.:0.7500  </strong> <strong class="calibre2"> Median :0.7500  </strong> <strong class="calibre2"> Mean   :0.8393  </strong> <strong class="calibre2"> 3rd Qu.:1.0000  </strong> <strong class="calibre2"> Max.   :1.0000  </strong>  <strong class="calibre2">includes transaction ID lists: FALSE </strong>  <strong class="calibre2">mining info:</strong> <strong class="calibre2">  data ntransactions nsequences support</strong> <strong class="calibre2"> trans            20          4    0.75</strong> </pre> </div></p></div></div></body></html>


<html>
  <head>
    <title>Mining frequent sequential patterns with cSPADE</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_2">将<a id="id857" class="calibre1"/>生成的序列格式数据转换回数据帧:<div> <pre class="programlisting"> <strong class="calibre2">&gt; as(s_result, "data.frame")</strong> <strong class="calibre2">        sequence support</strong> <strong class="calibre2">1          &lt;{A}&gt;    1.00</strong> <strong class="calibre2">2          &lt;{B}&gt;    1.00</strong> <strong class="calibre2">3          &lt;{C}&gt;    1.00</strong> <strong class="calibre2">4          &lt;{D}&gt;    0.75</strong> <strong class="calibre2">5          &lt;{E}&gt;    0.75</strong> <strong class="calibre2">6          &lt;{F}&gt;    0.75</strong> <strong class="calibre2">7      &lt;{A},{C}&gt;    1.00</strong> <strong class="calibre2">8      &lt;{B},{C}&gt;    0.75</strong> <strong class="calibre2">9      &lt;{C},{C}&gt;    0.75</strong> <strong class="calibre2">10     &lt;{D},{C}&gt;    0.75</strong> <strong class="calibre2">11 &lt;{A},{C},{C}&gt;    0.75</strong> <strong class="calibre2">12     &lt;{A},{B}&gt;    1.00</strong> <strong class="calibre2">13     &lt;{C},{B}&gt;    0.75</strong> <strong class="calibre2">14 &lt;{A},{C},{B}&gt;    0.75</strong> </pre> </div></h2></div></div></div><p class="calibre7"><a id="ch10lvl2sec419" class="calibre1"/>工作原理...</p><div><ol class="orderedlist"><li class="listitem" value="1">序列模式挖掘的<a id="id858" class="calibre1"/>目标是发现事务中的序列关系或模式。您可以使用模式挖掘结果来预测未来事件，或者向用户推荐项目。</li><li class="listitem" value="2">一种流行的序列模式挖掘方法是SPADE。SPADE使用垂直数据布局来存储id列表。其中，数据库中的每个输入序列称为SID，给定输入序列中的每个事件称为EID。SPADE过程是通过由先验候选生成逐层生成模式来执行的。详细地说，SPADE从ID列表的交集的连接(n-1)序列中生成后续的n序列。如果序列的个数大于<strong class="calibre2">最小支持度</strong> ( <strong class="calibre2"> minsup </strong>)，我们可以认为序列足够频繁。该算法停止<a id="id860" class="calibre1"/>，直到该过程不能找到更频繁的序列:</li><li class="listitem" value="3">SPADE算法的一个例子</li></ol><div/></div></div></div></body></html>


<html>
  <head>
    <title>Mining frequent sequential patterns with cSPADE</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch10lvl2sec419" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre7">在这个菜谱中，我们演示了如何使用频繁序列模式挖掘算法cSPADE来挖掘频繁序列模式。首先，由于我们的事务在变量<code class="email">trans</code>中加载了时态信息，我们可以使用支持0.75以上的<code class="email">cspade</code>函数来生成<code class="email">sequences</code>格式的频繁序列模式。然后，我们可以获得汇总信息，比如最常见的项目、序列大小分布、质量度量的汇总以及挖掘信息。最后，我们可以将<a id="id861" class="calibre1"/>生成的<code class="email">sequence</code>信息转换回数据帧格式，这样我们就可以检查支持度超过0.75的频繁序列模式的顺序和支持度。</p><p class="calibre7"><a id="ch10lvl2sec420" class="calibre1"/>参见</p><div><img src="img/00216.jpeg" alt="How it works..." class="calibre9"/><div><p class="calibre12">如果你对SPADE算法的概念和设计感兴趣，可以参考最初发表的论文:M. J. Zaki。(2001).<em class="calibre8"> SPADE:一种挖掘频繁序列的高效算法。机器学习期刊</em>，42，31–60。</p></div></div><p class="calibre10"><a id="ch11" class="calibre1"/>第十一章。降维</p><p class="calibre7">在本章中，我们将讨论以下主题:</p></div></div></body></html>


<html>
  <head>
    <title>Mining frequent sequential patterns with cSPADE</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_4">使用FSelector执行功能选择</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">使用主成分分析进行降维</li></ul></div></div></div></body></html>


<html>
  <head>
    <title>Chapter 11. Dimension Reduction</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div/><div><div><div><div><h1 class="title" id="calibre_pb_0">用筛选试验确定主成分数</h1></div></div></div><p class="calibre7">用Kaiser方法确定主成分数</p><div><ul class="itemizedlist"><li class="listitem">使用双标图可视化多元数据</li><li class="listitem">用MDS进行降维</li><li class="listitem">利用奇异值分解降低维数</li><li class="listitem">用奇异值分解压缩图像</li><li class="listitem">用ISOMAP进行非线性降维</li><li class="listitem">用局部线性嵌入进行非线性降维</li><li class="listitem"><a id="ch11lvl1sec121" class="calibre1"/>简介</li><li class="listitem">大多数数据集包含高度冗余的要素(如属性或变量)。为了移除不相关和冗余的数据以降低计算成本并避免过度拟合，您可以将要素缩减为一个更小的子集，而不会显著丢失信息。减少特征的数学过程称为降维。</li><li class="listitem">特征的减少可以提高数据处理的效率。因此，降维被广泛应用于模式识别、文本检索和机器学习等领域。降维<a id="id863" class="calibre1"/>可以分为两部分:特征提取<a id="id864" class="calibre1"/>和特征选择。特征<a id="id865" class="calibre1"/>提取是一种使用低<a id="id866" class="calibre1"/>维空间来表示高维空间中的数据的技术。特征选择用于找到原始变量的子集。</li><li class="listitem">特征选择的目的是选择一组相关的特征来构建模型。特征选择技术可以分为特征排序和特征选择。功能分级根据特定标准对功能进行分级，然后选择高于定义阈值的功能。另一方面，特征选择从特征子集空间中搜索最优子集。</li></ul></div></div></body></html>


<html>
  <head>
    <title>Chapter 11. Dimension Reduction</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h1 class="title" id="calibre_pb_1">在特征提取中，问题可以分为线性或非线性。线性方法搜索最能解释数据分布变化的仿射空间。相比之下，对于分布在高度非线性曲面上的数据，非线性方法是更好的选择。这里列举一些常见的线性和非线性方法。</h1></div></div></div><p class="calibre7">以下是一些常见的线性方法:</p><p class="calibre7"><strong class="calibre2"> PCA </strong>:主成分分析<a id="id867" class="calibre1"/>将数据映射到一个更低的维度，使得数据在一个低维表示中的方差<a id="id868" class="calibre1"/>最大化。</p><p class="calibre7"><strong class="calibre2"> MDS </strong>:多维缩放是一种<a id="id869" class="calibre1"/>方法，它允许您可视化对象之间的接近程度(模式接近度),并可以用更低维度的空间生成数据的表示<a id="id870" class="calibre1"/>。如果在MDS使用的距离测量等于数据的协方差，则PCA可以被认为是MDS的最简单形式。</p><p class="calibre7"><strong class="calibre2"> SVD </strong>:奇异值分解<a id="id871" class="calibre1"/>从线性代数的角度去除线性相关的冗余特征<a id="id872" class="calibre1"/>。PCA也可以看作是奇异值分解的一个特例。</p><p class="calibre7">以下是一些常见的非线性方法:</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre2"> ISOMAP </strong> : ISOMAP <a id="id873" class="calibre1"/>可以看作是MDS的延伸<a id="id874" class="calibre1"/>，它使用测地线距离的距离度量。在这种方法中，测地线距离是通过绘制最短路径距离来计算的。</li><li class="listitem"><strong class="calibre2"> LLE </strong>:局部线性嵌入<a id="id875" class="calibre1"/>进行局部PCA和全局特征分解。LLE <a id="id876" class="calibre1"/>是一种局部方法，包括为类特征的每个类别选择特征。相比之下，ISOMAP是一种全局方法，它涉及为所有特征选择特征。</li><li class="listitem">在本章中，我们将首先讨论如何执行特征排序和选择。接下来，我们将重点讨论使用线性和非线性方法进行降维时的特征提取和覆盖方法。对于线性方法，我们将介绍如何执行PCA、确定主成分的数量及其可视化。然后，我们继续前往MDS和SVD。此外，我们将介绍奇异值分解在图像压缩中的应用。对于非线性方法，我们将介绍如何使用ISOMAP和LLE进行降维。</li></ul></div><p class="calibre7"><a id="ch11lvl1sec122" class="calibre1"/>用偏置选择器进行特征选择</p><div><ul class="itemizedlist"><li class="listitem"><code class="email">FSelector</code>包提供了从原始特征集中选择最有影响的特征的两种方法。首先，根据一定的标准对特征进行排序，选择<a id="id877" class="calibre1"/>高于定义阈值的特征。其次，从特征子集空间中寻找最优的特征子集。在本<a id="id878" class="calibre1"/>菜谱中，我们将介绍如何使用<code class="email">FSelector</code>包进行特征选择。</li><li class="listitem"><a id="ch11lvl2sec421" class="calibre1"/>准备</li></ul></div><p class="calibre7">在本食谱中，我们将继续使用电信<code class="email">churn</code>数据集作为输入数据源来训练支持向量机。对于尚未准备好数据集的，请参见<a class="calibre1" title="Chapter 5. Classification (I) – Tree, Lazy, and Probabilistic" href="part0060_split_000.html#page">第5章</a>、<em class="calibre8">分类(一)–树、懒、概率</em>。</p></div></div></body></html>


<html>
  <head>
    <title>Performing feature selection with FSelector</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div/><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch11lvl2sec422" class="calibre1"/>怎么做...</h1></div></div></div><p class="calibre7">执行以下步骤对<code class="email">churn</code>数据集进行特征选择:</p></div></body></html>


<html>
  <head>
    <title>Performing feature selection with FSelector</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_1">首先，安装并加载软件包<code class="email">FSelector</code> : <div> <pre class="programlisting"> <strong class="calibre2">&gt; install.packages("FSelector")</strong> <strong class="calibre2">&gt; library(FSelector)</strong> </pre> </div></h2></div></div></div><p class="calibre7">然后，我们可以使用<code class="email">random.forest.importance</code>来计算每个属性的权重，这里我们将重要性类型设置为1: <div> <pre class="programlisting"> <strong class="calibre2">&gt; weights = random.forest.importance(churn~., trainset, importance.type = 1)</strong> <strong class="calibre2">&gt; print(weights)</strong> <strong class="calibre2">                              attr_importance</strong> <strong class="calibre2">international_plan                 96.3255882</strong> <strong class="calibre2">voice_mail_plan                    24.8921239</strong> <strong class="calibre2">number_vmail_messages              31.5420332</strong> <strong class="calibre2">total_day_minutes                  51.9365357</strong> <strong class="calibre2">total_day_calls                    -0.1766420</strong> <strong class="calibre2">total_day_charge                   53.7930096</strong> <strong class="calibre2">total_eve_minutes                  33.2006078</strong> <strong class="calibre2">total_eve_calls                    -2.2270323</strong> <strong class="calibre2">total_eve_charge                   32.4317375</strong> <strong class="calibre2">total_night_minutes                22.0888120</strong> <strong class="calibre2">total_night_calls                   0.3407087</strong> <strong class="calibre2">total_night_charge                 21.6368855</strong> <strong class="calibre2">total_intl_minutes                 32.4984413</strong> <strong class="calibre2">total_intl_calls                   51.1154046</strong> <strong class="calibre2">total_intl_charge                  32.4855194</strong> <strong class="calibre2">number_customer_service_calls     114.2566676</strong> </pre> </div></p></div></div></body></html>


<html>
  <head>
    <title>Performing feature selection with FSelector</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_2">接下来，我们<a id="id879" class="calibre1"/>可以使用<a id="id880" class="calibre1"/><code class="email">cutoff</code>函数获得前五个权重的属性:<div> <pre class="programlisting"> <strong class="calibre2">&gt; subset = cutoff.k(weights, 5)</strong> <strong class="calibre2">&gt; f = as.simple.formula(subset, "Class")</strong> <strong class="calibre2">&gt; print(f)</strong> <strong class="calibre2">Class ~ number_customer_service_calls + international_plan + </strong> <strong class="calibre2">    total_day_charge + total_day_minutes + total_intl_calls</strong> <strong class="calibre2">&lt;environment: 0x00000000269a28e8&gt;</strong> </pre> </div></h2></div></div></div><p class="calibre7">接下来，我们可以让评估者选择特征子集:<div> <pre class="programlisting"> <strong class="calibre2">&gt; evaluator = function(subset) {</strong> <strong class="calibre2">+   k = 5  </strong> <strong class="calibre2">+   set.seed(2)</strong> <strong class="calibre2">+   ind = sample(5, nrow(trainset), replace = TRUE)</strong> <strong class="calibre2">+   results = sapply(1:k, function(i) {</strong> <strong class="calibre2">+     train = trainset[ind ==i,]</strong> <strong class="calibre2">+     test  = trainset[ind !=i,]</strong> <strong class="calibre2">+     tree  = rpart(as.simple.formula(subset, "churn"), trainset)</strong> <strong class="calibre2">+     error.rate = sum(test$churn != predict(tree, test, type="class")) / nrow(test)</strong> <strong class="calibre2">+     return(1 - error.rate)</strong> <strong class="calibre2">+   })</strong> <strong class="calibre2">+   return(mean(results))</strong> <strong class="calibre2">+ }</strong> </pre> </div></p><div><ol class="orderedlist"><li class="listitem" value="1">最后，我们可以使用爬山搜索找到最佳特征子集:<div> <pre class="programlisting"> <strong class="calibre2">&gt; attr.subset = hill.climbing.search(names(trainset)[!names(trainset) %in% "churn"], evaluator)</strong> <strong class="calibre2">&gt; f = as.simple.formula(attr.subset, "churn")</strong> <strong class="calibre2">&gt; print(f)</strong> <strong class="calibre2">churn ~ international_plan + voice_mail_plan + number_vmail_messages + </strong> <strong class="calibre2">    total_day_minutes + total_day_calls + total_eve_minutes + </strong> <strong class="calibre2">    total_eve_charge + total_intl_minutes + total_intl_calls + </strong> <strong class="calibre2">    total_intl_charge + number_customer_service_calls</strong> <strong class="calibre2">&lt;environment: 0x000000002224d3d0&gt;</strong> </pre> </div></li><li class="listitem" value="2"><a id="ch11lvl2sec423" class="calibre1"/>工作原理...</li><li class="listitem" value="3">在这个<a id="id881" class="calibre1"/>配方中，我们展示了如何<a id="id882" class="calibre1"/>使用<code class="email">FSelector</code>包来选择最有影响力的特性。我们首先演示如何使用特征排序方法。在特征排序方法中，该算法首先采用权重函数来为每个特征生成权重。这里，我们使用精度平均下降(其中<code class="email">importance.type = 1</code>)的随机森林算法作为重要性度量来获得每个属性的权重。除了随机森林算法，您还可以从<code class="email">FSelector</code>包中选择其他特征排序算法(例如<code class="email">chi.squared</code>、<code class="email">information.gain</code>)。然后，该过程按权重对属性进行排序。最后，我们可以通过<code class="email">cutoff</code>函数从排序后的特征列表中获得前五个特征。在这种情况下，<code class="email">number_customer_service_calls</code>、<code class="email">international_plan, total_day_charge</code>、<code class="email">total_day_minutes</code>和<code class="email">total_intl_calls</code>是五个最重要的特征。</li><li class="listitem" value="4">接下来，我们说明如何搜索最佳特征子集。首先，我们需要建立一个五重交叉验证函数来评估特征子集的重要性。然后，我们使用爬山搜索算法从原始特征集中寻找最优特征子集。除了爬山法，用户可以从<code class="email">FSelector</code>包中选择其他特征选择算法(例如<code class="email">forward.search</code>)。最后，我们可以发现<code class="email">international_plan + voice_mail_plan + number_vmail_messages + total_day_minutes + total_day_calls + total_eve_minutes + total_eve_charge + total_intl_minutes + total_intl_calls + total_intl_charge + number_customer_service_calls</code>是最优特征子集。</li><li class="listitem" value="5"><a id="ch11lvl2sec424" class="calibre1"/>参见</li></ol><div/></div></div></div></body></html>


<html>
  <head>
    <title>Performing feature selection with FSelector</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_3">您也可以使用<code class="email">caret</code>包来执行特征选择。由于我们已经在模型评估章节中讨论了相关配方，您可以参考<a class="calibre1" title="Chapter 7. Model Evaluation" href="part0083_split_000.html#page">第7章</a>、<em class="calibre8">模型评估</em>了解更多详细信息。</h2></div></div></div><p class="calibre7">对于<a id="id883" class="calibre1"/>既有功能<a id="id884" class="calibre1"/>排序又有最优功能选择，可以探索包<code class="email">FSelector</code>，更多相关功能:<div> <pre class="programlisting"> <strong class="calibre2">&gt; help(package="FSelector")</strong> </pre> </div></p><p class="calibre7"><a id="ch11lvl1sec123" class="calibre1"/>使用主成分分析进行降维</p></div></div></body></html>


<html>
  <head>
    <title>Performing feature selection with FSelector</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><strong class="calibre2">主成分分析</strong> ( <strong class="calibre2"> PCA </strong>)是处理降维问题中应用最广泛的线性方法。当数据包含许多特征，并且这些特征中有<a id="id885" class="calibre1"/>冗余(相关性)时，这是有用的。为了移除冗余特征，PCA通过将特征减少为较少数量的主成分来将高维数据映射到较低维，这些主成分解释了原始特征的大部分变化。在这份食谱中，我们将介绍如何用主成分分析法进行降维。</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">准备就绪</li><li class="listitem">在这个配方中，我们将使用<code class="email">swiss</code>数据集作为我们执行PCA的目标。<code class="email">swiss</code>数据集包括大约1888年瑞士47个法语省份的标准化生育指标和社会经济指标。</li></ul></div></div></div></body></html>


<html>
  <head>
    <title>Performing dimension reduction with PCA</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div/><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch11lvl2sec426" class="calibre1"/>怎么做...</h1></div></div></div><p class="calibre7">执行以下步骤对<code class="email">swiss</code>数据集进行主成分分析:</p></div></body></html>


<html>
  <head>
    <title>Performing dimension reduction with PCA</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_1">首先，加载<code class="email">swiss</code>数据集:<div> <pre class="programlisting"> <strong class="calibre2">&gt; data(swiss)</strong> </pre> </div></h2></div></div></div><p class="calibre7">排除第一列<code class="email">swiss</code>数据:<div> <pre class="programlisting"> <strong class="calibre2">&gt; swiss = swiss[,-1]</strong> </pre> </div></p></div></div></body></html>


<html>
  <head>
    <title>Performing dimension reduction with PCA</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_2">然后可以对<code class="email">swiss</code>数据进行主成分分析:<div> <pre class="programlisting"> <strong class="calibre2">&gt; swiss.pca = prcomp(swiss,</strong> <strong class="calibre2">+ center = TRUE,</strong> <strong class="calibre2">+ scale  = TRUE)</strong> <strong class="calibre2">&gt; swiss.pca</strong> <strong class="calibre2">Standard deviations:</strong> <strong class="calibre2">[1] 1.6228065 1.0354873 0.9033447 0.5592765 0.4067472</strong>  <strong class="calibre2">Rotation:</strong> <strong class="calibre2">                         PC1         PC2          PC3        PC4         PC5</strong> <strong class="calibre2">Agriculture      0.52396452 -0.25834215  0.003003672 -0.8090741  0.06411415</strong> <strong class="calibre2">Examination  -0.57185792 -0.01145981 -0.039840522 -0.4224580 -0.70198942</strong> <strong class="calibre2">Education       -0.49150243  0.19028476  0.539337412 -0.3321615  0.56656945</strong> <strong class="calibre2">Catholic            0.38530580  0.36956307  0.725888143 0.1007965 -0.42176895</strong> <strong class="calibre2">Infant.Mortality 0.09167606 0.87197641 -0.424976789 -0.2154928 0.06488642</strong> </pre> </div></h2></div></div></div><p class="calibre7">从PCA结果中获取摘要:<div> <pre class="programlisting"> <strong class="calibre2">&gt; summary(swiss.pca)</strong> <strong class="calibre2">Importance of components:</strong> <strong class="calibre2">                          PC1    PC2    PC3     PC4     PC5</strong> <strong class="calibre2">Standard deviation     1.6228 1.0355 0.9033 0.55928 0.40675</strong> <strong class="calibre2">Proportion of Variance 0.5267 0.2145 0.1632 0.06256 0.03309</strong> <strong class="calibre2">Cumulative Proportion  0.5267 0.7411 0.9043 0.96691 1.00000</strong> </pre> </div></p><div><ol class="orderedlist"><li class="listitem" value="1">最后，您可以使用<code class="email">predict</code>函数输出第一行数据的主成分值:<div> <pre class="programlisting"> <strong class="calibre2">&gt; predict(swiss.pca, newdata=head(swiss, 1))</strong> <strong class="calibre2">                  PC1       PC2        PC3      PC4       PC5</strong> <strong class="calibre2">Courtelary -0.9390479 0.8047122 -0.8118681 1.000307 0.4618643</strong> </pre> </div></li><li class="listitem" value="2"><a id="ch11lvl2sec427" class="calibre1"/>工作原理...</li><li class="listitem" value="3">由于<a id="id887" class="calibre1"/>特征选择方法可能<a id="id888" class="calibre1"/>移除一些相关但信息丰富的特征，您必须考虑使用特征提取方法将这些相关特征合并成一个特征。PCA是特征提取方法之一，其执行正交变换以将可能相关的变量转换成主分量。此外，您可以使用这些主成分来确定方差的方向。</li><li class="listitem" value="4">PCA的过程按以下步骤进行:首先，求均值向量，<img src="img/00217.jpeg" alt="How it works..." class="calibre24"/>，其中<img src="img/00218.jpeg" alt="How it works..." class="calibre24"/>表示数据点，<em class="calibre8"> n </em>表示点数。其次，通过等式<img src="img/00219.jpeg" alt="How it works..." class="calibre24"/>计算协方差矩阵。第三，计算特征向量，<img src="img/00220.jpeg" alt="How it works..." class="calibre24"/>，以及相应的特征值。第四步，我们排序选择前<em class="calibre8"> k </em>个特征向量。在<a id="id889" class="calibre1"/>第五步中，我们构造一个<em class="calibre8"> d x k </em>维的<a id="id890" class="calibre1"/>特征向量矩阵u，这里<em class="calibre8"> d </em>是原始维数<em class="calibre8"> k </em>是特征向量的个数。最后，我们可以将数据样本变换到等式中的新子空间<img src="img/00221.jpeg" alt="How it works..." class="calibre24"/>。</li><li class="listitem" value="5">下图说明了我们可以使用两个主成分<img src="img/00222.jpeg" alt="How it works..." class="calibre24"/>和<img src="img/00223.jpeg" alt="How it works..." class="calibre24"/>将数据点从二维空间转换到新的二维子空间:</li></ol><div/></div></div></div></body></html>


<html>
  <head>
    <title>Performing dimension reduction with PCA</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_3">PCA的示例说明</h2></div></div></div><p class="calibre7">Since <a id="id887" class="calibre1"/>the feature selection method may <a id="id888" class="calibre1"/>remove some correlated but informative features, you have to consider combining these correlated features into a single feature with the feature extraction method. PCA is one of the feature extraction methods, which performs orthogonal transformation to convert possibly correlated variables into principal components. Also, you can use these principal components to identify the directions of variance.</p><p class="calibre7">在这个配方中，我们使用<code class="email">stats</code>包中的<code class="email">prcomp</code>函数对<code class="email">swiss</code>数据集执行PCA。首先，我们移除标准化的生育力测量值，并使用剩余的预测值作为函数<code class="email">prcomp</code>的输入。除此之外，我们将<code class="email">swiss</code>设置为输入数据集；通过指定<code class="email">center=TRUE</code>将变量移动到零中心；用选项<code class="email">scale=TRUE</code>将变量换算成单位方差，并将<a id="id891" class="calibre1"/>输出存储在变量<code class="email">swiss.pca</code>中。</p><p class="calibre7">然后，随着<a id="id892" class="calibre1"/>我们打印出<code class="email">swiss.pca</code>中存储的值，我们可以找到主成分的标准差和旋转。标准偏差表示协方差/相关矩阵的特征值的平方根。另一方面，主分量的旋转显示了输入特征的线性组合的系数。比如PC1等于<em class="calibre8">农业* 0.524 +考试* -0.572 +教育* -0.492 +天主教* 0.385 +婴幼儿。死亡率* 0.092 </em>。这里，我们可以发现属性<em class="calibre8">农业</em>对PC1的贡献最大，因为它具有最高的系数。</p><div><img src="img/00224.jpeg" alt="How it works..." class="calibre9"/><div><p class="calibre12">另外，我们可以使用<code class="email">summary</code>函数来获得组件的重要性。第一行显示每个主成分的标准差，第二行显示每个成分解释的方差的比例，第三行显示解释的方差的累积比例。最后，您可以使用<code class="email">predict</code>函数从输入要素中获取主成分。这里，我们输入数据集的第一行，并检索五个主成分。</p></div></div><p class="calibre10">还有更多...</p><p class="calibre7">另一个主成分分析功能是<code class="email">princomp</code>。在该函数中，通过使用相关或协方差矩阵的特征值进行计算，而不是使用<code class="email">prcomp</code>函数中的单值分解。一般情况下，最好使用<code class="email">prcomp</code>；然而，我们在这里介绍如何使用<code class="email">princomp</code>:</p><p class="calibre7">首先使用<code class="email">princomp</code>进行PCA: <div> <pre class="programlisting"> <strong class="calibre2">&gt; swiss.princomp = princomp(swiss,</strong> <strong class="calibre2">+ center = TRUE,</strong> <strong class="calibre2">+ scale  = TRUE)</strong> <strong class="calibre2">&gt; swiss.princomp</strong> <strong class="calibre2">Call:</strong> <strong class="calibre2">princomp(x = swiss, center = TRUE, scale = TRUE)</strong>  <strong class="calibre2">Standard deviations:</strong> <strong class="calibre2">   Comp.1    Comp.2    Comp.3    Comp.4    Comp.5 </strong> <strong class="calibre2">42.896335 21.201887  7.587978  3.687888  2.721105 </strong>  <strong class="calibre2"> 5 variables and 47 observations.</strong> </pre> </div></p><p class="calibre7">然后您<a id="id893" class="calibre1"/>可以获得<a id="id894" class="calibre1"/>汇总信息:<div> <pre class="programlisting"> <strong class="calibre2">&gt; summary(swiss.princomp)</strong> <strong class="calibre2">Importance of components:</strong> <strong class="calibre2">                           Comp.1     Comp.2     Comp.3      Comp.4      Comp.5</strong> <strong class="calibre2">Standard deviation     42.8963346 21.2018868 7.58797830 3.687888330 2.721104713</strong> <strong class="calibre2">Proportion of Variance  0.7770024  0.1898152 0.02431275 0.005742983 0.003126601</strong> <strong class="calibre2">Cumulative Proportion   0.7770024  0.9668177 0.99113042 0.996873399 1.000000000</strong> </pre> </div></p></div></div></body></html>


<html>
  <head>
    <title>Performing dimension reduction with PCA</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_4">您可以使用<code class="email">predict</code>函数从输入特征中获取主成分:<div> <pre class="programlisting"> <strong class="calibre2">&gt; predict(swiss.princomp, swiss[1,])</strong> <strong class="calibre2">              Comp.1    Comp.2   Comp.3   Comp.4   Comp.5</strong> <strong class="calibre2">Courtelary -38.95923 -20.40504 12.45808 4.713234 -1.46634</strong> </pre> </div></h2></div></div></div><p class="calibre7">除了<code class="email">stats</code>包中的<code class="email">prcomp</code>和<code class="email">princomp</code>功能外，您还可以使用<code class="email">psych</code>包中的<code class="email">principal</code>功能:</p><div><ol class="orderedlist"><li class="listitem" value="1">首先，安装并加载<code class="email">psych</code>包:<div> <pre class="programlisting"> <strong class="calibre2">&gt; install.packages("psych")</strong> <strong class="calibre2">&gt; install.packages("GPArotation")</strong> <strong class="calibre2">&gt; library(psych)</strong> </pre> </div></li><li class="listitem" value="2">然后可以使用<code class="email">principal</code>函数来检索主成分:<div> <pre class="programlisting"> <strong class="calibre2">&gt; swiss.principal = principal(swiss, nfactors=5, rotate="none")</strong> <strong class="calibre2">&gt; swiss.principal</strong> <strong class="calibre2">Principal Components Analysis</strong> <strong class="calibre2">Call: principal(r = swiss, nfactors = 5, rotate = "none")</strong> <strong class="calibre2">Standardized loadings (pattern matrix) based upon correlation matrix</strong> <strong class="calibre2">                   PC1   PC2   PC3   PC4   PC5 h2       u2</strong> <strong class="calibre2">Agriculture      -0.85 -0.27  0.00  0.45 -0.03  1 -6.7e-16</strong> <strong class="calibre2">Examination       0.93 -0.01 -0.04  0.24  0.29  1  4.4e-16</strong> <strong class="calibre2">Education         0.80  0.20  0.49  0.19 -0.23  1  2.2e-16</strong> <strong class="calibre2">Catholic         -0.63  0.38  0.66 -0.06  0.17  1 -2.2e-16</strong> <strong class="calibre2">Infant.Mortality -0.15  0.90 -0.38  0.12 -0.03  1 -8.9e-16</strong>  <strong class="calibre2">                       PC1  PC2  PC3  PC4  PC5</strong> <strong class="calibre2">SS loadings           2.63 1.07 0.82 0.31 0.17</strong> <strong class="calibre2">Proportion Var        0.53 0.21 0.16 0.06 0.03</strong> <strong class="calibre2">Cumulative Var        0.53 0.74 0.90 0.97 1.00</strong> <strong class="calibre2">Proportion Explained  0.53 0.21 0.16 0.06 0.03</strong> <strong class="calibre2">Cumulative Proportion 0.53 0.74 0.90 0.97 1.00</strong>  <strong class="calibre2">Test of the hypothesis that 5 components are sufficient.</strong>  <strong class="calibre2">The degrees of freedom for the null model are 10 and the objective function was 2.13</strong> <strong class="calibre2">The degrees of freedom for the model are -5  and the objective function was  0 </strong> <strong class="calibre2">The total number of observations was  47  with MLE Chi Square =  0  with prob &lt;  NA </strong>  <strong class="calibre2">Fit based upon off diagonal values = 1</strong> </pre> </div></li><li class="listitem" value="3"><a id="ch11lvl1sec124" class="calibre1"/>使用scree测试确定主成分的数量</li></ol><div/></div><p class="calibre7">由于我们<a id="id895" class="calibre1"/>只需要保留说明原始特征大部分变化的主要成分，我们可以使用Kaiser方法、scree测试或解释为选择标准的变化百分比。碎石测试的主要目的是将成分分析结果绘制成碎石图，并找出坡度(弯头)发生明显变化的位置。在本食谱中，我们将演示如何使用碎石图确定主要成分的数量。</p><div><ol class="orderedlist"><li class="listitem" value="1"><a id="ch11lvl2sec429" class="calibre1"/>准备就绪</li><li class="listitem" value="2">通过生成主成分对象并将其保存在变量<code class="email">swiss.pca</code>中，确保您已经完成了之前的配方。</li></ol><div/></div></div></div></body></html>


<html>
  <head>
    <title>Determining the number of principal components using the scree test</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div/><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch11lvl2sec430" class="calibre1"/>怎么做...</h1></div></div></div><p class="calibre7">执行<a id="id896" class="calibre1"/>以下步骤，用碎石图确定主成分的数量:</p></div></body></html>


<html>
  <head>
    <title>Determining the number of principal components using the scree test</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_1">条形图形式的碎石图</h2></div></div></div><p class="calibre7">Ensure that you have completed the previous recipe by generating a principal component object and save it in the variable, <code class="email">swiss.pca</code>.</p></div></div></body></html>


<html>
  <head>
    <title>Determining the number of principal components using the scree test</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_2">线形图形式的碎石图</h2></div></div></div><p class="calibre7">Perform <a id="id896" class="calibre1"/>the following steps to determine the number of principal components with the scree plot:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, you can generate a bar plot by using <code class="email">screeplot</code>:<div><pre class="programlisting">
<strong class="calibre2">&gt; screeplot(swiss.pca, type="barplot")</strong>
</pre></div><div><img src="img/00225.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12"><a id="ch11lvl2sec431" class="calibre1"/>工作原理...</p></div></div><p class="calibre13">在这个<a id="id897" class="calibre1"/>配方中，我们演示了如何使用scree图来确定主要成分的数量。在碎石图中，有两种类型的图，即条形图和线形图。正如两个生成的碎石图所示，坡度的明显变化(所谓的肘或膝)发生在构件2处。因此，我们应该保留分量1，在分量2之前，分量1处于陡峭的曲线中，分量2是平坦线趋势开始的地方。但是，由于这种方法可能不明确，您可以使用其他方法(如Kaiser方法)来确定组件的数量。</p></li><li class="listitem" value="2">You can also generate a line plot by using <code class="email">screeplot</code>:<div><pre class="programlisting">
<strong class="calibre2">&gt; screeplot(swiss.pca, type="line")</strong>
</pre></div><div><img src="img/00226.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12"><a id="ch11lvl2sec432" class="calibre1"/>还有更多...</p></div></div><p class="calibre13">默认情况下，如果您在生成的主成分对象上使用<code class="email">plot</code>功能，您也可以检索scree图。有关<code class="email">screeplot</code>的更多详情，请参考以下文件:</p></li></ol><div/></div></div></div></body></html>


<html>
  <head>
    <title>Determining the number of principal components using the scree test</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_3">您还可以使用<code class="email">nfactors</code>对Cattell scree测试进行平行分析和非图形解决方案:</h2></div></div></div><p class="calibre7">scree测试的非图形解决方案</p></div></div></body></html>


<html>
  <head>
    <title>Determining the number of principal components using the scree test</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch11lvl2sec432" class="calibre1"/>There's more...</h2></div></div></div><p class="calibre7"><a id="ch11lvl1sec125" class="calibre1"/>使用Kaiser方法确定主成分的数量</p><div><pre class="programlisting">
<strong class="calibre2">&gt; help(screeplot)</strong>
</pre></div><p class="calibre7">除了scree测试，您可以使用Kaiser方法来确定主要<a id="id898" class="calibre1"/>组件的数量。在这种方法中，选择标准保留大于<code class="email">1</code>的特征值。在本食谱中，我们将演示如何使用Kaiser方法确定主成分的数量。</p><div><pre class="programlisting">
<strong class="calibre2">&gt; install.packages("nFactors")</strong>
<strong class="calibre2">&gt; library(nFactors)</strong>
<strong class="calibre2">&gt; ev = eigen(cor(swiss))</strong>
<strong class="calibre2">&gt; ap = parallel(subject=nrow(swiss),var=ncol(swiss),rep=100,cent=.05)</strong>
<strong class="calibre2">&gt; nS = nScree(x=ev$values, aparallel=ap$eigen$qevpea)</strong>
<strong class="calibre2">&gt; plotnScree(nS)</strong>
</pre></div><div><img src="img/00227.jpeg" alt="There's more..." class="calibre9"/><div><p class="calibre12">准备就绪</p></div></div><p class="calibre10">通过生成主成分对象并将其保存在变量<code class="email">swiss.pca</code>中，确保您已经完成了之前的配方。</p></div></div></body></html>


<html>
  <head>
    <title>Determining the number of principal components using the Kaiser method</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div/><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch11lvl2sec434" class="calibre1"/>怎么做...</h1></div></div></div><p class="calibre7">执行以下步骤，用Kaiser <a id="id899" class="calibre1"/>方法确定主成分的数量:</p></div></body></html>


<html>
  <head>
    <title>Determining the number of principal components using the Kaiser method</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_1">首先可以从<code class="email">swiss.pca</code> : <div> <pre class="programlisting"> <strong class="calibre2">&gt; swiss.pca$sdev </strong> <strong class="calibre2">[1] 1.6228065 1.0354873 0.9033447 0.5592765 0.4067472</strong> </pre> </div>获得标准差</h2></div></div></div><p class="calibre7">接下来，您可以从<code class="email">swiss.pca</code> : <div> <pre class="programlisting"> <strong class="calibre2">&gt; swiss.pca$sdev ^ 2</strong> <strong class="calibre2">[1] 2.6335008 1.0722340 0.8160316 0.3127902 0.1654433</strong> </pre> </div>获得方差</p></div></div></body></html>


<html>
  <head>
    <title>Determining the number of principal components using the Kaiser method</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_2">选择方差大于1的组件:<div> <pre class="programlisting"> <strong class="calibre2">&gt; which(swiss.pca$sdev ^ 2&gt; 1)</strong> <strong class="calibre2">[1] 1 2</strong> </pre> </div></h2></div></div></div><p class="calibre7">选择方差大于1的分量</p><div><ol class="orderedlist"><li class="listitem" value="1">First, you can obtain the standard deviation from <code class="email">swiss.pca</code>:<div><pre class="programlisting">
<strong class="calibre2">&gt; swiss.pca$sdev </strong>
<strong class="calibre2">[1] 1.6228065 1.0354873 0.9033447 0.5592765 0.4067472</strong>
</pre></div></li><li class="listitem" value="2"><a id="ch11lvl2sec435" class="calibre1"/>工作原理...</li><li class="listitem" value="3">你也可以使用Kaiser方法来确定组件的数量。由于计算的主成分对象包含每个成分的标准差，我们可以<a id="id900" class="calibre1"/>将方差计算为标准差，也就是方差的平方根。根据计算的方差，我们发现组件1和2的方差都大于1。因此，我们可以确定主成分数为2(成分1和成分2)。此外，我们可以在碎石图上画一条红线(如上图所示),表示在这种情况下我们需要保留构件1和2。</li><li class="listitem" value="4">You can also use the scree plot to select components with a variance above 1:<div><pre class="programlisting">
<strong class="calibre2">&gt; screeplot(swiss.pca, type="line")</strong>
<strong class="calibre2">&gt; abline(h=1, col="red", lty= 3)</strong>
</pre></div><div><img src="img/00228.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12"><a id="ch11lvl2sec436" class="calibre1"/>参见</p></div></div><p class="calibre13">为了确定要保留哪些主要成分，请参考:</p></li></ol><div/></div></div></div></body></html>


<html>
  <head>
    <title>Determining the number of principal components using the Kaiser method</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_3">莱德斯马博士和瓦莱罗-莫拉博士(2007年)。<em class="calibre8">确定EFA中保留的因子数量:一个易于使用的计算机程序，用于进行平行分析</em>。<em class="calibre8">实践评估，调研&amp;评估</em>，12(2)，1-11。</h2></div></div></div><p class="calibre7"><a id="ch11lvl1sec126" class="calibre1"/>使用双标图可视化多元数据</p></div></div></body></html>


<html>
  <head>
    <title>Determining the number of principal components using the Kaiser method</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_4">为了<a id="id901" class="calibre1"/>找出数据和变量如何<a id="id902" class="calibre1"/>映射到主成分，您可以使用<code class="email">biplot</code>，它将数据和原始特征的投影绘制到前两个成分上。在这个菜谱中，我们将演示如何使用<code class="email">biplot</code>在同一个图上绘制变量和数据。</h2></div></div></div><p class="calibre7">准备就绪</p><div><ul class="itemizedlist"><li class="listitem">通过生成主成分对象并将其保存在变量<code class="email">swiss.pca</code>中，确保您已经完成了之前的配方。</li></ul></div></div></div></body></html>


<html>
  <head>
    <title>Visualizing multivariate data using biplot</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div/><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch11lvl2sec438" class="calibre1"/>怎么做...</h1></div></div></div><p class="calibre7">执行以下步骤创建双绘图:</p></div></body></html>


<html>
  <head>
    <title>Visualizing multivariate data using biplot</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_1">PCA结果的前两个成分的散点图</h2></div></div></div><p class="calibre7">Ensure that you have completed the previous recipe by generating a principal component object and save it in the variable, <code class="email">swiss.pca</code>.</p></div></div></body></html>


<html>
  <head>
    <title>Visualizing multivariate data using biplot</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_2">使用PCA结果的双标图</h2></div></div></div><p class="calibre7">Perform the following steps to create a biplot:</p><div><ol class="orderedlist"><li class="listitem" value="1">You can create a scatter plot using component 1 and 2:<div><pre class="programlisting">
<strong class="calibre2">&gt;  plot(swiss.pca$x[,1], swiss.pca$x[,2], xlim=c(-4,4))</strong>
<strong class="calibre2">&gt; text(swiss.pca$x[,1], swiss.pca$x[,2], rownames(swiss.pca$x), cex=0.7, pos=4, col="red")</strong>
</pre></div><div><img src="img/00229.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12"><a id="ch11lvl2sec439" class="calibre1"/>工作原理...</p></div></div><p class="calibre13">在这个<a id="id905" class="calibre1"/>配方中，我们演示了如何使用<code class="email">biplot</code>到<a id="id906" class="calibre1"/>将原始特征的数据和投影绘制到前两个组件上。在第一步中，我们演示了我们实际上可以使用前两个组件来创建散点图。此外，如果想在同一个图上添加变量，可以使用<code class="email">biplot</code>。在<code class="email">biplot</code>中，您可以看到农业变量中指标较高的省份，教育变量中指标较低的省份，以及PC1中得分较高的考试变量。另一方面，婴儿死亡率指标较高和农业指标较低的省份在PC2中得分较高。</p></li><li class="listitem" value="2">If <a id="id903" class="calibre1"/>you would like to add features <a id="id904" class="calibre1"/>on the plot, you can create biplot using the generated principal component object:<div><pre class="programlisting">
<strong class="calibre2">&gt; biplot(swiss.pca)</strong>
</pre></div><div><img src="img/00230.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12"><a id="ch11lvl2sec440" class="calibre1"/>还有更多...</p></div></div><p class="calibre13">除了<code class="email">stats</code>包里的<code class="email">biplot</code>，还可以用<code class="email">ggbiplot</code>。但是，你可能找不到克兰的这个包裹；你必须先安装<code class="email">devtools</code>，然后从GitHub安装<code class="email">ggbiplot</code>:</p></li></ol><div/></div></div></div></body></html>


<html>
  <head>
    <title>Visualizing multivariate data using biplot</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_3">使用PCA结果的ggbiplot</h2></div></div></div><p class="calibre7">In this<a id="id905" class="calibre1"/> recipe, we demonstrate how to use <code class="email">biplot</code> to <a id="id906" class="calibre1"/>plot data and projections of original features on to the first two components. In the first step, we demonstrate that we can actually use the first two components to create a scatter plot. Furthermore, if you want to add variables on the same plot, you can use <code class="email">biplot</code>. In <code class="email">biplot</code>, you can see the provinces with higher indicators in the agriculture variable, lower indicators in the education variable, and examination variables scores that are higher in PC1. On the other hand, the provinces with higher infant mortality indicators and lower agriculture indicators score higher in PC2.</p></div></div></body></html>


<html>
  <head>
    <title>Visualizing multivariate data using biplot</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch11lvl1sec127" class="calibre1"/>使用MDS进行降维</h2></div></div></div><p class="calibre7"><strong class="calibre2">多维缩放</strong> ( <strong class="calibre2"> MDS </strong>)是一种创建多个对象的相似性<a id="id907" class="calibre1"/>或不相似性(距离)的视觉呈现的技术。<em class="calibre8">多</em>前缀表示用户可以创建一个、两个或多个维度的呈现<a id="id908" class="calibre1"/>地图。然而，我们最常用MDS来表示一维或二维数据点之间的距离。</p><div><pre class="programlisting">
<strong class="calibre2">&gt; install.packages("devtools")</strong>

<strong class="calibre2">&gt; library(ggbiplot)</strong>
<strong class="calibre2">&gt; g = ggbiplot(swiss.pca, obs.scale = 1, var.scale = 1, </strong>
<strong class="calibre2">+ ellipse = TRUE, </strong>
<strong class="calibre2">+ circle = TRUE)</strong>
<strong class="calibre2">&gt; print(g)</strong>
</pre></div><div><img src="img/00231.jpeg" alt="There's more..." class="calibre9"/><div><p class="calibre12">在MDS，你可以使用度量或非度量的解决方案。这两种解决方案的主要区别在于，度量解决方案试图重现原始度量，而非度量解决方案则假设距离的等级是已知的。在这个菜谱中，我们将说明如何在<code class="email">swiss</code>数据集上执行MDS。</p></div></div><p class="calibre10">做好准备</p></div></div></body></html>


<html>
  <head>
    <title>Performing dimension reduction with MDS</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div/><div><div><div><div><h1 class="title" id="calibre_pb_0">在这个菜谱中，我们将继续使用<code class="email">swiss</code>数据集作为输入数据源。</h1></div></div></div><p class="calibre7"><a id="ch11lvl2sec442" class="calibre1"/>怎么做...</p><p class="calibre7">执行<a id="id909" class="calibre1"/>以下步骤，使用公制方法执行<a id="id910" class="calibre1"/>多维缩放:</p></div></body></html>


<html>
  <head>
    <title>Performing dimension reduction with MDS</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_1">首先，您可以使用最多两个维度执行公制MDS:<div><pre class="programlisting"> <strong class="calibre2">&gt; swiss.dist =dist(swiss)</strong> <strong class="calibre2">&gt; swiss.mds = cmdscale(swiss.dist, k=2)</strong> </pre></div></h2></div></div></div><p class="calibre7">cmdscale对象的二维散点图</p></div></div></body></html>


<html>
  <head>
    <title>Performing dimension reduction with MDS</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_2">此外，您可以使用<code class="email">isoMDS</code> : <div> <pre class="programlisting"> <strong class="calibre2">&gt; library(MASS)</strong> <strong class="calibre2">&gt; swiss.nmmds = isoMDS(swiss.dist, k=2)</strong> <strong class="calibre2">initial  value 2.979731 </strong> <strong class="calibre2">iter   5 value 2.431486</strong> <strong class="calibre2">iter  10 value 2.343353</strong> <strong class="calibre2">final  value 2.338839 </strong> <strong class="calibre2">converged</strong> </pre> </div>执行非计量MDS</h2></div></div></div><p class="calibre7">isoMDS物体的二维散点图</p><div><ol class="orderedlist"><li class="listitem" value="1">First, you can perform metric MDS with a maximum of two dimensions:<div><pre class="programlisting">
<strong class="calibre2">&gt; swiss.dist =dist(swiss)</strong>
<strong class="calibre2">&gt; swiss.mds = cmdscale(swiss.dist, k=2)</strong>
</pre></div></li><li class="listitem" value="2">You can then plot the <code class="email">swiss</code> data in a two-dimension scatter plot:<div><pre class="programlisting">
<strong class="calibre2">&gt; plot(swiss.mds[,1], swiss.mds[,2], type = "n", main = "cmdscale (stats)")</strong>
<strong class="calibre2">&gt; text(swiss.mds[,1], swiss.mds[,2], rownames(swiss), cex = 0.9, xpd = TRUE)</strong>
</pre></div><div><img src="img/00232.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12">isoMDS对象中的Shepard图</p></div></div><p class="calibre13"> </p></li><li class="listitem" value="3"><a id="ch11lvl2sec443" class="calibre1"/>工作原理...</li><li class="listitem" value="4">You <a id="id911" class="calibre1"/>can also plot the <a id="id912" class="calibre1"/>data points in a two-dimension scatter plot:<div><pre class="programlisting">
<strong class="calibre2">&gt; plot(swiss.nmmds$points, type = "n", main = "isoMDS (MASS)")</strong>
<strong class="calibre2">&gt; text(swiss.nmmds$points, rownames(swiss), cex = 0.9, xpd = TRUE)</strong>
</pre></div><div><img src="img/00233.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12">MDS通过提供一组<a id="id913" class="calibre1"/>对象之间相似性的视觉呈现来揭示数据的结构。更详细地说，MDS将一个物体放置在n维空间中，其中成对的<a id="id914" class="calibre1"/>点之间的距离对应于成对物体之间的相似性。通常，维空间是二维欧几里得空间，但是它可以是非欧几里得的，并且具有两个以上的维度。根据输入矩阵的含义，MDS主要可以分为两种类型:度量MDS，其中输入矩阵是基于度量的，非度量MDS，其中输入矩阵是非基于度量的。</p></div></div><p class="calibre13">公制MDS也称为主坐标分析，它首先将距离转换为相似性。在最简单的形式中，该过程通过对相似性执行主成分分析来将原始数据点线性投影到子空间。另一方面，该过程还可以通过最小化应力值<img src="img/00235.jpeg" alt="How it works..." class="calibre24"/>来执行相似性的非线性投影，其中<img src="img/00236.jpeg" alt="How it works..." class="calibre24"/>是两个点<img src="img/00237.jpeg" alt="How it works..." class="calibre24"/>和<img src="img/00238.jpeg" alt="How it works..." class="calibre24"/>之间的距离度量，并且<img src="img/00239.jpeg" alt="How it works..." class="calibre24"/>是两个投影点<img src="img/00240.jpeg" alt="How it works..." class="calibre24"/>和<img src="img/00241.jpeg" alt="How it works..." class="calibre24"/>的相似性度量。因此，我们可以在欧几里得空间中表示对象之间的关系。</p></li><li class="listitem" value="5">You can then plot the data points in a two-dimension scatter plot:<div><pre class="programlisting">
<strong class="calibre2">&gt; swiss.sh = Shepard(swiss.dist, swiss.mds)</strong>
<strong class="calibre2">&gt; plot(swiss.sh, pch = ".")</strong>
<strong class="calibre2">&gt; lines(swiss.sh$x, swiss.sh$yf, type = "S")</strong>
</pre></div><div><img src="img/00234.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12">在<a id="id915" class="calibre1"/>中，与使用基于度量的输入矩阵的度量MDS相比，<a id="id916" class="calibre1"/>在序数级别测量数据时，使用基于非度量的MDS。因为只有向量之间距离的等级顺序才有意义，所以非度量MDS对原始距离应用单调递增函数f，并将距离投影到保持等级顺序的新值。归一化的方程可以表示为<img src="img/00242.jpeg" alt="How it works..." class="calibre24"/>。</p></div></div><p class="calibre13">在这个配方中，我们说明了如何在<code class="email">swiss</code>数据集上执行度量和非度量MDS。为了执行度量MDS，我们首先需要从<code class="email">swiss</code>数据中获得距离度量。在这一步中，您可以将距离度量替换为任何度量，只要它能产生数据点的相似性/不相似性度量。您可以使用<code class="email">cmdscale</code>来执行度量多维缩放。这里，我们指定<code class="email">k = 2</code>，所以最大生成尺寸等于<code class="email">2</code>。您还可以在二维散点图上直观地显示数据点的距离。</p></li></ol><div/></div></div></div></body></html>


<html>
  <head>
    <title>Performing dimension reduction with MDS</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_3">接下来，您可以使用<code class="email">isoMDS</code>执行非度量MDS。在非度规MDS中，我们不匹配距离，而只是按顺序排列它们。我们还将<code class="email">swiss</code>设置为最大维度为2的输入数据集。与公制MDS的例子类似，我们可以在二维散点图上绘制数据点之间的距离。然后，我们使用Shepard图，该图显示了投影距离与距离矩阵中的距离的匹配程度。根据步骤4中的图，投影距离在距离矩阵中匹配良好。</h2></div></div></div><p class="calibre7"><a id="ch11lvl2sec444" class="calibre1"/>还有更多...</p><p class="calibre7">另一种可视化方法是将MDS对象呈现为图形。下面列出了一个示例代码:</p><p class="calibre7">MDS物体的图形表示</p><p class="calibre7">In this recipe, we illustrate how to perform metric and nonmetric MDS on the <code class="email">swiss</code> dataset. To perform metric MDS, we first need to obtain the distance metric from the <code class="email">swiss</code> data. In this step, you can replace the distance measure to any measure as long as it produces a similarity/dissimilarity measure of data points. You can use <code class="email">cmdscale</code> to perform metric multidimensional scaling. Here, we specify <code class="email">k = 2</code>, so the maximum generated dimensions equals <code class="email">2</code>. You can also visually present the distance of the data points on a two-dimensional scatter plot.</p><p class="calibre7">您<a id="id917" class="calibre1"/>还可以比较MDS和PCA生成的结果之间的差异<a id="id918" class="calibre1"/>。您可以通过在同一散点图上绘制投影尺寸来比较它们的差异。如果在MDS上使用欧几里得距离，则投影的尺寸与从PCA投影的尺寸完全相同:</p></div></div></body></html>


<html>
  <head>
    <title>Performing dimension reduction with MDS</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_4">MDS与主成分分析的比较</h2></div></div></div><p class="calibre7">Another visualization method is to present an MDS object as a graph. A sample code is listed here:</p><div><pre class="programlisting">
<strong class="calibre2">&gt; library(igraph)</strong>
<strong class="calibre2">&gt; swiss.sample = swiss[1:10,]</strong>

<strong class="calibre2">&gt; g = graph.full(nrow(swiss.sample))</strong>
<strong class="calibre2">&gt; V(g)$label = rownames(swiss.sample)</strong>
<strong class="calibre2">&gt; layout = layout.mds(g, dist = as.matrix(dist(swiss.sample)))</strong>
<strong class="calibre2">&gt; plot(g, layout = layout, vertex.size = 3)</strong>
</pre></div><div><img src="img/00243.jpeg" alt="There's more..." class="calibre9"/><div><p class="calibre12"><a id="ch11lvl1sec128" class="calibre1"/>使用奇异值分解降低维数</p></div></div><p class="calibre10"><strong class="calibre2">奇异值分解</strong> ( <strong class="calibre2"> SVD </strong>)是矩阵分解(分解)的一种，可以<a id="id919" class="calibre1"/>将矩阵分解为两个正交矩阵和对角<a id="id920" class="calibre1"/>矩阵。你可以用这三个矩阵把<a id="id921" class="calibre1"/>原始矩阵乘回去。从线性代数的角度来看，奇异值分解可以减少线性相关的冗余数据。因此，它可以应用于特征选择、图像处理、聚类等许多领域。在这个食谱中，我们将说明如何用奇异值分解进行降维。</p><p class="calibre7">准备就绪</p><div><pre class="programlisting">
<strong class="calibre2">&gt; swiss.dist = dist(swiss)</strong>
<strong class="calibre2">&gt; swiss.mds = cmdscale(swiss.dist, k=2)</strong>
<strong class="calibre2">&gt; plot(swiss.mds[,1], swiss.mds[,2], type="n")</strong>
<strong class="calibre2">&gt; text(swiss.mds[,1], swiss.mds[,2], rownames(swiss), cex = 0.9, xpd = TRUE)</strong>
<strong class="calibre2">&gt; swiss.pca = prcomp(swiss)</strong>
<strong class="calibre2">&gt; text(-swiss.pca$x[,1],-swiss.pca$x[,2], rownames(swiss), </strong>
<strong class="calibre2">+      ,col="blue", adj = c(0.2,-0.5),cex = 0.9, xpd = TRUE)</strong>
</pre></div><div><img src="img/00244.jpeg" alt="There's more..." class="calibre9"/><div><p class="calibre12">在这个菜谱中，我们将继续使用数据集<code class="email">swiss</code>作为输入数据源。</p></div></div><p class="calibre10">如何做到这一点...</p></div></div></body></html>


<html>
  <head>
    <title>Reducing dimensions with SVD</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div/><div><div><div><div><h1 class="title" id="calibre_pb_0">执行以下步骤，使用奇异值分解进行降维:</h1></div></div></div><p class="calibre7">首先可以对<code class="email">swiss</code>数据集执行<code class="email">svd</code>:<div><pre class="programlisting"> <strong class="calibre2">&gt; swiss.svd = svd(swiss)</strong> </pre></div></p></div></body></html>


<html>
  <head>
    <title>Reducing dimensions with SVD</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_1">解释的差异百分比</h2></div></div></div><p class="calibre7">In this recipe, we will continue using the dataset, <code class="email">swiss</code>, as our input data source.</p></div></div></body></html>


<html>
  <head>
    <title>Reducing dimensions with SVD</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch11lvl2sec446" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre7">解释的累计差异百分比</p><div><ol class="orderedlist"><li class="listitem" value="1">First, you can perform <code class="email">svd</code> on the <code class="email">swiss</code> dataset:<div><pre class="programlisting">
<strong class="calibre2">&gt; swiss.svd = svd(swiss)</strong>
</pre></div></li><li class="listitem" value="2">You can then plot the percentage of variance explained and the cumulative variance <a id="id922" class="calibre1"/>explained in accordance<a id="id923" class="calibre1"/> with the SVD column:<div><pre class="programlisting">
<strong class="calibre2">&gt; plot(swiss.svd$d^2/sum(swiss.svd$d^2), type="l", xlab=" Singular vector", ylab = "Variance explained")</strong>
</pre></div><div><img src="img/00245.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12">The percent of variance explained</p></div></div><p class="calibre13">接下来，你<a id="id924" class="calibre1"/>可以重建<a id="id925" class="calibre1"/>只有一个奇异向量的数据:<div> <pre class="programlisting"> <strong class="calibre2">&gt; swiss.recon = swiss.svd$u[,1] %*% diag(swiss.svd$d[1], length(1), length(1)) %*% t(swiss.svd$v[,1])</strong> </pre> </div></p><div><pre class="programlisting">
<strong class="calibre2">&gt; plot(cumsum(swiss.svd$d^2/sum(swiss.svd$d^2)), type="l", xlab="Singular vector", ylab = "Cumulative percent of variance explained")</strong>
</pre></div><p class="calibre26">原始数据集和重建数据集的比较</p><div><img src="img/00246.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12">Cumulative percent of variance explained</p></div></div><p class="calibre13"><a id="ch11lvl2sec447" class="calibre1"/>工作原理...</p><p class="calibre26">SVD是实矩阵或复矩阵的因式分解。详细来说，m×n矩阵A的SVD就是把A分解成三个矩阵的乘积，<img src="img/00248.jpeg" alt="How it works..." class="calibre24"/>。这里，U是m×m正交矩阵，D具有奇异值并且是m×n对角矩阵，V <sup class="calibre27"> T </sup>是n×n正交矩阵。</p></li><li class="listitem" value="3">在这个食谱中，我们演示了如何用奇异值分解进行降维。首先，您可以在<code class="email">swiss</code>数据集上应用<code class="email">svd</code>函数来获得分解后的矩阵。然后，您可以生成两个图:一个显示根据单一向量解释的方差，另一个显示根据单一向量解释的累积方差。</li><li class="listitem" value="4">Lastly, you can compare the original dataset with the constructed dataset in an image:<div><pre class="programlisting">
<strong class="calibre2">&gt; par(mfrow=c(1,2))</strong>
<strong class="calibre2">&gt; image(as.matrix(swiss), main="swiss data Image")</strong>
<strong class="calibre2">&gt; image(swiss.recon,  main="Reconstructed Image")</strong>
</pre></div><div><img src="img/00247.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12">上图显示，第一个奇异向量可以解释80%的方差。我们现在想要比较原始数据集和具有单个奇异向量的重建数据集的差异。因此，我们使用<a id="id928" class="calibre1"/>单个奇异向量重建数据，并使用<code class="email">image</code>函数并排显示原始数据集和重建数据集，并观察<a id="id929" class="calibre1"/>它们之间的差异。下图显示这两幅图像非常相似。</p></div></div><p class="calibre13"><a id="ch11lvl2sec448" class="calibre1"/>亦见</p></li></ol><div/></div></div></div></body></html>


<html>
  <head>
    <title>Reducing dimensions with SVD</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_3">正如我们前面提到的，主成分分析可以看作是奇异值分解的一个特例。这里，我们从SVD的<code class="email">swiss</code>数据生成正交向量，并从<code class="email">prcomp</code>获得旋转。我们可以看到生成的两个矩阵是一样的:<div> <pre class="programlisting"> <strong class="calibre2">&gt; svd.m = svd(scale(swiss))</strong> <strong class="calibre2">&gt; svd.m$v</strong> <strong class="calibre2">            [,1]        [,2]         [,3]       [,4]        [,5]</strong> <strong class="calibre2">[1,]  0.52396452 -0.25834215  0.003003672 -0.8090741  0.06411415</strong> <strong class="calibre2">[2,] -0.57185792 -0.01145981 -0.039840522 -0.4224580 -0.70198942</strong> <strong class="calibre2">[3,] -0.49150243  0.19028476  0.539337412 -0.3321615  0.56656945</strong> <strong class="calibre2">[4,]  0.38530580  0.36956307  0.725888143  0.1007965 -0.42176895</strong> <strong class="calibre2">[5,]  0.09167606  0.87197641 -0.424976789 -0.2154928  0.06488642</strong> <strong class="calibre2">&gt; pca.m = prcomp(swiss,scale=TRUE)</strong> <strong class="calibre2">&gt; pca.m$rotation</strong> <strong class="calibre2">                         PC1         PC2          PC3        PC4         PC5</strong> <strong class="calibre2">Agriculture      0.52396452 -0.25834215  0.003003672 -0.8090741  0.06411415</strong> <strong class="calibre2">Examination  -0.57185792 -0.01145981 -0.039840522 -0.4224580 -0.70198942</strong> <strong class="calibre2">Education       -0.49150243  0.19028476  0.539337412 -0.3321615  0.56656945</strong> <strong class="calibre2">Catholic          0.38530580  0.36956307  0.725888143  0.1007965 -0.42176895</strong> <strong class="calibre2">Infant.Mortality 0.09167606 0.87197641 -0.424976789 -0.2154928 0.06488642</strong> </pre> </div></h2></div></div></div><p class="calibre7"><a id="ch11lvl1sec129" class="calibre1"/>用奇异值分解压缩图像</p><p class="calibre7">在上一个配方中，我们演示了如何用SVD分解矩阵，然后通过乘以分解的矩阵来重建数据集。此外，矩阵<a id="id930" class="calibre1"/>分解的应用可以应用于图像<a id="id931" class="calibre1"/>压缩。在这个菜谱中，我们将演示如何在经典的图像处理材料Lenna上执行SVD。</p><p class="calibre7"><a id="ch11lvl2sec449" class="calibre1"/>做好准备</p></div></div></body></html>


<html>
  <head>
    <title>Reducing dimensions with SVD</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_4">在这个食谱中，你应该预先下载Lenna的图像(参见<a class="calibre1" href="http://www.ece.rice.edu/~wakin/images/lena512.bmp">http://www.ece.rice.edu/~wakin/images/lena512.bmp</a>)，或者你可以准备一个你自己的图像来看看图像压缩是如何工作的。</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem"><a id="ch11lvl2sec450" class="calibre1"/>怎么做...</li></ul></div></div></div></body></html>


<html>
  <head>
    <title>Compressing images with SVD</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div/><div><div><div><div><h1 class="title" id="calibre_pb_0">执行以下步骤用SVD压缩图像:</h1></div></div></div><p class="calibre7">首先，安装并加载<code class="email">bmp</code> : <div> <pre class="programlisting"> <strong class="calibre2">&gt; install.packages("bmp")</strong> <strong class="calibre2">&gt; library(bmp)</strong> </pre> </div></p></div></body></html>


<html>
  <head>
    <title>Compressing images with SVD</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_1">然后，您可以使用<code class="email">read.bmp</code>函数将Lenna的图像作为数字矩阵读取。阅读器下载图片时，默认名称为<code class="email">lena512.bmp</code> : <div> <pre class="programlisting"> <strong class="calibre2">&gt; lenna = read.bmp("lena512.bmp")</strong> </pre> </div></h2></div></div></div><p class="calibre7">蕾娜的照片</p></div></div></body></html>


<html>
  <head>
    <title>Compressing images with SVD</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch11lvl2sec450" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre7">解释的差异百分比</p><div><ol class="orderedlist"><li class="listitem" value="1">First, install and load <code class="email">bmp</code>:<div><pre class="programlisting">
<strong class="calibre2">&gt; install.packages("bmp")</strong>
<strong class="calibre2">&gt; library(bmp)</strong>
</pre></div></li><li class="listitem" value="2">接下来，您<a id="id934" class="calibre1"/>可以获得<a id="id935" class="calibre1"/>的维数来重建图像:<div> <pre class="programlisting"> <strong class="calibre2">&gt; length(lenna.svd$d)</strong> <strong class="calibre2">[1] 512</strong> </pre> </div></li><li class="listitem" value="3">Rotate and plot the image:<div><pre class="programlisting">
<strong class="calibre2">&gt; lenna = t(lenna)[,nrow(lenna):1]</strong>
<strong class="calibre2">&gt; image(lenna) </strong>
</pre></div><div><img src="img/00249.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12">求奇异向量能解释90%以上方差的点:<div> <pre class="programlisting"> <strong class="calibre2">&gt; min(which(cumsum(lenna.svd$d^2/sum(lenna.svd$d^2))&gt; 0.9))</strong> <strong class="calibre2">[1] 18</strong> </pre> </div></p></div></div><p class="calibre13">您也可以将代码包装到函数<code class="email">lenna_compression</code>中，然后使用该函数绘制压缩的Lenna: <div> <pre class="programlisting"> <strong class="calibre2">&gt; lenna_compression = function(dim){</strong> <strong class="calibre2">+     u=as.matrix(lenna.svd$u[, 1:dim])</strong> <strong class="calibre2">+     v=as.matrix(lenna.svd$v[, 1:dim])</strong> <strong class="calibre2">+     d=as.matrix(diag(lenna.svd$d)[1:dim, 1:dim])</strong> <strong class="calibre2">+     image(u%*%d%*%t(v))</strong> <strong class="calibre2">+ }</strong> </pre> </div></p></li><li class="listitem" value="4">Next, you <a id="id932" class="calibre1"/>can perform SVD on the read <a id="id933" class="calibre1"/>numeric matrix and plot the percentage of variance explained:<div><pre class="programlisting">
<strong class="calibre2">&gt; lenna.svd = svd(scale(lenna))</strong>
<strong class="calibre2">&gt; plot(lenna.svd$d^2/sum(lenna.svd$d^2), type="l", xlab=" Singular vector", ylab = "Variance explained")</strong>
</pre></div><div><img src="img/00250.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12">具有18个分量的重建图像</p></div></div><p class="calibre13"> </p></li><li class="listitem" value="5">具有92个分量的重建图像</li><li class="listitem" value="6">Obtain the point at which the singular vector can explain more than 90 percent of the variance:<div><pre class="programlisting">
<strong class="calibre2">&gt; min(which(cumsum(lenna.svd$d^2/sum(lenna.svd$d^2))&gt; 0.9))</strong>
<strong class="calibre2">[1] 18</strong>
</pre></div></li><li class="listitem" value="7"><a id="ch11lvl2sec451" class="calibre1"/>工作原理...</li><li class="listitem" value="8">Also, you can use 18 vectors to reconstruct the image:<div><pre class="programlisting">
<strong class="calibre2">&gt; lenna_compression(18)</strong>
</pre></div><div><img src="img/00251.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12">在这个<a id="id938" class="calibre1"/>食谱中，我们演示了如何用SVD压缩<a id="id939" class="calibre1"/>一幅图像。在第一步中，我们使用包<code class="email">bmp</code>将Lenna映像加载到R会话中。然后，随着读取图像的旋转，我们可以将图像旋转回来，并使用<code class="email">plot</code>函数在R中绘制Lenna(如步骤3中的图所示)。接下来，我们对图像矩阵执行SVD以分解矩阵。然后我们根据奇异向量的数量绘制方差的百分比。</p></div></div><p class="calibre13">此外，当我们发现我们可以用18个成分来解释90%的差异时，我们就用这18个成分来重建Lenna。因此，我们创建一个名为<code class="email">lenna_compression</code>的函数，目的是通过矩阵乘法来重建图像。因此，我们输入18作为函数的输入，它返回一个相当模糊的Lenna图像(如步骤8中的图所示)。然而，我们至少可以看到图像的轮廓。为了获得更清晰的图像，我们发现我们可以用92个分量来解释99%的方差。因此，我们将函数<code class="email">lenna_compression</code>的输入设为92。步骤9中的图显示，与仅使用<a id="id941" class="calibre1"/>18个组件构建的图像相比，这生成了更清晰的<a id="id940" class="calibre1"/>图像。</p></li><li class="listitem" value="9">You<a id="id936" class="calibre1"/> can obtain the point at which <a id="id937" class="calibre1"/>the singular vector can explain more than 99 percent of the variance;<div><pre class="programlisting">
<strong class="calibre2">&gt; min(which(cumsum(lenna.svd$d^2/sum(lenna.svd$d^2))&gt; 0.99))</strong>
<strong class="calibre2">[1] 92</strong>
<strong class="calibre2">&gt; lenna_compression(92)</strong>
</pre></div><div><img src="img/00252.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12"><a id="ch11lvl2sec452" class="calibre1"/>参见</p></div></div><p class="calibre13">Lenna图片是压缩算法最广泛使用的标准测试图像之一。关于Lenna图片的更多细节，请参考<a class="calibre1" href="http://www.cs.cmu.edu/~chuck/lennapg/">http://www.cs.cmu.edu/~chuck/lennapg/</a>。</p></li></ol><div/></div></div></div></body></html>


<html>
  <head>
    <title>Compressing images with SVD</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch11lvl1sec130" class="calibre1"/>使用ISOMAP进行非线性降维</h2></div></div></div><p class="calibre7">ISOMAP是流形学习的方法之一，它将线性框架<a id="id942" class="calibre1"/>推广到非线性<a id="id943" class="calibre1"/>数据结构。类似于MDS，ISOMAP创建了一些对象的相似性或不相似性(距离)的视觉呈现。然而，由于数据是以非线性格式构建的，因此在ISOMAP中，MDS的欧几里德距离度量被数据流形的测地线距离所取代。在本食谱中，我们将说明如何使用ISOMAP进行非线性降维。</p><p class="calibre7">准备就绪</p></div></div></body></html>


<html>
  <head>
    <title>Compressing images with SVD</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_4">在这个菜谱中，我们将使用来自<code class="email">RnavGraphImageData</code>的<code class="email">digits</code>数据作为我们的输入源。</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem"><a id="ch11lvl2sec454" class="calibre1"/>怎么做...</li></ul></div></div></div></body></html>


<html>
  <head>
    <title>Performing nonlinear dimension reduction with ISOMAP</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div/><div><div><div><div><h1 class="title" id="calibre_pb_0">执行以下步骤，使用ISOMAP执行非线性降维:</h1></div></div></div><p class="calibre7">首先安装并加载<code class="email">RnavGraphImageData</code>和<code class="email">vegan</code>包:<div> <pre class="programlisting"> <strong class="calibre2">&gt; install.packages("RnavGraphImageData")</strong> <strong class="calibre2">&gt; install.packages("vegan")</strong> <strong class="calibre2">&gt; library(RnavGraphImageData)</strong> <strong class="calibre2">&gt; library(vegan)</strong> </pre> </div></p></div></body></html>


<html>
  <head>
    <title>Performing nonlinear dimension reduction with ISOMAP</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_1">然后可以加载数据集，<code class="email">digits</code> : <div> <pre class="programlisting"> <strong class="calibre2">&gt; data(digits)</strong> </pre> </div></h2></div></div></div><p class="calibre7">数字数据集中的样本图像</p></div></div></body></html>


<html>
  <head>
    <title>Performing nonlinear dimension reduction with ISOMAP</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_2">接下来，您<a id="id944" class="calibre1"/>可以<a id="id945" class="calibre1"/>从人群中随机抽取300个数字:<div> <pre class="programlisting"> <strong class="calibre2">&gt; set.seed(2)</strong> <strong class="calibre2">&gt; digit.idx = sample(1:ncol(digits),size = 600)</strong> <strong class="calibre2">&gt; digit.select = digits[,digit.idx]</strong> </pre> </div></h2></div></div></div><p class="calibre7">转置选中的数字数据，然后使用<code class="email">vegdist</code> : <div> <pre class="programlisting"> <strong class="calibre2">&gt; digits.Transpose = t(digit.select)</strong> <strong class="calibre2">&gt; digit.dist = vegdist(digits.Transpose, method="euclidean")</strong> </pre> </div>计算对象间的相异度</p><div><ol class="orderedlist"><li class="listitem" value="1">ISOMAP对象的二维散点图</li><li class="listitem" value="2">You can then load the dataset, <code class="email">digits</code>:<div><pre class="programlisting">
<strong class="calibre2">&gt; data(digits)</strong>
</pre></div></li><li class="listitem" value="3">Rotate and plot the image:<div><pre class="programlisting">
<strong class="calibre2">&gt; sample.digit = matrix(digits[,3000],ncol = 16, byrow=FALSE)</strong>
<strong class="calibre2">&gt; image(t(sample.digit)[,nrow(sample.digit):1])</strong>
</pre></div><div><img src="img/00253.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12">具有最小生成树的二维散点图覆盖图</p></div></div><p class="calibre13"> </p></li><li class="listitem" value="4"><a id="ch11lvl2sec455" class="calibre1"/>工作原理...</li><li class="listitem" value="5">ISOMAP是一种非线性降维方法，是等距映射<a id="id948" class="calibre1"/>方法的代表。ISOMAP <a id="id949" class="calibre1"/>可以被视为度量MDS的扩展，其中数据点之间的欧几里德距离成对地被邻域图诱导的测地线距离所取代。</li><li class="listitem" value="6">Next, you can use <code class="email">isomap</code> to perform dimension reduction:<div><pre class="programlisting">
<strong class="calibre2">&gt; digit.isomap = isomap(digit.dist,k = 8, ndim=6, fragmentedOK = TRUE)</strong>
<strong class="calibre2">&gt; plot(digit.isomap)</strong>
</pre></div><div><img src="img/00254.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12">ISOMAP算法的描述分为四个步骤。首先，确定每个点的邻居。其次，构造一个邻域图。第三，计算两个节点之间的最短距离路径。最后，通过MDS找到数据的低维嵌入。</p></div></div><p class="calibre13">在这个食谱中，我们演示了如何使用ISOMAP进行非线性降维。首先，我们从<code class="email">RnavGraphImageData</code>加载数字数据。然后，在我们选择一个数字并绘制其旋转图像后，我们可以看到手写数字的图像(数字3，在步骤3的图中)。</p></li><li class="listitem" value="7">Finally, you <a id="id946" class="calibre1"/>can <a id="id947" class="calibre1"/>overlay the scatter plot with the minimum spanning tree, marked in red;<div><pre class="programlisting">
<strong class="calibre2">&gt; digit.st = spantree(digit.dist)</strong>
<strong class="calibre2">&gt; digit.plot = plot(digit.isomap, main="isomap k=8")</strong>
<strong class="calibre2">&gt; lines(digit.st, digit.plot, col="red")</strong>
</pre></div><div><img src="img/00255.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12">接下来，我们随机抽取300个数字作为ISOMAP的输入数据。然后我们转置数据集来计算每个图像对象之间的距离。一旦数据准备好，我们计算每个对象之间的距离，并执行降维。在这里，我们使用<code class="email">vegdist</code>来计算每个对象之间的差异，使用欧几里得度量。然后，我们使用ISOMAP对<code class="email">digits</code>数据进行非线性降维，将维度设置为<code class="email">6</code>，将为一个点保留的最短相异数设置为<code class="email">8</code>，并确保通过将<code class="email">fragmentedOK</code>指定为<code class="email">TRUE</code>来分析最大的连通组。</p></div></div><p class="calibre13">最后，我们<a id="id950" class="calibre1"/>可以使用<a id="id951" class="calibre1"/>生成的ISOMAP对象来制作一个二维散点图(图6)，并在散点图上用红色线条覆盖最小生成树(图7)。</p></li></ol><div/></div></div></div></body></html>


<html>
  <head>
    <title>Performing nonlinear dimension reduction with ISOMAP</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch11lvl2sec456" class="calibre1"/>还有更多...</h2></div></div></div><p class="calibre7">您还可以使用<code class="email">RnavGraph</code>包将高维数据(本例中是数字)可视化，使用<a id="id952" class="calibre1"/>图作为导航基础设施。更多信息请参考<a class="calibre1" href="http://www.icesi.edu.co/CRAN/web/packages/RnavGraph/vignettes/RnavGraph.pdf">http://www . icesi . edu . co/CRAN/web/packages/RnavGraph/vignettes/RnavGraph . pdf</a>。</p><p class="calibre7">以下是如何使用<code class="email">RnavGraph</code>在图表中可视化高维数据的描述:</p><p class="calibre7">首先安装并加载<code class="email">RnavGraph</code>和<code class="email">graph</code>包:<div> <pre class="programlisting"> <strong class="calibre2">&gt; install.packages("RnavGraph")</strong> <strong class="calibre2">&gt; source("http://bioconductor.org/biocLite.R")</strong> <strong class="calibre2">&gt; biocLite("graph")</strong> <strong class="calibre2">&gt; library(RnavGraph)</strong> </pre> </div></p><p class="calibre7">然后你可以从<code class="email">digit</code>数据:<div> <pre class="programlisting"> <strong class="calibre2">&gt; digit.group = rep(c(1:9,0), each = 1100)</strong> <strong class="calibre2">&gt; digit.ng_data = ng_data(name = "ISO_digits",</strong> <strong class="calibre2">+ data = data.frame(digit.isomap$points),</strong> <strong class="calibre2">+ shortnames = paste('i',1:6, sep = ''),</strong> <strong class="calibre2">+ group = digit.group[digit.idx],</strong> <strong class="calibre2">+ labels = as.character(digits.group[digit.idx]))</strong> </pre> </div>中创建一个<code class="email">NG_data</code>对象</p><p class="calibre7">从<code class="email">NG_data</code> : <div> <pre class="programlisting"> <strong class="calibre2">&gt;  V = shortnames(digit.ng_data)</strong> <strong class="calibre2">&gt;  G = completegraph(V)</strong> <strong class="calibre2">&gt;  LG =linegraph(G)</strong> <strong class="calibre2">&gt;  LGnot = complement(LG)</strong> <strong class="calibre2">&gt;  ng.LG = ng_graph(name = "3D Transition", graph = LG)</strong> <strong class="calibre2">&gt; ng.LGnot = ng_graph(name = "4D Transition", graph = LGnot)</strong> </pre> </div>创建一个<code class="email">NG_graph</code>对象</p></div></div></body></html>


<html>
  <head>
    <title>Performing nonlinear dimension reduction with ISOMAP</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_4">三维转换图表</h2></div></div></div><p class="calibre7">You can also use the <code class="email">RnavGraph</code> package to visualize high dimensional data (digits in this case) using <a id="id952" class="calibre1"/>graphs as a navigational infrastructure. For <a id="id953" class="calibre1"/>more information, please refer to <a class="calibre1" href="http://www.icesi.edu.co/CRAN/web/packages/RnavGraph/vignettes/RnavGraph.pdf">http://www.icesi.edu.co/CRAN/web/packages/RnavGraph/vignettes/RnavGraph.pdf</a>.</p><p class="calibre7">4D转换曲线图</p><div><ol class="orderedlist"><li class="listitem" value="1">First, install and load the <code class="email">RnavGraph</code> and <code class="email">graph</code> packages:<div><pre class="programlisting">
<strong class="calibre2">&gt; install.packages("RnavGraph")</strong>
<strong class="calibre2">&gt; source("http://bioconductor.org/biocLite.R")</strong>
<strong class="calibre2">&gt; biocLite("graph")</strong>
<strong class="calibre2">&gt; library(RnavGraph)</strong>
</pre></div></li><li class="listitem" value="2"><a id="ch11lvl1sec131" class="calibre1"/>利用局部线性嵌入进行非线性降维</li><li class="listitem" value="3"><strong class="calibre2">局部线性嵌入</strong> ( <strong class="calibre2"> LLE </strong>)是PCA的扩展，它将嵌入在高维<a id="id957" class="calibre1"/>空间的<a id="id956" class="calibre1"/>流形上的数据降低到低维空间。与ISOMAP(一种用于非线性降维的全局方法)相比，LLE是一种局部方法，其采用k-最近邻的线性组合来保持数据的局部属性。在这个食谱中，我们将简单介绍如何在s曲线数据上使用LLE。</li><li class="listitem" value="4">Finally, you<a id="id954" class="calibre1"/> can <a id="id955" class="calibre1"/>visualize the graph in the <code class="email">tk2d</code> plot:<div><pre class="programlisting">
<strong class="calibre2">&gt; ng.i.digits = ng_image_array_gray('USPS Handwritten Digits',</strong>
<strong class="calibre2">+ digit.select,16,16,invert = TRUE,</strong>
<strong class="calibre2">+ img_in_row = FALSE)</strong>
<strong class="calibre2">&gt; vizDigits1 = ng_2d(data = digit.ng_data, graph = ng.LG, images = ng.i.digits)</strong>
<strong class="calibre2">&gt; vizDigits2 = ng_2d(data = digit.ng_data, graph = ng.LGnot, images = ng.i.digits)</strong>
<strong class="calibre2">&gt; nav = navGraph(data = digit.ng_data, graph = list(ng.LG, ng.LGnot), viz = list(vizDigits1, vizDigits2))</strong>
</pre></div><div><img src="img/00256.jpeg" alt="There's more..." class="calibre9"/><div><p class="calibre12"><a id="ch11lvl2sec457" class="calibre1"/>做好准备</p></div></div><p class="calibre13">在这个菜谱中，我们将使用来自<code class="email">lle</code>包中的<code class="email">lle_scurve_data</code>的数字数据作为我们的输入源。</p></li><li class="listitem" value="5">One can also view a 4D transition graph plot:<div><img src="img/00257.jpeg" alt="There's more..." class="calibre9"/><div><p class="calibre12"><a id="ch11lvl2sec458" class="calibre1"/>怎么做...</p></div></div><p class="calibre13">执行以下步骤，使用LLE进行非线性降维:</p></li></ol><div/></div></div></div></body></html>


<html>
  <head>
    <title>Performing nonlinear dimension reduction with Local Linear Embedding</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div/><div><div><div><div><h1 class="title" id="calibre_pb_0">首先，你需要安装并加载软件包，<code class="email">lle</code> : <div> <pre class="programlisting"> <strong class="calibre2">&gt; install.packages("lle")</strong> <strong class="calibre2">&gt; library(lle)</strong> </pre> </div></h1></div></div></div><p class="calibre7">然后可以从<code class="email">lle</code> : <div> <pre class="programlisting"> <strong class="calibre2">&gt; data( lle_scurve_data )</strong> </pre> </div>加载<code class="email">ll_scurve_data</code></p></div></body></html>


<html>
  <head>
    <title>Performing nonlinear dimension reduction with Local Linear Embedding</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_1">接下来，对<code class="email">lle_scurve_data</code> : <div> <pre class="programlisting"> <strong class="calibre2">&gt; X = lle_scurve_data</strong> <strong class="calibre2">&gt; results = lle( X=X , m=2, k=12,  id=TRUE)</strong> <strong class="calibre2">finding neighbours</strong> <strong class="calibre2">calculating weights</strong> <strong class="calibre2">intrinsic dim: mean=2.47875, mode=2</strong> <strong class="calibre2">computing coordinates</strong> </pre> </div>执行<code class="email">lle</code></h2></div></div></div><p class="calibre7">嵌入数据的二维散点图</p></div></div></body></html>


<html>
  <head>
    <title>Performing nonlinear dimension reduction with Local Linear Embedding</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch11lvl2sec458" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre7">LLE结果的LLE图</p><div><ol class="orderedlist"><li class="listitem" value="1">First, you need to install and load the package, <code class="email">lle</code>:<div><pre class="programlisting">
<strong class="calibre2">&gt; install.packages("lle")</strong>
<strong class="calibre2">&gt; library(lle)</strong>
</pre></div></li><li class="listitem" value="2"><a id="ch11lvl2sec459" class="calibre1"/>工作原理...</li><li class="listitem" value="3">LLE是一种<a id="id960" class="calibre1"/>非线性降维<a id="id961" class="calibre1"/>方法，它计算低维的邻域，保持高维数据的嵌入。LLE的算法可以用这些步骤来说明:首先，LLE计算每个数据点的k-邻居，<img src="img/00218.jpeg" alt="How it works..." class="calibre24"/>。其次，它为每个点计算一组权重，这使得误差的残差和最小化，这可以最好地从其邻居重建每个数据点。误差的残差和可以描述为<img src="img/00260.jpeg" alt="How it works..." class="calibre24"/>，其中<img src="img/00261.jpeg" alt="How it works..." class="calibre24"/>如果<img src="img/00262.jpeg" alt="How it works..." class="calibre24"/>不是<img src="img/00218.jpeg" alt="How it works..." class="calibre24"/>的k近邻之一，对于每个I，<img src="img/00263.jpeg" alt="How it works..." class="calibre24"/>。最后，找到由权重w重构的最佳向量Y，代价函数可以表示为<img src="img/00264.jpeg" alt="How it works..." class="calibre24"/>，约束条件为<img src="img/00265.jpeg" alt="How it works..." class="calibre24"/>，和<img src="img/00266.jpeg" alt="How it works..." class="calibre24"/>。</li><li class="listitem" value="4">Examine <a id="id958" class="calibre1"/>the result <a id="id959" class="calibre1"/>with the <code class="email">str</code> and <code class="email">plot</code> function:<div><pre class="programlisting">
<strong class="calibre2">&gt; str( results )</strong>
<strong class="calibre2">List of 4</strong>
<strong class="calibre2"> $ Y     : num [1:800, 1:2] -1.586 -0.415 0.896 0.513 1.477 ...</strong>
<strong class="calibre2"> $ X     : num [1:800, 1:3] 0.955 -0.66 -0.983 0.954 0.958 ...</strong>
<strong class="calibre2"> $ choise: NULL</strong>
<strong class="calibre2"> $ id    : num [1:800] 3 3 2 3 2 2 2 3 3 3 ...</strong>
<strong class="calibre2">&gt;plot( results$Y, main="embedded data", xlab=expression(y[1]), ylab=expression(y[2]) )</strong>
</pre></div><div><img src="img/00258.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12">在这个<a id="id962" class="calibre1"/>配方中，我们演示了<a id="id963" class="calibre1"/>如何使用LLE进行非线性降维。首先，我们从<code class="email">lle</code>加载<code class="email">lle_scurve_data</code>。然后，我们对两个维度和12个邻居执行<code class="email">lle</code>，并通过指定<code class="email">id =TRUE</code>列出每个数据点的维度。LLE有三个步骤，包括:为数据中的每个点构建邻域，在该邻域中查找用于线性逼近数据的权重，以及查找低维坐标。</p></div></div><p class="calibre13">接下来，我们可以使用<code class="email">str</code>和<code class="email">plot</code>函数来检查数据。<code class="email">str</code>函数返回X、Y、选择和ID。这里，X表示输入数据，Y表示嵌入数据，choice表示保留数据的索引向量，而子集选择和ID表示每个数据输入的维度。<code class="email">plot</code>函数返回嵌入数据的散点图。最后，我们使用<code class="email">plot_lle</code>来绘制结果。这里，我们通过设置inter等于<code class="email">TRUE</code>来启用交互模式。</p></li><li class="listitem" value="5">Lastly, you can use <code class="email">plot_lle</code> to plot the LLE result:<div><pre class="programlisting">
<strong class="calibre2">&gt; plot_lle( results$Y, X, FALSE, col="red", inter=TRUE )</strong>
</pre></div><div><img src="img/00259.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12"><a id="ch11lvl2sec460" class="calibre1"/>参见</p></div></div><p class="calibre13">另一个有用的非线性降维包是<code class="email">RDRToolbox</code>，它是一个用ISOMAP和LLE进行非线性降维的包。您可以使用以下命令安装<code class="email">RDRToolbox</code> : <div> <pre class="programlisting"> <strong class="calibre2">&gt; source("http://bioconductor.org/biocLite.R")</strong> <strong class="calibre2">&gt; biocLite("RDRToolbox")</strong> <strong class="calibre2">&gt; library(RDRToolbox)</strong> </pre> </div></p></li></ol><div/></div></div></div></body></html>


<html>
  <head>
    <title>Performing nonlinear dimension reduction with Local Linear Embedding</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch12" class="calibre1"/>第十二章。大数据分析(R和Hadoop)</h2></div></div></div><p class="calibre7">在本章中，我们将讨论以下主题:</p><p class="calibre7">准备RHadoop环境</p><p class="calibre7">安装rmr2</p></div></div></body></html>


<html>
  <head>
    <title>Performing nonlinear dimension reduction with Local Linear Embedding</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_4">安装rhdfs</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">使用rhdfs操作HDFS</li></ul></div></div></div></body></html>


<html>
  <head>
    <title>Chapter 12. Big Data Analysis (R and Hadoop)</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div/><div><div><div><div><h1 class="title" id="calibre_pb_0">用RHadoop实现字数统计问题</h1></div></div></div><p class="calibre7">比较R MapReduce程序和标准R程序的性能</p><div><ul class="itemizedlist"><li class="listitem">测试和调试rmr2程序</li><li class="listitem">安装plyrmr</li><li class="listitem">使用plyrmr操作数据</li><li class="listitem">用RHadoop进行机器学习</li><li class="listitem">在Amazon EMR上配置RHadoop集群</li><li class="listitem"><a id="ch12lvl1sec132" class="calibre1"/>简介</li><li class="listitem">RHadoop <a id="id964" class="calibre1"/>是一个R包集合，支持用户使用Hadoop处理和分析大数据。在了解如何设置RHadoop并将其付诸实践之前，我们必须知道为什么我们需要使用机器学习来实现大数据规模。</li><li class="listitem">在前面的章节中，我们已经提到R在执行数据分析和机器学习时是多么有用。在传统的统计分析中，重点是对历史样本(小数据)进行分析，这可能会忽略很少发生但有价值的事件和结果，从而得出不确定的结论。</li><li class="listitem">云技术的出现使得客户和企业之间的实时交互更加频繁；因此，现在机器学习的重点已经转移到为各种客户开发准确的预测。例如，企业可以通过使用实时预测模型，基于个人行为提供实时个人推荐或在线广告。</li><li class="listitem">然而，如果数据(例如，所有在线用户的行为)太大，无法容纳在一台<a id="id965" class="calibre1"/>单机的内存中，那么您别无选择，只能使用超级计算机或其他可扩展的解决方案。最受欢迎的可扩展大数据解决方案是Hadoop，这是一个开源框架，能够跨集群存储和执行并行计算。因此，您可以使用RHadoop，它允许R利用Hadoop的可伸缩性，帮助处理和分析大数据。在RHadoop中，有五个主要的包，它们是:</li><li class="listitem"><code class="email">rmr</code>:这个<a id="id966" class="calibre1"/>是R和Hadoop MapReduce的接口，<a id="id967" class="calibre1"/>调用Hadoop streaming MapReduce API跨Hadoop集群执行MapReduce作业。开发一个R MapReduce程序，你只需要专注于map和Reduce函数的设计，剩下的可伸缩性问题就交给Hadoop自己处理了。</li></ul></div></div></body></html>


<html>
  <head>
    <title>Chapter 12. Big Data Analysis (R and Hadoop)</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><code class="email">rhdfs</code>:这个<a id="id968" class="calibre1"/>是R和HDFS之间的接口，它调用HDFS API访问存储在HDFS的数据。<code class="email">rhdfs</code>的使用<a id="id969" class="calibre1"/>非常类似于Hadoop shell的使用，它允许用户从R控制台轻松操作HDFS。</h1></div></div></div><p class="calibre7"><code class="email">rhbase</code>:这个<a id="id970" class="calibre1"/>是R和HBase之间的接口，访问Hbase，通过节俭服务器分布在集群中。您可以使用<code class="email">rhbase</code>来读/写数据和操作HBase中存储的表。</p><p class="calibre7"><code class="email">plyrmr</code>:这个<a id="id972" class="calibre1"/>是MapReduce的高级抽象，它<a id="id973" class="calibre1"/>允许用户以类似plyr的语法执行常见的数据操作。这个包极大地降低了大数据操作的学习曲线。</p><p class="calibre7"><code class="email">ravro</code>:该<a id="id974" class="calibre1"/>允许用户读取R中的<code class="email">avro</code>文件，或者<a id="id975" class="calibre1"/>写入<code class="email">avro</code>文件。它允许R与HDFS交换数据。</p><p class="calibre7">在本章中，我们将从准备Hadoop环境开始，这样您就可以安装RHadoop了。然后我们介绍三个主要包的安装:<code class="email">rmr</code>、<code class="email">rhdfs</code>和<code class="email">plyrmr</code>。接下来我们将介绍如何使用<code class="email">rmr</code>从R执行MapReduce，通过<code class="email">rhdfs</code>操作一个HDFS文件，使用<code class="email">plyrmr</code>执行一个普通的数据操作。此外，我们将探索如何使用RHadoop执行机器学习。最后，我们将介绍如何在Amazon EC2上部署多个RHadoop集群。</p><div><ul class="itemizedlist"><li class="listitem"><a id="ch12lvl1sec133" class="calibre1"/>准备RHadoop环境</li><li class="listitem">由于RHadoop需要一个R和Hadoop集成的环境，我们必须首先准备一个安装了R和Hadoop的环境<a id="id977" class="calibre1"/>。我们可以使用<strong class="calibre2">Cloudera QuickStart VM</strong>(VM是免费的)，而不是构建一个新的Hadoop系统，它包含一个单节点Apache Hadoop集群和r。在这个<a id="id978" class="calibre1"/>配方中，我们将演示如何下载cloud era quick start VM。</li><li class="listitem">准备就绪</li><li class="listitem">要使用Cloudera QuickStart虚拟机，建议您准备一个64位的客户操作系统，安装VMWare或VirtualBox，或者安装KVM。</li><li class="listitem">如果选择使用VMWare，应准备与WorkStation 8.x或更高版本兼容的播放器:Player 4.x或更高版本、ESXi 5.x或更高版本、Fusion 4.x或更高版本。</li></ul></div><p class="calibre7">注意，启动VM需要4 GB的RAM，可用磁盘空间至少为3 GB。</p></div></div></body></html>


<html>
  <head>
    <title>Preparing the RHadoop environment</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div/><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch12lvl2sec462" class="calibre1"/>怎么做...</h1></div></div></div><p class="calibre7">执行<a id="id979" class="calibre1"/>以下步骤，使用Cloudera QuickStart虚拟机设置Hadoop环境:</p></div></body></html>


<html>
  <head>
    <title>Preparing the RHadoop environment</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_1">Cloudera QuickStart虚拟机下载网站的屏幕截图</h2></div></div></div><p class="calibre7">根据安装在您的操作系统上的虚拟<a id="id982" class="calibre1"/>机器平台的<a id="id981" class="calibre1"/>，选择适当的链接(您可能需要在Cloudera升级其虚拟机时更新链接)来下载虚拟机文件:<div> <ul class="itemizedlist3"> <li class="listitem"> <strong class="calibre2">来下载VMWare </strong>:您<a id="id983" class="calibre1"/>可以访问<a class="calibre1" href="https://downloads.cloudera.com/demo_vm/vmware/cloudera-quickstart-vm-5.2.0-0-vmware.7z">https://downloads . cloud era . com/demo _ VM/VMWare/cloud era-quick start-VM-5 . 2 . 0-0-VMWare . 7z</a></li><li class="listitem"><strong class="calibre2">来下载</strong></li></ul></div></p><p class="calibre7"><strong class="calibre2">下载VMWare </strong>:您<a id="id983" class="calibre1"/>可以访问<a class="calibre1" href="https://downloads.cloudera.com/demo_vm/vmware/cloudera-quickstart-vm-5.2.0-0-vmware.7z">https://downloads . cloud era . com/demo _ VM/VMWare/cloud era-quick start-VM-5 . 2 . 0-0-VMWare . 7z</a></p><p class="calibre7"><strong class="calibre2">下载KVM </strong>:您<a id="id984" class="calibre1"/>可以访问<a class="calibre1" href="https://downloads.cloudera.com/demo_vm/kvm/cloudera-quickstart-vm-5.2.0-0-kvm.7z">https://downloads . cloud era . com/demo _ VM/KVM/cloud era-quick start-VM-5 . 2 . 0-0-KVM . 7z</a></p></div></div></body></html>


<html>
  <head>
    <title>Preparing the RHadoop environment</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><strong class="calibre2">下载VirtualBox </strong>:可以访问<a class="calibre1" href="https://downloads.cloudera.com/demo_vm/virtualbox/cloudera-quickstart-vm-5.2.0-0-virtualbox.7z">https://downloads . cloudera . com/demo _ VM/VirtualBox/cloudera-quick start-VM-5 . 2 . 0-0-VirtualBox . 7z</a></h2></div></div></div><p class="calibre7">Cloudera QuickStart虚拟机的屏幕截图。</p><div><ol class="orderedlist"><li class="listitem" value="1">Visit the Cloudera QuickStart VM download site (you may need to update the link as<a id="id980" class="calibre1"/> Cloudera upgrades its VMs , the current version of CDH is 5.3) at <a class="calibre1" href="http://www.cloudera.com/content/cloudera/en/downloads/quickstart_vms/cdh-5-3-x.html">http://www.cloudera.com/content/cloudera/en/downloads/quickstart_vms/cdh-5-3-x.html</a>.<div><img src="img/00267.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12">A screenshot of the Cloudera QuickStart VM download site</p></div></div><p class="calibre13">输入<code class="email">hadoop</code>后的终端截图</p></li><li class="listitem" value="2">Depending <a id="id981" class="calibre1"/>on the virtual<a id="id982" class="calibre1"/> machine platform installed on your OS, choose the appropriate link (you may need to update the link as Cloudera upgrades its VMs) to download the VM file:<div><ul class="itemizedlist3"><li class="listitem">打开一个终端，输入<code class="email">R</code>。访问一个R会话，检查Cloudera QuickStart虚拟机中是否已经安装了版本3.1.1。如果在VM中找不到安装的R，请使用下面的命令安装R: <div> <pre class="programlisting"> <strong class="calibre2">$ yum install R R-core R-core-devel R-devel</strong> </pre> </div></li><li class="listitem"><a id="ch12lvl2sec463" class="calibre1"/>工作原理...</li><li class="listitem">不用自己搭建Hadoop系统，可以使用Cloudera提供的Hadoop VM应用(VM免费)。QuickStart VM在CentOS 6.2上运行，安装了单节点Apache Hadoop集群、Hadoop生态系统模块和R。这有助于您节省时间，而不是要求您学习如何安装和使用Hadoop。</li></ul></div></li><li class="listitem" value="3">Next, you <a id="id985" class="calibre1"/>can start the QuickStart VM using the virtual machine platform installed on your OS. You should see the desktop of Centos 6.2 in a few minutes.<div><img src="img/00268.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12"><a id="id988" class="calibre1"/> QuickStart VM要求您拥有一台装有64位客户操作系统的<a id="id989" class="calibre1"/>计算机、至少4 GB内存、3 GB磁盘空间，并且安装了VMWare、VirtualBox或KVM。因此，您可能无法在某些计算机上使用此版本的VM。作为替代，你可以考虑使用亚马逊的弹性MapReduce。我们将在本章的最后一个菜谱中说明如何在EMR中准备一个RHadoop环境。</p></div></div><p class="calibre13">设置Cloudera QuickStart虚拟机非常简单。从下载站点下载虚拟机，然后使用VMWare、VirtualBox或KVM打开构建的映像。一旦可以看到CentOS的桌面，那么就可以访问终端，输入<code class="email">hadoop</code>查看Hadoop是否在工作；然后，键入<code class="email">R</code>,看看R在QuickStart VM中是否工作。</p></li><li class="listitem" value="4">You <a id="id986" class="calibre1"/>can then open a terminal<a id="id987" class="calibre1"/> and type <code class="email">hadoop</code>, which will display a list of functions that can operate a Hadoop cluster.<div><img src="img/00269.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12"><a id="ch12lvl2sec464" class="calibre1"/>参见</p></div></div><p class="calibre13">除了使用Cloudera QuickStart VM，你还可以考虑使用Hontonworks或MapR提供的沙盒VM。你可以在<a class="calibre1" href="http://hortonworks.com/products/hortonworks-sandbox/#install">http://Horton works . com/products/Horton works-Sandbox/# install</a>找到Hontonworks沙盒，在<a class="calibre1" href="https://www.mapr.com/products/mapr-sandbox-hadoop/download">https://www.mapr.com/products/mapr-sandbox-hadoop/download</a>找到<a id="id991" class="calibre1"/> mapR沙盒。</p></li><li class="listitem" value="5"><a id="ch12lvl1sec134" class="calibre1"/>安装rmr2</li></ol><div/></div></div></div></body></html>


<html>
  <head>
    <title>Preparing the RHadoop environment</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><code class="email">rmr2</code>包<a id="id992" class="calibre1"/>允许你在Hadoop集群上通过MapReduce进行大数据处理和<a id="id993" class="calibre1"/>分析。要在Hadoop集群上执行MapReduce，您必须在每个任务节点上安装R和<code class="email">rmr2</code>。在这个菜谱中，我们将说明如何在Hadoop集群的单个节点上安装<code class="email">rmr2</code>。</h2></div></div></div><p class="calibre7">做好准备</p><p class="calibre7">通过启动Cloudera QuickStart虚拟机并将虚拟机连接到互联网，确保您已经完成了前面的操作，以便您可以继续下载和安装<code class="email">rmr2</code>包。</p><p class="calibre7"><a id="ch12lvl2sec466" class="calibre1"/>怎么做...</p></div></div></body></html>


<html>
  <head>
    <title>Preparing the RHadoop environment</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_4">执行以下<a id="id994" class="calibre1"/>步骤，在快速启动虚拟机上安装<code class="email">rmr2</code>:</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">首先，在Cloudera QuickStart虚拟机中打开<a id="id995" class="calibre1"/>终端。</li></ul></div></div></div></body></html>


<html>
  <head>
    <title>Installing rmr2</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div/><div><div><div><div><h1 class="title" id="calibre_pb_0">使用root权限进入R会话:<div> <pre class="programlisting"> <strong class="calibre2">$ sudo R</strong> </pre> </div></h1></div></div></div><p class="calibre7">然后可以在安装<code class="email">rmr2</code> : <div> <pre class="programlisting"> <strong class="calibre2">&gt; install.packages(c("codetools", "Rcpp", "RJSONIO", "bitops", "digest", "functional", "stringr", "plyr", "reshape2", "rJava", "caTools"))</strong> </pre> </div>之前安装依赖包</p></div></body></html>


<html>
  <head>
    <title>Installing rmr2</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_1">退出R会话:<div> <pre class="programlisting"> <strong class="calibre2">&gt; q()</strong> </pre> </div></h2></div></div></div><p class="calibre7">接下来，您可以将<code class="email">rmr-3.3.0</code>下载到快速启动虚拟机。如果Revolution Analytics升级了<code class="email">rmr2</code>的版本，您可能需要更新链接:<div> <pre class="programlisting"> <strong class="calibre2">$ wget --no-check-certificate https://raw.githubusercontent.com/RevolutionAnalytics/rmr2/3.3.0/build/rmr2_3.3.0.tar.gz</strong> </pre> </div></p></div></div></body></html>


<html>
  <head>
    <title>Installing rmr2</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_2">然后，您可以将<code class="email">rmr-3.3.0</code>安装到快速启动虚拟机:<div> <pre class="programlisting"> <strong class="calibre2">$ sudo R CMD INSTALL rmr2_3.3.0.tar.gz</strong> </pre> </div></h2></div></div></div><p class="calibre7">最后，您可以进入R会话并使用<code class="email">library</code>功能来测试库是否已经成功安装:<div> <pre class="programlisting"> <strong class="calibre2">$ R</strong> <strong class="calibre2">&gt; library(rmr2)</strong> </pre> </div></p><div><ol class="orderedlist"><li class="listitem" value="1">它是如何工作的...</li><li class="listitem" value="2">为了在Hadoop集群上执行MapReduce，您必须在每个任务节点上安装R和RHadoop。这里，我们展示了如何在Hadoop集群的单个节点上安装<code class="email">rmr2</code>。首先打开Cloudera QuickStart VM的终端。在安装<code class="email">rmr2</code>之前，我们先用root权限访问一个R会话，安装依赖的R包。</li><li class="listitem" value="3">接下来，在安装完所有依赖包之后，退出R会话，并使用Linux shell中的<code class="email">wget</code>命令将<code class="email">rmr-3.3.0</code>从GitHub下载到本地文件系统。然后您可以开始安装<code class="email">rmr2</code>。最后，您可以访问一个R会话，并使用库函数来验证软件包是否已经安装。</li><li class="listitem" value="4"><a id="ch12lvl2sec468" class="calibre1"/>亦见</li><li class="listitem" value="5">要查看更多关于RHadoop的信息和更新，你可以参考GitHub上的RHadoop wiki页面:<a class="calibre1" href="https://github.com/RevolutionAnalytics/RHadoop/wiki">https://github.com/RevolutionAnalytics/RHadoop/wiki</a></li><li class="listitem" value="6"><a id="ch12lvl1sec135" class="calibre1"/>安装rhdfs</li><li class="listitem" value="7"><code class="email">rhdfs</code>包<a id="id998" class="calibre1"/>是R和HDFS之间的接口，<a id="id999" class="calibre1"/>允许用户从R控制台访问HDFS。与<code class="email">rmr2</code>类似，应该在每个任务节点上安装<code class="email">rhdfs</code>，这样就可以通过r访问HDFS资源，在这个菜谱中，我们将介绍如何在Cloudera QuickStart VM上安装<code class="email">rhdfs</code>。</li></ol><div/></div></div></div></body></html>


<html>
  <head>
    <title>Installing rmr2</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch12lvl2sec469" class="calibre1"/>做好准备</h2></div></div></div><p class="calibre7">通过启动Cloudera QuickStart虚拟机并将虚拟机连接到互联网，确保您已经完成了前面的方法，这样您就可以继续下载和安装<code class="email">rhdfs</code>包。</p><p class="calibre7"><a id="ch12lvl2sec470" class="calibre1"/>怎么做...</p></div></div></body></html>


<html>
  <head>
    <title>Installing rmr2</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_4">执行以下步骤安装<code class="email">rhdfs</code>:</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">首先可以从GitHub下载<code class="email">rhdfs 1.0.8</code>。如果Revolution Analytics升级了<code class="email">rhdfs</code> : <div> <pre class="programlisting"> <strong class="calibre2">$wget --no-check-certificate https://raw.github.com/RevolutionAnalytics/rhdfs/master/build/rhdfs_1.0.8.tar.gz</strong> </pre> </div>的版本，您可能需要更新链接</li></ul></div></div></div></body></html>


<html>
  <head>
    <title>Installing rhdfs</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div/><div><div><div><div><h1 class="title" id="calibre_pb_0">接下来，你可以在命令行模式下安装<code class="email">rhdfs</code>:<div><pre class="programlisting"> <strong class="calibre2">$ sudo HADOOP_CMD=/usr/bin/hadoop  R CMD INSTALL rhdfs_1.0.8.tar.gz</strong> </pre></div></h1></div></div></div><p class="calibre7">然后您可以设置<code class="email">JAVA_HOME</code>。<code class="email">JAVA_HOME</code>的配置取决于虚拟机中安装的Java版本:<div> <pre class="programlisting"> <strong class="calibre2">$ sudo JAVA_HOME=/usr/java/jdk1.7.0_67-cloudera R CMD javareconf</strong> </pre> </div></p></div></body></html>


<html>
  <head>
    <title>Installing rhdfs</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_1">最后，您可以设置系统环境并初始化<code class="email">rhdfs</code>。如果您使用不同版本的QuickStart VM，您可能需要更新环境设置:<div> <pre class="programlisting"> <strong class="calibre2">$ R</strong> <strong class="calibre2">&gt; Sys.setenv(HADOOP_CMD="/usr/bin/hadoop")</strong> <strong class="calibre2">&gt; Sys.setenv(HADOOP_STREAMING="/usr/lib/hadoop-mapreduce/hadoop-</strong> <strong class="calibre2">streaming-2.5.0-cdh5.2.0.jar")</strong> <strong class="calibre2">&gt; library(rhdfs)</strong> <strong class="calibre2">&gt; hdfs.init()</strong> </pre> </div></h2></div></div></div><p class="calibre7"><a id="ch12lvl2sec471" class="calibre1"/>工作原理...</p></div></div></body></html>


<html>
  <head>
    <title>Installing rhdfs</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><code class="email">rhdfs</code>包提供了让用户使用R管理HDFS的功能，和<code class="email">rmr2</code>类似，你<a id="id1000" class="calibre1"/>要在每个任务节点上安装<code class="email">rhdfs</code>，这样<a id="id1001" class="calibre1"/>就可以通过R控制台访问HDFS。</h2></div></div></div><p class="calibre7">要安装<code class="email">rhdfs</code>，首先要从GitHub下载<code class="email">rhdfs</code>。然后，您可以通过指定<code class="email">HADOOP_CMD</code>的位置将<code class="email">rhdfs</code>安装到R中。您必须通过命令<code class="email">javareconf</code>为R配置Java支持。</p><div><ol class="orderedlist"><li class="listitem" value="1">接下来可以访问R，配置<code class="email">HADOOP_CMD</code>和<code class="email">HADOOP_STREAMING</code>的位置。最后，您可以通过<code class="email">rhdfs.init</code>函数初始化<code class="email">rhdfs</code>，这允许您通过<code class="email">rhdfs</code>开始操作HDFS。</li><li class="listitem" value="2"><a id="ch12lvl2sec472" class="calibre1"/>亦见</li><li class="listitem" value="3">要找到<code class="email">HADOOP_CMD</code>的位置，可以在Linux shell中使用<code class="email">which hadoop</code>命令。在大多数Hadoop系统中，<code class="email">HADOOP_CMD</code>位于<code class="email">/usr/bin/hadoop</code>。</li><li class="listitem" value="4">至于<code class="email">HADOOP_STREAMING</code>的位置，流JAR文件往往位于<code class="email">/usr/lib/hadoop-mapreduce/</code>。但是，如果在您的Linux系统中找不到目录<code class="email">/usr/lib/Hadoop-mapreduce</code>，您可以使用<code class="email">locate</code>命令搜索流JAR。例如:<div> <pre class="programlisting"> <strong class="calibre2">$ sudo updatedb</strong> <strong class="calibre2">$ locate streaming | grep jar | more</strong> </pre> </div></li></ol><div/></div></div></div></body></html>


<html>
  <head>
    <title>Installing rhdfs</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch12lvl1sec136" class="calibre1"/>使用rhdfs操作HDFS</h2></div></div></div><p class="calibre7"><code class="email">rhdfs</code>包是Hadoop和R之间的接口，可以调用<a id="id1002" class="calibre1"/>后端的一个HDFS API来操作HDFS。因此，您<a id="id1003" class="calibre1"/>可以通过使用<code class="email">rhdfs</code>包从R控制台轻松操作HDFS。在下面的食谱中，我们将演示如何使用<code class="email">rhdfs</code>函数来操作HDFS。</p><p class="calibre7">准备就绪</p><p class="calibre7">要继续此配方，您需要通过将<code class="email">rhdfs</code>安装到R中来完成之前的配方，并确认您可以通过<code class="email">hdfs.init</code>功能初始化HDFS。</p></div></div></body></html>


<html>
  <head>
    <title>Installing rhdfs</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch12lvl2sec474" class="calibre1"/>怎么做...</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">执行<a id="id1004" class="calibre1"/>以下步骤操作存储在<a id="id1005" class="calibre1"/>HDFS上的文件:</li><li class="listitem">初始化<code class="email">rhdfs</code>包:<div> <pre class="programlisting"> <strong class="calibre2">&gt; Sys.setenv(HADOOP_CMD="/usr/bin/hadoop")</strong> <strong class="calibre2">&gt; Sys.setenv(HADOOP_STREAMING="/usr/lib/hadoop-mapreduce/hadoop-streaming-2.5.0-cdh5.2.0.jar")</strong> <strong class="calibre2">&gt; library(rhdfs)</strong> <strong class="calibre2">&gt; hdfs.init ()</strong> </pre> </div></li></ul></div></div></div></body></html>


<html>
  <head>
    <title>Operating HDFS with rhdfs</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div/><div><div><div><div><h1 class="title" id="calibre_pb_0">然后你可以操作存储在HDFS上的文件， 如下:<div> <ul class="itemizedlist3"> <li class="listitem"> <code class="email">hdfs.put</code>:从本地文件系统复制一个文件到HDFS:<div><pre class="programlisting"> <strong class="calibre2">&gt; hdfs.put('word.txt', './')</strong> </pre></div></li><li class="listitem"><code class="email">hdfs.ls</code>:从HDFS读取目录列表:<div> <pre class="programlisting"> <strong class="calibre2">&gt; hdfs.ls('./')</strong> </pre> </div> </li> <li class="listitem"> <code class="email">hdfs.copy</code>:从一个HDFS目录复制一个文件到另一个:<div> <pre class="programlisting"> <strong class="calibre2">&gt; hdfs.copy('word.txt', 'wordcnt.txt')</strong> </pre> </div> </li> <li class="listitem"> <code class="email">hdfs.move</code>:从一个HDFS目录移动一个文件到另一个:<div><pre class="programlisting"> <strong class="calibre2">&gt; hdfs.move('wordcnt.txt', './data/wordcnt.txt')</strong> </pre></div></li><li class="listitem"><code class="email">hdfs.delete</code>:T8】 :从R:<div><pre class="programlisting"> <strong class="calibre2">&gt; hdfs.rm('./data/')</strong> </pre></div></li><li class="listitem"><code class="email">hdfs.get</code>删除一个HDFS目录:从HDFS下载一个文件到本地文件系统:<div> <pre class="programlisting"> <strong class="calibre2">&gt; hdfs.get(word.txt', '/home/cloudera/word.txt')</strong> </pre> </div> </li> <li class="listitem"> <code class="email">hdfs.rename</code>:重命名存储在HDFS上的一个文件:<div> <pre class="programlisting"> <strong class="calibre2">hdfs.rename('./test/q1.txt','./test/test.txt')</strong> </pre> </div> </li> <li class="listitem"> <code class="email">hdfs.chmod</code>:更改文件或目录的权限:<div> <pre class="programlisting"> <strong class="calibre2">&gt; hdfs.chmod('test', permissions= '777')</strong> </pre> </div> </li> <li class="listitem"> <code class="email">hdfs.file.info</code>:读取HDFS的元信息</li></ul></div></h1></div></div></div><p class="calibre7"><code class="email">hdfs.put</code>:从本地文件系统复制一个文件到HDFS: <div> <pre class="programlisting"> <strong class="calibre2">&gt; hdfs.put('word.txt', './')</strong> </pre> </div></p></div></body></html>


<html>
  <head>
    <title>Operating HDFS with rhdfs</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><code class="email">hdfs.ls</code>:从HDFS读取目录列表:<div> <pre class="programlisting"> <strong class="calibre2">&gt; hdfs.ls('./')</strong> </pre> </div></h2></div></div></div><p class="calibre7"><code class="email">hdfs.copy</code>:将文件从一个HDFS目录复制到另一个:<div> <pre class="programlisting"> <strong class="calibre2">&gt; hdfs.copy('word.txt', 'wordcnt.txt')</strong> </pre> </div></p></div></div></body></html>


<html>
  <head>
    <title>Operating HDFS with rhdfs</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><code class="email">hdfs.move</code>:将文件从一个HDFS目录移动到另一个:<div> <pre class="programlisting"> <strong class="calibre2">&gt; hdfs.move('wordcnt.txt', './data/wordcnt.txt')</strong> </pre> </div></h2></div></div></div><p class="calibre7"><code class="email">hdfs.delete</code>:从R: <div> <pre class="programlisting"> <strong class="calibre2">&gt; hdfs.delete('./data/')</strong> </pre> </div>中删除一个HDFS目录</p><div><ol class="orderedlist"><li class="listitem" value="1"><code class="email">hdfs.rm</code>:从R: <div> <pre class="programlisting"> <strong class="calibre2">&gt; hdfs.rm('./data/')</strong> </pre> </div>中删除一个HDFS目录</li><li class="listitem" value="2"><code class="email">hdfs.get</code>:从HDFS下载一个文件到本地文件系统:<div> <pre class="programlisting"> <strong class="calibre2">&gt; hdfs.get(word.txt', '/home/cloudera/word.txt')</strong> </pre> </div></li><li class="listitem" value="3">要初始化<code class="email">rhdfs</code>，必须在系统环境中设置<code class="email">HADOOP_CMD</code>和<code class="email">HADOOP_STREAMING</code>。不用每次使用<code class="email">rhdfs</code>时都设置配置，您可以将配置放在<code class="email">.rprofile</code>文件中。因此，每次启动R会话时，都会自动加载配置。</li><li class="listitem" value="4"><a id="ch12lvl1sec137" class="calibre1"/>用RHadoop实现字数统计问题</li></ol><div/></div></div></div></body></html>


<html>
  <head>
    <title>Operating HDFS with rhdfs</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_3">为了演示MapReduce如何工作，我们举例说明了一个单词计数的例子，它计算每个单词在给定输入集中出现的次数。在这个菜谱中，我们将演示如何使用<code class="email">rmr2</code>来实现字数统计问题。</h2></div></div></div><p class="calibre7">准备就绪</p><p class="calibre7">在这个食谱中，我们需要一个输入文件作为我们的字数统计程序输入。你可以从https://github.com/ywchiu/ml_R_cookbook/tree/master/CH12的<a class="calibre1" href="https://github.com/ywchiu/ml_R_cookbook/tree/master/CH12">下载</a><a id="id1009" class="calibre1"/>示例输入。</p><p class="calibre7"><a id="ch12lvl2sec478" class="calibre1"/>怎么做...</p></div></div></body></html>


<html>
  <head>
    <title>Operating HDFS with rhdfs</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_4">执行<a id="id1010" class="calibre1"/>以下步骤实施字数统计程序:</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">首先，您需要配置系统环境，然后将<code class="email">rmr2</code>和<code class="email">rhdfs</code>加载到R会话中。如果您使用不同版本的QuickStart VM，您可能需要更新JAR文件的使用:<div> <pre class="programlisting"> <strong class="calibre2">&gt; Sys.setenv(HADOOP_CMD="/usr/bin/hadoop")</strong> <strong class="calibre2">&gt; Sys.setenv(HADOOP_STREAMING="/usr/lib/hadoop-mapreduce/hadoop-streaming-2.5.0-cdh5.2.0.jar ")</strong> <strong class="calibre2">&gt; library(rmr2)</strong> <strong class="calibre2">&gt; library(rhdfs)</strong> <strong class="calibre2">&gt; hdfs.init()</strong> </pre> </div></li></ul></div></div></div></body></html>


<html>
  <head>
    <title>Implementing a word count problem with RHadoop</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div/><div><div><div><div><h1 class="title" id="calibre_pb_0">然后，您可以在HDFS上创建一个目录，并将输入文件放入新创建的目录:<div> <pre class="programlisting"> <strong class="calibre2">&gt; hdfs.mkdir("/user/cloudera/wordcount/data")</strong> <strong class="calibre2">&gt; hdfs.put("wc_input.txt", "/user/cloudera/wordcount/data")</strong> </pre> </div></h1></div></div></div><p class="calibre7">接下来，你可以创建一个<code class="email">map</code>函数:<div> <pre class="programlisting"> <strong class="calibre2">&gt; map = function(.,lines) { keyval(</strong> <strong class="calibre2">+   unlist(</strong> <strong class="calibre2">+     strsplit(</strong> <strong class="calibre2">+       x = lines, </strong> <strong class="calibre2">+       split = " +")),</strong> <strong class="calibre2">+   1)}</strong> </pre> </div></p></div></body></html>


<html>
  <head>
    <title>Implementing a word count problem with RHadoop</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_1">创建一个<code class="email">reduce</code>功能:<div> <pre class="programlisting"> <strong class="calibre2">&gt; reduce = function(word, counts) { </strong> <strong class="calibre2">+   keyval(word, sum(counts)) </strong> <strong class="calibre2">+ }</strong> </pre> </div></h2></div></div></div><p class="calibre7">调用<code class="email">MapReduce</code>程序统计文档中的字数:<div> <pre class="programlisting"> <strong class="calibre2">&gt; hdfs.root = 'wordcount' &gt; hdfs.data = file.path(hdfs.root, 'data')</strong> <strong class="calibre2">&gt; hdfs.out = file.path(hdfs.root, 'out')</strong> <strong class="calibre2">&gt; wordcount = function (input, output=NULL) { </strong> <strong class="calibre2">+  mapreduce(input=input, output=output, input.format="text", map=map, </strong> <strong class="calibre2">+  reduce=reduce) </strong> <strong class="calibre2">+ } </strong> <strong class="calibre2">&gt; out = wordcount(hdfs.data, hdfs.out)</strong> </pre> </div></p></div></div></body></html>


<html>
  <head>
    <title>Implementing a word count problem with RHadoop</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_2">最后，您可以检索文档中出现的前10个单词:<div> <pre class="programlisting"> <strong class="calibre2">&gt; results = from.dfs(out) </strong> <strong class="calibre2">&gt; results$key[order(results$val, decreasing = TRUE)][1:10]</strong> </pre> </div></h2></div></div></div><p class="calibre7">它是如何工作的...</p><div><ol class="orderedlist"><li class="listitem" value="1">在这个<a id="id1011" class="calibre1"/>菜谱中，我们演示了如何使用<code class="email">rmr2</code>包实现字数统计。首先，我们需要配置系统环境并将<code class="email">rhdfs</code>和<code class="email">rmr2</code>加载到r中。然后，我们通过<code class="email">hdfs.put</code>函数指定将我们的字数统计程序从本地文件系统输入到HDFS目录<code class="email">/user/cloudera/wordcount/data</code>。</li><li class="listitem" value="2">接下来，我们开始实现MapReduce程序。通常，我们可以将MapReduce程序分为<code class="email">map</code>和<code class="email">reduce</code>两个函数。在<code class="email">map</code>函数中，我们首先使用<code class="email">strsplit</code>函数将每一行拆分成单词。然后，当<code class="email">strsplit</code>函数返回单词列表时，我们可以使用<code class="email">unlist</code>函数对向量进行字符化。最后，我们可以返回键-值对，每个单词作为一个键，值作为一个键。当<code class="email">reduce</code>函数接收到从<code class="email">map</code>函数生成的键值对时，<code class="email">reduce</code>函数对计数求和，并返回每个单词(或键)的出现次数。</li><li class="listitem" value="3">在我们实现了<code class="email">map</code>和<code class="email">reduce</code>功能后，我们可以通过<code class="email">mapreduce</code>功能提交我们的作业。通常情况下，<code class="email">mapreduce</code>功能需要四个输入，分别是HDFS输入路径、HDFS输出路径、map功能和reduce功能。在这种情况下，我们指定输入为<code class="email">wordcount/data</code>，输出为<code class="email">wordcount/out</code>，映射<code class="email"> </code>函数为<code class="email">map</code>，化简函数为<code class="email">reduce</code>，并将<code class="email">mapreduce</code>调用包装在函数<code class="email">wordcount</code>中。最后，我们调用函数<code class="email">wordcount</code>，并将输出路径存储在变量<code class="email">out</code>中。</li><li class="listitem" value="4">我们可以使用<code class="email">from.dfs</code>函数将HDFS数据加载到<code class="email">results</code>变量中，该变量包含单词和出现次数的映射。然后，我们可以从<code class="email">results</code>变量中生成前10个出现的单词。</li><li class="listitem" value="5"><a id="ch12lvl2sec480" class="calibre1"/>亦见</li><li class="listitem" value="6">在这个菜谱中，我们演示了如何编写一个R MapReduce程序来解决一个<a id="id1012" class="calibre1"/>字数问题。不过如果<a id="id1013" class="calibre1"/>你对如何编写一个原生Java MapReduce程序感兴趣，可以参考<a class="calibre1" href="http://hadoop.apache.org/docs/current/hadoop-mapreduce-client/hadoop-mapreduce-client-core/MapReduceTutorial.html">http://Hadoop . Apache . org/docs/current/Hadoop-MapReduce-client/Hadoop-MapReduce-client-core/MapReduce tutorial . html</a>。</li></ol><div/></div></div></div></body></html>


<html>
  <head>
    <title>Implementing a word count problem with RHadoop</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch12lvl1sec138" class="calibre1"/>比较R MapReduce程序和标准R程序的性能</h2></div></div></div><p class="calibre7">那些不熟悉Hadoop如何工作的人可能经常会将Hadoop视为大数据处理的补救措施。有些人可能认为Hadoop可以在几毫秒内返回任何大小数据的处理结果。在这个菜谱中，我们将比较R MapReduce程序和标准R程序的性能，以证明Hadoop并不像某些人认为的那样快。</p><p class="calibre7">准备就绪</p><p class="calibre7">在这个配方中，您应该已经通过将<code class="email">rmr2</code>安装到R环境中完成了前面的配方。</p><p class="calibre7"><a id="ch12lvl2sec482" class="calibre1"/>怎么做...</p></div></div></body></html>


<html>
  <head>
    <title>Implementing a word count problem with RHadoop</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_4">执行以下步骤来比较标准R程序和R MapReduce程序的性能:</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">首先，你可以实现一个标准的R程序来计算所有数字的平方:<div> <pre class="programlisting"> <strong class="calibre2">&gt; a.time = proc.time() </strong> <strong class="calibre2">&gt; small.ints2=1:100000 </strong> <strong class="calibre2">&gt; result.normal = sapply(small.ints2, function(x) x^2) </strong> <strong class="calibre2">&gt; proc.time() - a.time</strong> </pre> </div></li></ul></div></div></div></body></html>


<html>
  <head>
    <title>Comparing the performance between an R MapReduce program and a standard R program</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div/><div><div><div><div><h1 class="title" id="calibre_pb_0">为了比较性能，您可以实现一个R MapReduce程序来计算所有数字的平方:<div> <pre class="programlisting"> <strong class="calibre2">&gt; b.time = proc.time() </strong> <strong class="calibre2">&gt; small.ints= to.dfs(1:100000) </strong> <strong class="calibre2">&gt; result = mapreduce(input = small.ints, map = function(k,v)       cbind(v,v^2)) </strong> <strong class="calibre2">&gt; proc.time() - b.time</strong> </pre> </div></h1></div></div></div><p class="calibre7"><a id="ch12lvl2sec483" class="calibre1"/>工作原理...</p></div></body></html>


<html>
  <head>
    <title>Comparing the performance between an R MapReduce program and a standard R program</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_1">在这个配方中，我们实现了两个程序来计算所有数字的平方。在第一个程序中，我们使用一个标准的R函数<code class="email">sapply</code>，对1到100，000的序列求平方。为了记录程序执行时间，我们先在<code class="email">a.time</code>中记录<a id="id1016" class="calibre1"/>执行前的加工时间，然后在执行后从当前加工时间中减去<code class="email">a.time</code>。通常，执行时间不超过10秒。在第二个程序中，我们<a id="id1017" class="calibre1"/>使用<code class="email">rmr2</code>包来实现一个R MapReduce版本的程序。在这个程序中，我们还记录了执行时间。通常，这个程序需要几分钟来完成一项任务。</h2></div></div></div><p class="calibre7">性能比较表明，在处理少量数据时，标准R程序优于MapReduce程序。这是因为Hadoop系统通常需要时间来生成守护进程、守护进程之间的作业协调以及从数据节点获取数据。因此，MapReduce程序通常需要几分钟到几个小时来完成执行。因此，如果你能把数据存储在内存中，你应该写一个标准的R程序来解决这个问题。否则，如果数据太大而不适合内存，您可以实现MapReduce解决方案。</p></div></div></body></html>


<html>
  <head>
    <title>Comparing the performance between an R MapReduce program and a standard R program</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch12lvl2sec484" class="calibre1"/>参见</h2></div></div></div><p class="calibre7">为了检查一个作业在Hadoop中是否会平稳高效地运行，可以运行一个MapReduce基准程序MRBench来评估作业的性能:<div> <pre class="programlisting"> <strong class="calibre2">$ hadoop jar /usr/lib/hadoop-0.20-mapreduce/hadoop-test.jar mrbench -numRuns 50</strong> </pre> </div></p><div><ol class="orderedlist"><li class="listitem" value="1"><a id="ch12lvl1sec139" class="calibre1"/>测试和调试rmr2程序</li><li class="listitem" value="2">由于运行MapReduce程序需要相当长的时间，从几分钟到几个小时不等，测试和调试变得非常重要。在这份食谱中，我们将举例说明一些你可以用来排除R MapReduce程序故障的技术。</li></ol><div/></div></div></div></body></html>


<html>
  <head>
    <title>Comparing the performance between an R MapReduce program and a standard R program</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch12lvl2sec485" class="calibre1"/>准备就绪</h2></div></div></div><p class="calibre7">在这个配方中，您应该已经通过将<code class="email">rmr2</code>安装到R环境中完成了前面的配方。</p><p class="calibre7"><a id="ch12lvl2sec486" class="calibre1"/>怎么做...</p></div></div></body></html>


<html>
  <head>
    <title>Comparing the performance between an R MapReduce program and a standard R program</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_4">执行以下步骤来测试和调试R MapReduce程序:</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">首先，您可以在<code class="email">rmr.options</code> : <div> <pre class="programlisting"> <strong class="calibre2">&gt; rmr.options(backend = 'local')</strong> </pre> </div>中将后端配置为本地</li></ul></div></div></div></body></html>


<html>
  <head>
    <title>Testing and debugging the rmr2 program</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div/><div><div><div><div><h1 class="title" id="calibre_pb_0">同样，你<a id="id1020" class="calibre1"/>可以执行前面提到的数字平方MapReduce程序:<div> <pre class="programlisting"> <strong class="calibre2">&gt; b.time = proc.time() </strong> <strong class="calibre2">&gt; small.ints= to.dfs(1:100000) </strong> <strong class="calibre2">&gt; result = mapreduce(input = small.ints, map = function(k,v)       cbind(v,v^2)) </strong> <strong class="calibre2">&gt; proc.time() - b.time</strong> </pre> </div></h1></div></div></div><p class="calibre7">除了<a id="id1021" class="calibre1"/>之外，如果想打印MapReduce程序中任意变量的结构信息，可以使用<code class="email">rmr.str</code>函数:<div> <pre class="programlisting"> <strong class="calibre2">&gt; out = mapreduce(to.dfs(1), map = function(k, v) rmr.str(v))</strong> <strong class="calibre2">Dotted pair list of 14</strong> <strong class="calibre2"> $ : language mapreduce(to.dfs(1), map = function(k, v) rmr.str(v))</strong> <strong class="calibre2"> $ : language mr(map = map, reduce = reduce, combine = combine, vectorized.reduce, in.folder = if (is.list(input)) {     lapply(input, to.dfs.path) ...</strong> <strong class="calibre2"> $ : language c.keyval(do.call(c, lapply(in.folder, function(fname) {     kv = get.data(fname) ...</strong> <strong class="calibre2"> $ : language do.call(c, lapply(in.folder, function(fname) {     kv = get.data(fname) ...</strong> <strong class="calibre2"> $ : language lapply(in.folder, function(fname) {     kv = get.data(fname) ...</strong> <strong class="calibre2"> $ : language FUN("/tmp/Rtmp813BFJ/file25af6e85cfde"[[1L]], ...)</strong> <strong class="calibre2"> $ : language unname(tapply(1:lkv, ceiling((1:lkv)/(lkv/(object.size(kv)/10^6))), function(r) {     kvr = slice.keyval(kv, r) ...</strong> <strong class="calibre2"> $ : language tapply(1:lkv, ceiling((1:lkv)/(lkv/(object.size(kv)/10^6))), function(r) {     kvr = slice.keyval(kv, r) ...</strong> <strong class="calibre2"> $ : language lapply(X = split(X, group), FUN = FUN, ...)</strong> <strong class="calibre2"> $ : language FUN(X[[1L]], ...)</strong> <strong class="calibre2"> $ : language as.keyval(map(keys(kvr), values(kvr)))</strong> <strong class="calibre2"> $ : language is.keyval(x)</strong> <strong class="calibre2"> $ : language map(keys(kvr), values(kvr))</strong> <strong class="calibre2"> $ :length 2 rmr.str(v)</strong> <strong class="calibre2">  ..- attr(*, "srcref")=Class 'srcref'  atomic [1:8] 1 34 1 58 34 58 1 1</strong> <strong class="calibre2">  .. .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' &lt;environment: 0x3f984f0&gt; </strong> <strong class="calibre2">v</strong> <strong class="calibre2"> num 1</strong> </pre> </div></p></div></body></html>


<html>
  <head>
    <title>Testing and debugging the rmr2 program</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch12lvl2sec487" class="calibre1"/>工作原理...</h2></div></div></div><p class="calibre7">在这个<a id="id1022" class="calibre1"/>食谱中，我们介绍了一些调试和测试<a id="id1023" class="calibre1"/>技术，你可以在实现MapReduce程序时使用。首先，我们介绍了在本地模式下测试MapReduce程序的技术。如果您希望以伪分布式或完全分布式模式运行MapReduce程序，那么您将需要几分钟到几个小时来完成任务，这将会浪费大量时间来排除MapReduce程序的故障。因此，您可以在<code class="email">rmr.options</code>中将后端设置为本地模式，这样程序将在本地模式下执行，这将花费较少的执行时间。</p></div></div></body></html>


<html>
  <head>
    <title>Testing and debugging the rmr2 program</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_2">另一种调试技术是在<code class="email">map</code>或<code class="email">reduce</code>函数中列出变量的内容。在R程序中，可以使用<code class="email">str</code>函数来显示单个变量的紧凑结构。在<code class="email">rmr2</code>中，这个包还提供了一个名为<code class="email">rmr.str</code>的函数，它允许你将单个变量的内容打印到控制台上。在这个例子中，我们使用<code class="email">rmr.str</code>来打印MapReduce程序中变量的内容。</h2></div></div></div><p class="calibre7"><a id="ch12lvl2sec488" class="calibre1"/>亦见</p><div><ol class="orderedlist"><li class="listitem" value="1">对<code class="email">rmr2</code>包的<code class="email">option</code>设置感兴趣的可以参考<code class="email">rmr.options</code>的帮助文档:<div> <pre class="programlisting"> <strong class="calibre2">&gt; help(rmr.options)</strong> </pre> </div></li><li class="listitem" value="2"><a id="ch12lvl1sec140" class="calibre1"/>安装plyrmr</li><li class="listitem" value="3"><code class="email">plyrmr</code>包<a id="id1024" class="calibre1"/>为<a id="id1025" class="calibre1"/>用户提供了通用操作(如<code class="email">plyr</code>或<code class="email">reshape2</code>中所示),以便通过MapReduce框架轻松执行数据操作。在这个菜谱中，我们将介绍如何在Hadoop系统上安装<code class="email">plyrmr</code>。</li></ol><div/></div></div></div></body></html>


<html>
  <head>
    <title>Testing and debugging the rmr2 program</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_3">做好准备</h2></div></div></div><p class="calibre7">通过启动Cloudera QuickStart虚拟机并将虚拟机连接到互联网，确保您已经完成了前面的步骤。此外，您需要预先安装<code class="email">rmr2</code>包。</p><p class="calibre7"><a id="ch12lvl2sec490" class="calibre1"/>怎么做...</p></div></div></body></html>


<html>
  <head>
    <title>Testing and debugging the rmr2 program</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_4">执行以下步骤在Hadoop系统上安装<code class="email">plyrmr</code>:</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">首先你要在Linux shell中安装<code class="email">libxml2-devel</code>和<code class="email">curl-devel</code>:<div><pre class="programlisting"> <strong class="calibre2">$ yum install libxml2-devel</strong> <strong class="calibre2">$ sudo yum install curl-devel</strong> </pre></div></li></ul></div></div></div></body></html>


<html>
  <head>
    <title>Installing plyrmr</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div/><div><div><div><div><h1 class="title" id="calibre_pb_0">然后您可以访问R并安装依赖包:<div> <pre class="programlisting"> <strong class="calibre2">$ sudo R</strong> <strong class="calibre2">&gt; Install.packages(c(" Rcurl", "httr"),  dependencies = TRUE</strong> <strong class="calibre2">&gt; Install.packages("devtools", dependencies = TRUE)</strong> <strong class="calibre2">&gt; library(devtools)</strong> <strong class="calibre2">&gt; install_github("pryr", "hadley")</strong> <strong class="calibre2">&gt; install.packages(c(" R.methodsS3", "hydroPSO"),  dependencies = TRUE)</strong> <strong class="calibre2">&gt; q()</strong> </pre> </div></h1></div></div></div><p class="calibre7">接下来可以下载<code class="email">plyrmr 0.5.0</code>并安装在Hadoop VM上。如果Revolution Analytics升级了<code class="email">plyrmr</code> : <div> <pre class="programlisting"> <strong class="calibre2">$ wget -no-check-certificate https://raw.github.com/RevolutionAnalytics/plyrmr/master/build/plyrmr_0.5.0.tar.gz</strong> <strong class="calibre2">$ sudo R CMD INSTALL plyrmr_0.5.0.tar.gz</strong> </pre> </div>的版本，您可能需要更新链接</p></div></body></html>


<html>
  <head>
    <title>Installing plyrmr</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_1">最后，验证安装:<div> <pre class="programlisting"> <strong class="calibre2">$ R</strong> <strong class="calibre2">&gt; library(plyrmr)</strong> </pre> </div></h2></div></div></div><p class="calibre7">它是如何工作的...</p></div></div></body></html>


<html>
  <head>
    <title>Installing plyrmr</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_2">除了使用<code class="email">rmr2</code>包编写R MapReduce程序，您还可以使用<code class="email">plyrmr</code>来操作数据。<code class="email">plyrmr</code>包类似于Hadoop生态系统中的hive和pig，是MapReduce程序的抽象。因此，我们可以用<code class="email">plyr</code>风格实现一个R MapReduce程序，而不是实现<code class="email">map</code> f和<code class="email">reduce</code>函数。</h2></div></div></div><p class="calibre7">要安装<code class="email">plyrmr</code>，首先使用<code class="email">yum install</code>命令安装<code class="email">libxml2-devel</code>和<code class="email">curl-devel</code>的组件。然后，访问R并安装依赖包。最后，从GitHub下载<a id="id1026" class="calibre1"/>文件并将<code class="email">plyrmr</code>安装到r。</p><div><ol class="orderedlist"><li class="listitem" value="1"><a id="ch12lvl2sec492" class="calibre1"/>亦见</li><li class="listitem" value="2">要阅读<a id="id1027" class="calibre1"/>更多关于<code class="email">plyrmr</code>的信息，您可以使用<code class="email">help</code>功能查阅以下文档:<div> <pre class="programlisting"> <strong class="calibre2">&gt; help(package=plyrmr) </strong> </pre> </div></li><li class="listitem" value="3"><a id="ch12lvl1sec141" class="calibre1"/>使用plyrmr操作数据</li><li class="listitem" value="4">虽然用<code class="email">rmr2</code>编写MapReduce程序比编写原生Java版本容易得多，但对于非开发人员来说，编写MapReduce程序仍然很难。因此，可以使用MapReduce程序的高级抽象<code class="email">plyrmr</code>，这样就可以使用类似plyr的操作来操作大数据。在这个菜谱中，我们将介绍一些可以用来操作数据的操作。</li></ol><div/></div></div></div></body></html>


<html>
  <head>
    <title>Installing plyrmr</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_3">准备就绪</h2></div></div></div><p class="calibre7">在这个食谱中，你应该已经通过在r中安装<code class="email">plyrmr</code>和<code class="email">rmr2</code>完成了前面的食谱</p><p class="calibre7"><a id="ch12lvl2sec494" class="calibre1"/>怎么做...</p></div></div></body></html>


<html>
  <head>
    <title>Installing plyrmr</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_4">执行以下步骤，用<code class="email">plyrmr</code>操作数据:</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">首先，你需要将<code class="email">plyrmr</code>和<code class="email">rmr2</code>都加载到R: <div> <pre class="programlisting"> <strong class="calibre2">&gt; library(rmr2)</strong> <strong class="calibre2">&gt; library(plyrmr)</strong> </pre> </div></li></ul></div></div></div></body></html>


<html>
  <head>
    <title>Manipulating data with plyrmr</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div/><div><div><div><div><h1 class="title" id="calibre_pb_0">然后可以将执行模式设置为本地模式:<div> <pre class="programlisting"> <strong class="calibre2">&gt; plyrmr.options(backend="local")</strong> </pre> </div></h1></div></div></div><p class="calibre7">接下来，将泰坦尼克号数据集加载到R: <div> <pre class="programlisting"> <strong class="calibre2">&gt; data(Titanic)</strong> <strong class="calibre2">&gt; titanic = data.frame(Titanic)</strong> </pre> </div></p></div></body></html>


<html>
  <head>
    <title>Manipulating data with plyrmr</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_1">通过过滤数据开始操作:<div> <pre class="programlisting"> <strong class="calibre2">&gt; where(</strong> <strong class="calibre2">+    Titanic, </strong> <strong class="calibre2">+ Freq &gt;=100)</strong> </pre> </div></h2></div></div></div><p class="calibre7">您也可以使用管道运算符来过滤数据:<div> <pre class="programlisting"> <strong class="calibre2">&gt; titanic %|% where(Freq &gt;=100)</strong> </pre> </div></p></div></div></body></html>


<html>
  <head>
    <title>Manipulating data with plyrmr</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_2">将泰坦尼克号数据放入HDFS，并将数据的路径加载到变量中，<code class="email">tidata</code> : <div> <pre class="programlisting"> <strong class="calibre2">&gt; tidata = to.dfs(data.frame(Titanic), output = '/tmp/titanic')</strong> <strong class="calibre2">&gt; tidata</strong> </pre> </div></h2></div></div></div><p class="calibre7">接下来，您可以从泰坦尼克号数据中生成频率的总和:<div> <pre class="programlisting"> <strong class="calibre2">&gt; input(tidata) %|% transmute(sum(Freq))</strong> </pre> </div></p><div><ol class="orderedlist"><li class="listitem" value="1">你<a id="id1029" class="calibre1"/>也可以按性别分组频率:<div> <pre class="programlisting"> <strong class="calibre2">&gt; input(tidata) %|% group(Sex) %|% transmute(sum(Freq))</strong> </pre> </div></li><li class="listitem" value="2">然后，您可以从总体中抽取10条记录:<div> <pre class="programlisting"> <strong class="calibre2">&gt; sample(input(tidata), n=10)</strong> </pre> </div></li><li class="listitem" value="3">除此之外，还可以使用plyrmr连接两个数据集:<div> <pre class="programlisting"> <strong class="calibre2">&gt; convert_tb = data.frame(Label=c("No","Yes"), Symbol=c(0,1))</strong> <strong class="calibre2">ctb = to.dfs(convert_tb, output = 'convert')</strong> <strong class="calibre2">&gt; as.data.frame(plyrmr::merge(input(tidata), input(ctb), by.x="Survived", by.y="Label"))</strong> <strong class="calibre2">&gt; file.remove('convert')</strong> </pre> </div></li><li class="listitem" value="4">它是如何工作的...</li><li class="listitem" value="5">在这个菜谱中，我们介绍如何使用<code class="email">plyrmr</code>来操作数据。首先，我们需要将<code class="email">plyrmr</code>包加载到r中，然后，类似于<code class="email">rmr2</code>，你要将<code class="email">plyrmr</code>的后端选项设置为本地模式。否则，如果<code class="email">plyrmr</code>在Hadoop模式下运行(默认设置)，您将不得不等待几分钟到几个小时。</li><li class="listitem" value="6">接下来，我们可以从数据过滤开始数据操作。在步骤4中，您可以选择调用嵌套在另一个函数调用中的函数。另一方面，您可以使用管道操作符<code class="email">%|%</code>来链接多个操作。因此，我们可以像步骤4一样过滤数据，在步骤5中使用管道操作符。</li><li class="listitem" value="7">接下来，您可以根据当前运行模式使用<code class="email">to.dfs</code>将数据集输入到HDFS或本地文件系统中。该函数将生成数据集的路径，并将其保存在变量<code class="email">tidata</code>中。通过知道路径，您可以使用<code class="email">input</code>函数访问数据。接下来，我们演示如何使用<code class="email">transmute</code>和<code class="email">sum</code>函数从Titanic数据集生成频率的总和。另外，<code class="email">plyrmr</code>允许用户按性别汇总频率。</li><li class="listitem" value="8">此外，为了从总体中抽取数据样本，您还可以使用<code class="email">sample</code>函数从Titanic数据集中选择10条记录。最后，我们演示如何使用<code class="email">plyrmr</code>中的<code class="email">merge</code>函数连接两个数据集。</li><li class="listitem" value="9"><a id="ch12lvl2sec496" class="calibre1"/>亦见</li><li class="listitem" value="10">这里<a id="id1030" class="calibre1"/>我们列出了一些可以用来用<code class="email">plyrmr</code>操作数据的函数。您可以参考<code class="email">help</code>功能，了解其用法和功能的更多详情:</li></ol><div/></div></div></div></body></html>


<html>
  <head>
    <title>Manipulating data with plyrmr</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_3">数据操作:<div> <ul class="itemizedlist3"> <li class="listitem"> <code class="email">bind.cols</code>:这增加了新的列</li> <li class="listitem"> <code class="email">select</code>:这用于选择列</li> <li class="listitem"> <code class="email">where</code>:这用于选择行</li> <li class="listitem"> <code class="email">transmute</code>:这使用了上面所有的加上它们的摘要</li> </ul> </div></h2></div></div></div><p class="calibre7"><code class="email">bind.cols</code>:增加新栏目</p><p class="calibre7"><code class="email">select</code>:用于选择列</p><p class="calibre7"><code class="email">where</code>:用于选择行</p><p class="calibre7"><code class="email">transmute</code>:这使用了以上所有内容以及它们的摘要</p></div></div></body></html>


<html>
  <head>
    <title>Manipulating data with plyrmr</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_4">从<code class="email">reshape2</code> : <div> <ul class="itemizedlist3"> <li class="listitem"> <code class="email">melt</code>和<code class="email">dcast</code>:转换长而宽的数据帧</li> </ul> </div></h2></div></div></div><p class="calibre7"><code class="email">melt</code>和<code class="email">dcast</code>:转换长而宽的数据帧</p><div><ul class="itemizedlist"><li class="listitem">总结:<div><ul class="itemizedlist3"><li class="listitem"><code class="email">count</code></li><li class="listitem"><code class="email">quantile</code></li><li class="listitem"><code class="email">sample</code></li></ul></div></li><li class="listitem"><code class="email">top.k</code></li><li class="listitem"><a id="ch12lvl1sec142" class="calibre1"/>用RHadoop进行机器学习</li><li class="listitem"><a id="ch12lvl2sec498" class="calibre1"/>怎么做...</li></ul></div></div></div></body></html>


<html>
  <head>
    <title>Conducting machine learning with RHadoop</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div/><div><div><div><div><h1 class="title" id="calibre_pb_0">然后您可以通过调用<code class="email">lm</code>函数:<div> <pre class="programlisting"> <strong class="calibre2">&gt; model = lm(y~X)</strong> <strong class="calibre2">&gt; summary(model)</strong>  <strong class="calibre2">Call:</strong> <strong class="calibre2">lm(formula = y ~ X)</strong>  <strong class="calibre2">Residuals:</strong> <strong class="calibre2">    Min      1Q  Median      3Q     Max </strong> <strong class="calibre2">-3.5694 -0.9634 -0.0921  1.0426  5.1238 </strong>  <strong class="calibre2">Coefficients:</strong> <strong class="calibre2">            Estimate Std. Error t value Pr(&gt;|t|)    </strong> <strong class="calibre2">(Intercept)  -0.3567     0.6923  -0.515    0.607    </strong> <strong class="calibre2">X             4.0341     0.2503  16.119   &lt;2e-16 ***</strong> <strong class="calibre2">---</strong> <strong class="calibre2">Signif. codes:  </strong> <strong class="calibre2">0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</strong>  <strong class="calibre2">Residual standard error: 1.452 on 142 degrees of freedom</strong> <strong class="calibre2">Multiple R-squared:  0.6466,  Adjusted R-squared:  0.6441 </strong> <strong class="calibre2">F-statistic: 259.8 on 1 and 142 DF,  p-value: &lt; 2.2e-16</strong> </pre> </div>生成一个线性回归模型</h1></div></div></div><p class="calibre7">cats数据集的线性回归图</p></div></body></html>


<html>
  <head>
    <title>Conducting machine learning with RHadoop</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch12lvl2sec497" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre7">将<code class="email">rmr2</code>载入R: <div> <pre class="programlisting"> <strong class="calibre2">&gt; Sys.setenv(HADOOP_CMD="/usr/bin/hadoop")</strong> <strong class="calibre2">&gt; Sys.setenv(HADOOP_STREAMING="/usr/lib/hadoop-mapreduce/hadoop-&gt; streaming-2.5.0-cdh5.2.0.jar")</strong> <strong class="calibre2">&gt; library(rmr2)</strong> <strong class="calibre2">&gt; rmr.options(backend="local")</strong> </pre> </div></p></div></div></body></html>


<html>
  <head>
    <title>Conducting machine learning with RHadoop</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_2">然后可以设置<code class="email">X</code>和<code class="email">y</code>值:<div> <pre class="programlisting"> <strong class="calibre2">&gt; X = matrix(cats$Bwt)</strong> <strong class="calibre2">&gt; X.index = to.dfs(cbind(1:nrow(X), X))</strong> <strong class="calibre2">&gt; y = as.matrix(cats$Hwt)</strong> </pre> </div></h2></div></div></div><p class="calibre7">做一个<code class="email">Sum</code>函数来汇总数值:<div> <pre class="programlisting"> <strong class="calibre2">&gt; Sum = </strong> <strong class="calibre2">+   function(., YY) </strong> <strong class="calibre2">+     keyval(1, list(Reduce('+', YY)))</strong> </pre> </div></p><div><ol class="orderedlist"><li class="listitem" value="1">在<a id="id1037" class="calibre1"/> MapReduce中计算<code class="email">Xtx</code>，<code class="email">Job1</code> : <div> <pre class="programlisting"> <strong class="calibre2">&gt; XtX = </strong> <strong class="calibre2">+    values(</strong> <strong class="calibre2">+      from.dfs(</strong> <strong class="calibre2">+        mapreduce(</strong> <strong class="calibre2">+          input = X.index,</strong> <strong class="calibre2">+          map = </strong> <strong class="calibre2">+            function(., Xi) {</strong> <strong class="calibre2">+              Xi = Xi[,-1]</strong> <strong class="calibre2">+              keyval(1, list(t(Xi) %*% Xi))},</strong> <strong class="calibre2">+          reduce = Sum,</strong> <strong class="calibre2">+          combine = TRUE)))[[1]]</strong> </pre> </div></li><li class="listitem" value="2">你<a id="id1038" class="calibre1"/>然后可以在MapReduce中计算<code class="email">Xty</code>，<code class="email">Job2</code> : <div> <pre class="programlisting"> <strong class="calibre2">Xty = </strong> <strong class="calibre2">+    values(</strong> <strong class="calibre2">+      from.dfs(</strong> <strong class="calibre2">+        mapreduce(</strong> <strong class="calibre2">+          input = X.index,</strong> <strong class="calibre2">+          map = function(., Xi) {</strong> <strong class="calibre2">+            yi = y[Xi[,1],]</strong> <strong class="calibre2">+            Xi = Xi[,-1]</strong> <strong class="calibre2">+            keyval(1, list(t(Xi) %*% yi))},</strong> <strong class="calibre2">+          reduce = Sum,</strong> <strong class="calibre2">+          combine = TRUE)))[[1]]</strong> </pre> </div></li><li class="listitem" value="3">You can <a id="id1035" class="calibre1"/>now make a regression plot with<a id="id1036" class="calibre1"/> the given data points and model:<div><pre class="programlisting">
<strong class="calibre2">&gt; plot(y~X)</strong>
<strong class="calibre2">&gt; abline(model, col="red")</strong>
</pre></div><div><img src="img/00270.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12">最后，您可以从<code class="email">XtX</code>和<code class="email">Xty</code> : <div> <pre class="programlisting"> <strong class="calibre2">&gt; solve(XtX, Xty)</strong> <strong class="calibre2">         [,1]</strong> <strong class="calibre2">[1,] 3.907113</strong> </pre> </div>中导出系数</p></div></div><p class="calibre13">它是如何工作的...</p></li><li class="listitem" value="4">在这个菜谱中，我们演示了如何在r中以MapReduce方式实现线性逻辑回归。在开始实现之前，我们先回顾一下传统的线性模型是如何工作的。我们首先从<code class="email">MASS</code>包中检索<code class="email">cats</code>数据集。然后我们加载<code class="email">X</code>作为体重(<code class="email">Bwt</code>)，加载<code class="email">y</code>作为心脏重量(<code class="email">Hwt</code>)。</li><li class="listitem" value="5">接下来，我们开始使用<code class="email">lm</code>函数将数据拟合到线性回归模型中。然后我们可以<a id="id1039" class="calibre1"/>计算拟合的模型，并获得模型的摘要<a id="id1040" class="calibre1"/>。汇总显示系数为4.0341，截距为-0.3567。此外，我们根据给定的数据点绘制散点图，然后在图上绘制回归线。</li><li class="listitem" value="6">因为我们不能在MapReduce表单中使用<code class="email">lm</code>函数来执行线性回归，所以我们必须以MapReduce的方式重写回归模型。这里，我们将分三步实现线性回归的MapReduce版本，这三步是:用MapReduce job 1计算<code class="email">Xtx</code>值，用MapReduce计算<code class="email">Xty</code>值，<code class="email">job2</code>，然后导出系数值:</li><li class="listitem" value="7">第一步，我们将矩阵<code class="email">X</code>作为输入传递给<code class="email">map</code>函数。然后，<code class="email">map</code>函数计算转置矩阵<code class="email">X</code>和<code class="email">X</code>的叉积。然后<code class="email">reduce</code>函数执行上一节定义的求和运算。</li><li class="listitem" value="8">在第二步中，计算<code class="email">Xty</code>的过程类似于计算<code class="email">XtX</code>。该过程计算转置矩阵<code class="email">X,</code>和<code class="email">y</code>的叉积。然后，<code class="email">reduce</code>函数执行求和运算。</li><li class="listitem" value="9">最后，我们使用<code class="email">solve</code>函数导出系数，它是3.907113。</li></ol><div/></div></div></div></body></html>


<html>
  <head>
    <title>Conducting machine learning with RHadoop</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_3">如结果所示，由<code class="email">lm</code>和MapReduce计算的系数略有不同。一般来说，<code class="email">lm</code>模型计算的系数比MapReduce计算的系数更准确。但是，如果您的数据太大而无法容纳在内存中，您别无选择，只能在MapReduce版本中实现线性回归。</h2></div></div></div><p class="calibre7"><a id="ch12lvl2sec500" class="calibre1"/>参见</p><p class="calibre7">你可以<a id="id1041" class="calibre1"/>访问关于机器学习算法的更多信息:<a class="calibre1" href="https://github.com/RevolutionAnalytics/rmr2/tree/master/pkg/tests">https://github . com/revolution analytics/rmr 2/tree/master/pkg/tests</a></p><p class="calibre7"><a id="ch12lvl1sec143" class="calibre1"/>在Amazon EMR上配置RHadoop集群</p><div><ul class="itemizedlist"><li class="listitem">到目前为止，我们只演示了如何在单个Hadoop节点中运行RHadoop程序。为了在多节点集群上测试我们的RHadoop程序，您唯一需要做的事情就是在Hadoop集群的所有任务节点(带有mapreduce版本1的任务跟踪器或map reduce版本2的节点管理器的节点)上安装RHadoop。然而，部署和安装非常耗时。另一方面，您可以选择在Amazon EMR上部署您的RHadoop程序，这样您只需几分钟就可以在每个任务节点上部署多节点集群和RHadoop。在下面的菜谱中，我们将演示如何在Amazon EMR服务上配置RHadoop集群。</li><li class="listitem">做好准备</li><li class="listitem">在这个<a id="id1042" class="calibre1"/>配方中，你必须在AWS上注册并创建一个<a id="id1043" class="calibre1"/>账户，你还必须知道如何在使用亚马逊EMR之前生成EC2密钥对。</li></ul></div><p class="calibre7">想要了解更多如何开始使用AWS的信息，请参考<a id="id1044" class="calibre1"/>亚马逊在<a class="calibre1" href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EC2_GetStarted.html">http://docs . AWS . Amazon . com/AWS C2/latest/user guide/EC2 _ get started . html</a>提供的教程。</p></div></div></body></html>


<html>
  <head>
    <title>Conducting machine learning with RHadoop</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch12lvl2sec502" class="calibre1"/>怎么做...</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">执行以下步骤在Amazon EMR上配置RHadoop:</li></ul></div></div></div></body></html>


<html>
  <head>
    <title>Configuring RHadoop clusters on Amazon EMR</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div/><div><div><div><div><h1 class="title" id="calibre_pb_0">从AWS控制台访问EMR服务。</h1></div></div></div><p class="calibre7">Until now, we have only demonstrated how to run a RHadoop program in a single Hadoop node. In order to test our RHadoop program on a multi-node cluster, the only thing you need to do is to install RHadoop on all the task nodes (nodes with either task tracker for mapreduce version 1 or node manager for map reduce version 2) of Hadoop clusters. However, the deployment and installation is time consuming. On the other hand, you can choose to deploy your RHadoop program on Amazon EMR, so that you can deploy multi-node clusters and RHadoop on every task node in only a few minutes. In the following recipe, we will demonstrate how to configure RHadoop cluster on an Amazon EMR service.</p></div></body></html>


<html>
  <head>
    <title>Configuring RHadoop clusters on Amazon EMR</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_1">EMR的集群列表</h2></div></div></div><p class="calibre7">In this <a id="id1042" class="calibre1"/>recipe, you must register and create an <a id="id1043" class="calibre1"/>account on AWS, and you also must know how to generate a EC2 key-pair before using Amazon EMR.</p><p class="calibre7">然后，你应该会发现自己在<strong class="calibre2">创建集群</strong>页面(参考<a class="calibre1" href="https://us-west-2.console.aws.amazon.com/elasticmapreduce/home?region=us-west-2#create-cluster:">https://us-west-2 . console . AWS . Amazon . com/elastic MapReduce/home？region = us-west-2 #创建集群:</a>)。</p></div></div></body></html>


<html>
  <head>
    <title>Configuring RHadoop clusters on Amazon EMR</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_2">“创建集群”页中的集群配置</h2></div></div></div><p class="calibre7">Perform the following steps to configure RHadoop on Amazon EMR:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, you can access the console of the Amazon Web Service (refer to <a class="calibre1" href="https://us-west-2.console.aws.amazon.com/console/">https://us-west-2.console.aws.amazon.com/console/</a>) and find EMR in the analytics section. Then, click on <strong class="calibre2">EMR</strong>.<div><img src="img/00271.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12">配置软件和应用程序</p></div></div><p class="calibre13"> </p></li><li class="listitem" value="2">You should <a id="id1045" class="calibre1"/>find yourself in the cluster list of the EMR dashboard (refer to <a class="calibre1" href="https://us-west-2.console.aws.amazon.com/elasticmapreduce/home?region=us-west-2#cluster-list::">https://us-west-2.console.aws.amazon.com/elasticmapreduce/home?region=us-west-2#cluster-list::</a>); click on <strong class="calibre2">Create cluster</strong>.<div><img src="img/00272.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12">在Hadoop集群中配置硬件</p></div></div><p class="calibre13"> </p></li><li class="listitem" value="3">EMR集群主节点的安全性和访问</li><li class="listitem" value="4">Next, you <a id="id1046" class="calibre1"/>should specify <strong class="calibre2">Cluster name</strong> and<a id="id1047" class="calibre1"/> <strong class="calibre2">Log folder S3 location</strong> in the cluster configuration.<div><img src="img/00273.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12">Cluster configuration in the create cluster page</p></div></div><p class="calibre13">要设置<a id="id1050" class="calibre1"/>RHadoop，必须<a id="id1051" class="calibre1"/>执行引导操作，在每个任务节点上安装RHadoop。请编写一个名为<code class="email">bootstrapRHadoop.sh</code>的文件，并在文件中插入以下行:<div> <pre class="programlisting">echo 'install.packages(c("codetools", "Rcpp", "RJSONIO", "bitops", "digest", "functional", "stringr", "plyr", "reshape2", "rJava", "caTools"), repos="http://cran.us.r-project.org")' &gt; /home/hadoop/installPackage.R sudo Rscript /home/hadoop/installPackage.R wget --no-check-certificate https://raw.githubusercontent.com/RevolutionAnalytics/rmr2/master/build/rmr2_3.3.0.tar.gz sudo R CMD INSTALL rmr2_3.3.0.tar.gz wget --no-check-certificate https://raw.github.com/RevolutionAnalytics/rhdfs/master/build/rhdfs_1.0.8.tar.gz sudo HADOOP_CMD=/home/hadoop/bin/hadoop R CMD INSTALL rhdfs_1.0.8.tar.gz</pre> </div></p></li><li class="listitem" value="5">You can then configure the Hadoop distribution on <strong class="calibre2">Software Configuration</strong>.<div><img src="img/00274.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12">你应该把<code class="email">bootstrapRHadoop.sh</code>上传到<code class="email">S3</code>。</p></div></div><p class="calibre13">设置引导操作</p></li><li class="listitem" value="6">Next, you<a id="id1048" class="calibre1"/> can configure the <a id="id1049" class="calibre1"/>number of nodes within the Hadoop cluster.<div><img src="img/00275.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12">Configure the hardware within Hadoop cluster</p></div></div><p class="calibre13">创建集群</p></li><li class="listitem" value="7">You can then specify the EC2 key-pair for the master node login.<div><img src="img/00276.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12">Security and access to the master node of the EMR cluster</p></div></div><p class="calibre13">创建的集群的屏幕截图</p></li><li class="listitem" value="8">To set <a id="id1050" class="calibre1"/>up RHadoop, one has to<a id="id1051" class="calibre1"/> perform bootstrap actions to install RHadoop on every task node. Please write a file named <code class="email">bootstrapRHadoop.sh</code>, and insert the following lines within the file:<div><pre class="programlisting">echo 'install.packages(c("codetools", "Rcpp", "RJSONIO", "bitops", "digest", "functional", "stringr", "plyr", "reshape2", "rJava", "caTools"), repos="http://cran.us.r-project.org")' &gt; /home/hadoop/installPackage.R
sudo Rscript /home/hadoop/installPackage.R
wget --no-check-certificate https://raw.githubusercontent.com/RevolutionAnalytics/rmr2/master/build/rmr2_3.3.0.tar.gz
sudo R CMD INSTALL rmr2_3.3.0.tar.gz
wget --no-check-certificate https://raw.github.com/RevolutionAnalytics/rhdfs/master/build/rhdfs_1.0.8.tar.gz
sudo HADOOP_CMD=/home/hadoop/bin/hadoop R CMD INSTALL rhdfs_1.0.8.tar.gz</pre></div></li><li class="listitem" value="9"><a id="ch12lvl2sec503" class="calibre1"/>工作原理...</li><li class="listitem" value="10">You now need to add the bootstrap action with <code class="email">Custom action</code>, and add <code class="email">s3://&lt;location&gt;/bootstrapRHadoop.sh</code> within the S3 location.<div><img src="img/00277.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12">在这个菜谱中，我们演示了如何在Amazon EMR上设置RHadoop。这样做的好处是，您只需在几分钟内点击几下鼠标，就可以快速创建可扩展的按需Hadoop。这有助于节省构建和部署Hadoop应用程序的时间。但是，您必须为每个实例的运行小时数付费。在使用Amazon EMR之前，您应该创建一个AWS帐户，并知道如何设置EC2密钥对和S3。然后，您可以开始在Amazon EMR上安装RHadoop。</p></div></div><p class="calibre13">第一步，访问EMR集群列表并点击<strong class="calibre2">创建集群</strong>。您可以在<strong class="calibre2">创建集群</strong>页面上看到配置列表。然后，您应该在群集配置中的S3位置设置群集名称和日志文件夹。</p></li><li class="listitem" value="11">Next, you can click on <strong class="calibre2">Create cluster</strong> to launch the Hadoop cluster.<div><img src="img/00278.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12">接下来，您可以设置软件配置并选择您想要安装的Hadoop发行版<a id="id1054" class="calibre1"/>。亚马逊提供了自己的<a id="id1055" class="calibre1"/>发行版和MapR发行版。通常，您会跳过这一节，除非您对默认的Hadoop发行版有所顾虑。</p></div></div><p class="calibre13">然后，您可以通过指定主节点、核心节点和任务节点来配置硬件。默认情况下，只有一个主节点和两个核心节点。如果愿意，您可以添加更多的核心和任务节点。然后，您应该设置密钥对来登录到主节点。</p></li><li class="listitem" value="12">Lastly, you<a id="id1052" class="calibre1"/> should see the master <a id="id1053" class="calibre1"/>public DNS when the cluster is ready. You can now access the terminal of the master node with your EC2-key pair:<div><img src="img/00279.jpeg" alt="How to do it..." class="calibre9"/><div><p class="calibre12">接下来，您应该创建一个包含所有名为<code class="email">bootstrapRHadoop.sh</code>的启动脚本的文件。创建文件后，您应该将文件保存在S3存储中。然后，您可以使用<code class="email">bootstrapRHadoop.sh</code>作为引导脚本，在<strong class="calibre2">引导动作</strong>中指定<code class="email">custom action</code>。最后，您可以点击<code class="email">Create cluster</code>，等待集群就绪。一旦集群准备就绪，就可以看到主公共DNS，并可以使用EC2密钥对来访问主节点的终端。</p></div></div><p class="calibre13">当心！如果不想继续使用EMR服务，请终止正在运行的实例。否则，您将按使用的每个小时为每个实例付费。</p></li></ol><div/></div></div></div></body></html>


<html>
  <head>
    <title>Configuring RHadoop clusters on Amazon EMR</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch12lvl2sec504" class="calibre1"/>参见</h2></div></div></div><p class="calibre7">谷歌还提供了自己的云解决方案——谷歌计算引擎。如果<a id="id1056" class="calibre1"/>想了解更多，请参考<a class="calibre1" href="https://cloud.google.com/compute/">https://cloud.google.com/compute/</a>。</p><p class="calibre7">In the first step, access the EMR cluster list and click on <strong class="calibre2">Create cluster</strong>. You can see a list of configurations on the <strong class="calibre2">Create cluster</strong> page. You should then set up the cluster name and log folder in the S3 location in the cluster configuration. </p><p class="calibre7">Next, you can set up the software configuration and choose the Hadoop distribution you would like to <a id="id1054" class="calibre1"/>install. Amazon provides both its own <a id="id1055" class="calibre1"/>distribution and the MapR distribution. Normally, you would skip this section unless you have concerns about the default Hadoop distribution.</p><p class="calibre7">You can then configure the hardware by specifying the master, core, and task node. By default, there is only one master node, and two core nodes. You can add more core and task nodes if you like. You should then set up the key-pair to login to the master node.</p><p class="calibre7">You should next make a file containing all the start scripts named <code class="email">bootstrapRHadoop.sh</code>. After the file is created, you should save the file in the S3 storage. You can then specify <code class="email">custom action</code> in <strong class="calibre2">Bootstrap Action</strong> with <code class="email">bootstrapRHadoop.sh</code> as the Bootstrap script. Lastly, you can click on <code class="email">Create cluster</code> and wait until the cluster is ready. Once the cluster is ready, one can see the master public DNS and can use the EC2 key-pair to access the terminal of the master node.</p><p class="calibre7">Beware! Terminate the running instance if you do not want to continue using the EMR service. Otherwise, you will be charged per instance for every hour you use.</p></div></div></body></html>


<html>
  <head>
    <title>Configuring RHadoop clusters on Amazon EMR</title>
    <meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  

</head>
  <body id="page" class="calibre">
<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch12lvl2sec504" class="calibre1"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">Google also provides its own cloud solution, the Google compute engine. For those who <a id="id1056" class="calibre1"/>would like to know more, please refer to <a class="calibre1" href="https://cloud.google.com/compute/">https://cloud.google.com/compute/</a>.</li></ul></div></div></div></body></html>
</body></html>